<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YunLinOS Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yunlinos.com/"/>
  <updated>2018-08-10T13:40:36.238Z</updated>
  <id>http://yunlinos.com/</id>
  
  <author>
    <name>YunLinOS</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android触摸事件模拟</title>
    <link href="http://yunlinos.com/archives/8b308b7c.html"/>
    <id>http://yunlinos.com/archives/8b308b7c.html</id>
    <published>2018-08-10T01:40:36.000Z</published>
    <updated>2018-08-10T13:40:36.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用monkey进行压力测试时，我们发现，随机的触摸事件中大约有95%的无效事件，达到深层页面的概率极低，每晚压测的实际有效时间其实只有半小时，且缺少相互依赖的路径，完全无法满足压力测试的需求。而存粹依靠人工测试则效率过低，所以我们会想，能否有一种方式，可以将我们的测试过程录制下来，然后在更多的机器上面循环回放，还能对操作进行加速和减速，并且实时跟踪崩溃数据和性能数据，起到效率更高的压测效果，即<code>Copy once, paste anywhere</code>。在知道<a href="http://yunlinos.com/archives/9f4ea589.html" title="触摸事件原理">触摸事件原理</a>后，我们就开始做这件很Cool的事情，而本文就介绍了整个预研和摸索的过程。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们现在先梳理下我们需要实现的功能，即过程大概如下：</p><ol><li>将触摸事件记录在文本中</li><li>记录相邻事件的时间间隔</li><li>读取文本信息，解析成触摸事件和时间间隔</li><li>将触摸事件注入到系统中，并根据时间间隔进行延时注入</li></ol><p>说到触摸事件注入，那么我们是否有想到之前的这篇文章：<a href="http://yunlinos.com/archives/9f4ea589.html" title="Android触摸事件原理">Android触摸事件原理</a>。在那里介绍了Monkey中常用的两种事件注入方式，即：</p><ol><li><code>InputManager.getInstance().injectInputEvent</code></li><li><code>FileOutputStream(&quot;/dev/input/event0&quot;)</code></li></ol><p>现在，事件注入的方式有了，那么事件来源的方式呢，我们如何得到事件源和事件间隔？下面，我们将以这两种方式作为突破口来实现触摸的录制和回放。</p><h2 id="injectEvent"><a href="#injectEvent" class="headerlink" title="injectEvent"></a>injectEvent</h2><p>在前面的文章中，我们深入了解了injectEvent方法的执行流程，其实就是<code>InputDispatcher</code>对事件进行分发。优点是直接通过应用层去执行，且触摸事件不需要经过任何处理即可进行分发，速度极快，基本上没有任何延迟就可以响应，monkey中大量的随机事件就是用这种方式处理的。</p><p>但最大的问题是，我们如何获取到操作中的触摸事件信息，并保存成文本信息呢。如果仿照<code>monkeyscript</code>的实现方式，在脚本中自定义触摸事件，确实可以生成可用的数据，但是这种工作极其繁琐且效率较低，只能用于单个按钮点击或者短路径的测试场景，对于压力测试这种长时间、多应用的测试场景，就显得力不从心了。</p><p>因此，我们只能从系统的事件源中想办法，通过抓取系统产生的大量事件来生成事件源。想到的方法有两种：</p><ol><li>从getevent拿到数据，即通过监听<code>/dev/input/event*</code>节点来捕获系统input事件。但是这些事件需要通过较为复杂的转换才能在应用层进行注入，且还要处理多指、拖拽等场景，较为麻烦，故暂时不做考虑，如果没有更好的方案可以再回头来看。</li><li>在<code>InputManagerService</code>中通过Socked向上层发送需要分发的数据，这些数据不需要任何处理就能从应用层进行事件注入，但是这样对系统代码的侵入性太强，故也不考虑。</li></ol><p>那么，我们就来看其他方式。</p><h2 id="getevent"><a href="#getevent" class="headerlink" title="getevent"></a>getevent</h2><p>在monkey中，使用的第二种事件注入方式就是通过向设备节点<code>/dev/input/event*</code>中写入触摸数据，然后InputManager中的<code>EventHub</code>就能正常获取到该事件，再进行后续的事件分发。<br>不过，Android官方已经提供了现成的工具做这些工作，包括事件捕获和事件注入，即<code>getevent</code>和<code>sendevent</code>。我们先通过adb命令来看下getevent的用法（触摸事件在哪个设备节点需要先确认，我这台Android设备的触摸事件是在<code>event4</code>）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb shell getevent | grep event4</span><br><span class="line">add device 5: /dev/input/event4</span><br><span class="line">/dev/input/event4: 0003 0039 00000008</span><br><span class="line">/dev/input/event4: 0003 0035 00005cdf</span><br><span class="line">/dev/input/event4: 0003 0036 00003341</span><br><span class="line">/dev/input/event4: 0001 014a 00000001</span><br><span class="line">/dev/input/event4: 0003 0000 00005cdf</span><br><span class="line">/dev/input/event4: 0003 0001 00003341</span><br><span class="line">/dev/input/event4: 0000 0000 00000000</span><br></pre></td></tr></table></figure></p><p>关于<code>getevent</code>的相关参数我们可以详见官方文章：<a href="https://source.android.com/devices/input/getevent" title="https://source.android.com/devices/input/getevent" target="_blank" rel="noopener">https://source.android.com/devices/input/getevent</a><br>这样我们就能获取到系统中的所有的触摸事件，然后根据出现的时间来确定时间间隔，并将这些信息保存成文本中，<code>python</code>实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNeededEvent</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'/dev/input/event4'</span> <span class="keyword">in</span> event <span class="keyword">and</span> <span class="string">'add device'</span> <span class="keyword">not</span> <span class="keyword">in</span> event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCurrentMillisecondTime</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(round(time.time() * <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyInputEvent</span><span class="params">()</span>:</span></span><br><span class="line">    copyCmd = <span class="string">'adb -s %s shell getevent'</span> % deviceIp</span><br><span class="line">    outputStream = os.popen(copyCmd)._stream</span><br><span class="line">    eventSaveFile = open(<span class="string">'Event.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">    eventLine = outputStream.readline()</span><br><span class="line">    currentTime = getCurrentMillisecondTime()</span><br><span class="line">    <span class="keyword">while</span> eventLine:</span><br><span class="line">        <span class="keyword">if</span> isNeededEvent(eventLine):</span><br><span class="line">            intervalTime = getCurrentMillisecondTime() - currentTime</span><br><span class="line">            currentTime = getCurrentMillisecondTime()</span><br><span class="line">            eventStr = <span class="string">'%s#%s'</span> % (intervalTime, eventLine)</span><br><span class="line">            print(intervalTime, eventLine)</span><br><span class="line">            eventSaveFile.write(eventStr)</span><br><span class="line">        eventLine = outputStream.readline()</span><br></pre></td></tr></table></figure></p><p>最终，我们得到的文本内容为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1#/dev/input/event4: 0003 0035 000011a5</span><br><span class="line">0#/dev/input/event4: 0003 0036 00001753</span><br><span class="line">0#/dev/input/event4: 0001 014a 00000001</span><br><span class="line">0#/dev/input/event4: 0003 0000 000011a5</span><br><span class="line">0#/dev/input/event4: 0003 0001 00001753</span><br><span class="line">4#/dev/input/event4: 0000 0000 00000000</span><br><span class="line">20#/dev/input/event4: 0003 0035 000011ae</span><br><span class="line">0#/dev/input/event4: 0003 0036 000017a0</span><br><span class="line">0#/dev/input/event4: 0003 0000 000011ae</span><br><span class="line">0#/dev/input/event4: 0003 0001 000017a0</span><br><span class="line">0#/dev/input/event4: 0000 0000 00000000</span><br><span class="line">5#/dev/input/event4: 0003 0035 000011b9</span><br><span class="line">0#/dev/input/event4: 0003 0036 000017fc</span><br><span class="line">0#/dev/input/event4: 0003 0000 000011b9</span><br><span class="line">4#/dev/input/event4: 0003 0001 000017fc</span><br></pre></td></tr></table></figure></p><h2 id="sendevent"><a href="#sendevent" class="headerlink" title="sendevent"></a>sendevent</h2><p>在得到这些触摸的文本信息，我们就能通过<code>sendevent</code>方法来进行触摸事件注入了，而且能通过事件前面记录的时间间隔来确定延时时间，从而模拟出正常的操作。不过在这之前，我们需要先确认下面几点注意事项，即：</p><ol><li><code>getevent</code>得到的数值是16进制的，<code>sendevent</code>输入的参数是10进制的，注意进行转换</li><li><code>sendevent</code>中没有冒号，即<code>sendevent /dev/input/event4 3 57 579</code>这种方式</li><li>如果执行没有效果，尝试先修改文件权限，在su后调用<code>chmod 777 /dev/input/event[x]</code></li></ol><p>万事俱备，我们现在来撸出事件注入的代码，同样是<code>python实现</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCurrentMillisecondTime</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(round(time.time() * <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTranslatedEvent</span><span class="params">(eventContent)</span>:</span></span><br><span class="line">    event = eventContent.split(<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'%s %s %s %s'</span> % (event[<span class="number">0</span>], int(event[<span class="number">1</span>], <span class="number">16</span>), int(event[<span class="number">2</span>], <span class="number">16</span>), int(event[<span class="number">3</span>], <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pasteInutEvent</span><span class="params">()</span>:</span></span><br><span class="line">    eventSaveFile = open(<span class="string">'Event.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">    eventLines = eventSaveFile.readlines()</span><br><span class="line"></span><br><span class="line">    time3 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> eventLine <span class="keyword">in</span> eventLines:</span><br><span class="line">        eventLine = eventLine.strip(<span class="string">'\n'</span>)</span><br><span class="line">        eventInfo = eventLine.split(<span class="string">'#'</span>)</span><br><span class="line">        intervalTime = eventInfo[<span class="number">0</span>]</span><br><span class="line">        eventContent = eventInfo[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> intervalTime != <span class="string">'0'</span>:</span><br><span class="line">            time.sleep(int(intervalTime) / <span class="number">1000</span>)</span><br><span class="line">        time2 = getCurrentMillisecondTime()</span><br><span class="line">        translatedEvent = getTranslatedEvent(eventContent).replace(<span class="string">':'</span>, <span class="string">''</span>)</span><br><span class="line">        print(<span class="string">'+++%s'</span> % (time2 - time3))</span><br><span class="line">        pasteCmd = <span class="string">'adb -s %s shell sendevent '</span> % deviceIp</span><br><span class="line">        os.system(<span class="string">'%s %s'</span> % (pasteCmd, translatedEvent))</span><br><span class="line">        time3 = getCurrentMillisecondTime()</span><br><span class="line">        print(<span class="string">'---%s'</span> % (time3 - time2))</span><br></pre></td></tr></table></figure></p><p>到了这里，我们就是不是就已经完成了所有的事件录制和回放的功能呢？不，不是的。如果有执行上面这段代码，我们会发现，界面上确实正在回放我们刚刚的操作的路径，不过是以龟速在进行，大概录制一分钟的操作，可能需要十分钟才能执行完，这样的功能并不能满足我们的需要。</p><p>可是，我们确实是按照记录的时间间隔来进行延时处理的，那么问题到底在哪里呢？于是我们在代码中加入日志，打印了方法的执行时间，发现在实际事件注入的地方（<code>os.system(&#39;%s %s&#39; % (pasteCmd, translatedEvent))</code>）耗时较长，大概开销在70ms左右。而我们后面的努力就是要将这块的时间开销降到最低，否则这种方案没有任何实际使用价值。那么我们从<code>sendevent</code>的源码实现入手，源码位于<code>system/core/toolbox/sendevent.c</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendevent_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> fd;</span><br><span class="line">     <span class="keyword">ssize_t</span> ret;</span><br><span class="line">     <span class="keyword">int</span> version;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(argc != <span class="number">5</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"use: %s device type code value\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">     <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"could not open %s, %s\n"</span>, argv[optind], strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (ioctl(fd, EVIOCGVERSION, &amp;version)) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"could not get driver version for %s, %s\n"</span>, argv[optind], strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line">     event.type = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">     event.code = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">     event.value = atoi(argv[<span class="number">4</span>]);</span><br><span class="line">     ret = write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">     <span class="keyword">if</span>(ret &lt; (<span class="keyword">ssize_t</span>) <span class="keyword">sizeof</span>(event)) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"write event failed, %s\n"</span>, strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>代码比较简单，从中我们可以看出事件注入的流程就是：打开文件描述符（13行）、组装事件信息（22-25行）、写入事件信息（26行）、关闭文件描述符（进程关闭时）。而对应我们每一次通过<code>sendevent</code>进行的事件注入，就意味着重复打开关闭文件的操作，根据经验判断，这个过程是非常耗时的。所以我们可以尝试重写该源码来验证我们的判断：在打开文件描述符后，写入所有数据，再关闭文件描述符。</p><p>另外，我们的想法是，通过<code>python</code>脚本录制所有的操作后，直接将事件数据文本导入到Android设备中，然后运行相关服务就可以进行回放。故<code>jni</code>代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line">    __u16 type;</span><br><span class="line">    __u16 code;</span><br><span class="line">    __s32 value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_yunlinos_montioninject_EventInject_openInputSource(JNIEnv *env, jclass type) &#123;</span><br><span class="line">    __android_log_write(ANDROID_LOG_DEBUG, <span class="string">"InjectEvent"</span>, <span class="string">"openInputSource"</span>);</span><br><span class="line">    fd = open(<span class="string">"/dev/input/event4"</span>, O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_yunlinos_montioninject_EventInject_injectEvent(JNIEnv *env, jclass type,</span><br><span class="line">                                                        jstring eventType_, jstring eventCode_,</span><br><span class="line">                                                        jstring eventValue_) &#123;</span><br><span class="line">    __android_log_write(ANDROID_LOG_DEBUG, <span class="string">"InjectEvent"</span>, <span class="string">"injectEvent"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eventType = (*env)-&gt;GetStringUTFChars(env, eventType_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eventCode = (*env)-&gt;GetStringUTFChars(env, eventCode_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eventValue = (*env)-&gt;GetStringUTFChars(env, eventValue_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line"></span><br><span class="line">    event.code = atoi(eventCode);</span><br><span class="line">    event.type = atoi(eventType);</span><br><span class="line">    event.value = atoi(eventValue);</span><br><span class="line"></span><br><span class="line">    write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, eventType_, eventType);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, eventCode_, eventCode);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, eventValue_, eventValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_yunlinos_montioninject_EventInject_closeInputSource(JNIEnv *env, jclass type) &#123;</span><br><span class="line">    __android_log_write(ANDROID_LOG_DEBUG, <span class="string">"InjectEvent"</span>, <span class="string">"closeInputSource"</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而应用层Java代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">openInputSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">injectEvent</span><span class="params">(String eventType, String eventCode, String eventValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">closeInputSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFileEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"/sdcard/Event.txt"</span>));</span><br><span class="line">         InputStreamReader is = <span class="keyword">new</span> InputStreamReader(fis);</span><br><span class="line">         BufferedReader br = <span class="keyword">new</span> BufferedReader(is)) &#123;</span><br><span class="line"></span><br><span class="line">        String txtLine;</span><br><span class="line">        String[] allEvents;</span><br><span class="line">        String[] eventInfo;</span><br><span class="line">        String eventStr;</span><br><span class="line">        <span class="keyword">while</span> ((txtLine = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            InputEvent inputEvent = <span class="keyword">new</span> InputEvent();</span><br><span class="line">            allEvents = txtLine.split(<span class="string">"#"</span>);</span><br><span class="line">            inputEvent.time = Long.parseLong(allEvents[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            eventStr = allEvents[<span class="number">1</span>].replace(<span class="string">":"</span>, <span class="string">""</span>);</span><br><span class="line">            eventInfo = eventStr.split(<span class="string">" "</span>);</span><br><span class="line">            inputEvent.type = String.valueOf(Integer.parseInt(eventInfo[<span class="number">1</span>], <span class="number">16</span>));</span><br><span class="line">            inputEvent.code = String.valueOf(Integer.parseInt(eventInfo[<span class="number">2</span>], <span class="number">16</span>));</span><br><span class="line">            inputEvent.value = String.valueOf(Long.parseLong(eventInfo[<span class="number">3</span>], <span class="number">16</span>));</span><br><span class="line">            inputEvents.add(inputEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectEvent</span><span class="params">(List&lt;InputEvent&gt; inputEventList)</span> </span>&#123;</span><br><span class="line">    EventInject.openInputSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (InputEvent inputEvent : inputEventList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputEvent.time != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(inputEvent.time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        EventInject.injectEvent(inputEvent.type, inputEvent.code, inputEvent.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventInject.closeInputSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>readFileEvent</code>方法用于读取事件信息文本并解析为可使用的事件，<code>injectEvent</code>则是实际事件注入的地方。在运行后，发现能够完美解决我们现有的问题。不过，针对于实际应用场景，还有很多需要优化的点，比如：</p><ul><li>当录制时间过长时，一次性解析所有触摸信息并解析为对象肯定不可能，内存占用太多。可能这个时就候需要使用生产消费者队列了。</li><li>我们还可以配置部分参数，通过处理延时时间的方式，进行回放的加速和减速。</li><li>等等</li></ul><p>这些在这篇文章中就不过多赘述了，各位可以根据自己的业务需要来进行定制化处理。</p><h2 id="项目开源地址"><a href="#项目开源地址" class="headerlink" title="项目开源地址"></a>项目开源地址</h2><p>触摸录制：<a href="https://github.com/yunlinos/MotionCopy" title="https://github.com/yunlinos/MotionCopy" target="_blank" rel="noopener">https://github.com/yunlinos/MotionCopy</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://source.android.com/devices/input/getevent.html" title="http://source.android.com/devices/input/getevent.html" target="_blank" rel="noopener">http://source.android.com/devices/input/getevent.html</a><br><a href="http://source.android.com/devices/input/touch-devices.html" title="http://source.android.com/devices/input/touch-devices.html" target="_blank" rel="noopener">http://source.android.com/devices/input/touch-devices.html</a><br><a href="https://stackoverflow.com/questions/12079591/android-sendevent-is-really-slow-how-to-speed-it-up" title="https://stackoverflow.com/questions/12079591/android-sendevent-is-really-slow-how-to-speed-it-up" target="_blank" rel="noopener">https://stackoverflow.com/questions/12079591/android-sendevent-is-really-slow-how-to-speed-it-up</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用monkey进行压力测试时，我们发现，随机的触摸事件中大约有95%的无效事件，达到深层页面的概率极低，每晚压测的实际有效时间其实只有半
      
    
    </summary>
    
      <category term="Android系统源码" scheme="http://yunlinos.com/categories/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="触摸事件" scheme="http://yunlinos.com/tags/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="自动化测试" scheme="http://yunlinos.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android触摸事件分发--从InputManager到Window</title>
    <link href="http://yunlinos.com/archives/feabfdd.html"/>
    <id>http://yunlinos.com/archives/feabfdd.html</id>
    <published>2018-08-05T07:06:56.000Z</published>
    <updated>2018-08-06T00:01:35.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上篇文章<a href="http://yunlinos.com/archives/9f4ea589.html" title="Android触摸事件原理">Android触摸事件原理</a>中，我们知道了事件注入的原理，也了解了触摸事件的来源与去处。但是，仍然留了两个比较复杂的问题还没解决，那就是：</p><ol><li>将触摸事件发送给Window时，是如何在茫茫人海中确定眼神的？</li><li>他们相隔千山万水，又是如何将触摸事件交付给对方的？</li></ol><p>当然，涉及到跨进程通信，我们的第一反应肯定是Binder机制。毕竟Binder在Android中是使用最多的IPC手段，包括Activity启动、Service启动等等，是效率和安全的象征。那触摸事件的跨进程分发到底是不是使用Binder呢，我们继续往下看。</p><h2 id="如何为触摸事件找到Window"><a href="#如何为触摸事件找到Window" class="headerlink" title="如何为触摸事件找到Window"></a>如何为触摸事件找到Window</h2><p>让时间倒转，回到<code>dispatchMotionLocked</code>：<br>[-&gt; InputDispatcher.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchMotionLocked(</span><br><span class="line">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="comment">// Pointer event.  (eg. touchscreen)</span></span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Non touch event.  (eg. trackball)</span></span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续往下看，进入到<code>findFocusedWindowTargetsLocked</code>中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> InputDispatcher::findFocusedWindowTargetsLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    String8 reason;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前没有获取焦点的窗口或者应用，就丢弃该事件</span></span><br><span class="line">    <span class="keyword">if</span> (mFocusedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocusedApplicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    mFocusedApplicationHandle, <span class="literal">NULL</span>, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);</span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ALOGI(<span class="string">"Dropping event because there is no focused window or focused application."</span>);</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> (! checkInjectionPermission(mFocusedWindowHandle, entry-&gt;injectionState)) &#123;</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测窗口是否为更多的输入操作而准备就绪</span></span><br><span class="line">    reason = checkWindowReadyForMoreInputLocked(currentTime,</span><br><span class="line">            mFocusedWindowHandle, entry, <span class="string">"focused"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reason.isEmpty()) &#123;</span><br><span class="line">        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功找到目标窗口，添加到目标窗口</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    addWindowTargetLocked(mFocusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">Failed:</span><br><span class="line">Unresponsive:</span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatisticsLocked(currentTime, entry,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    ALOGD(<span class="string">"findFocusedWindow finished: injectionResult=%d, "</span></span><br><span class="line">            <span class="string">"timeSpentWaitingForApplication=%0.1fms"</span>,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication / <span class="number">1000000.0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以从代码中的注释看到，会经过权限检查、窗口焦点状态等条件判断。那么，此处的<code>mFocusedWindowHandle</code>又是在哪里赋值的呢？我们可以在InputDispatcher找到赋值的地方：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::setInputWindows(<span class="keyword">const</span> Vector&lt;sp&lt;InputWindowHandle&gt; &gt;&amp; inputWindowHandles) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    ALOGD(<span class="string">"setInputWindows"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Vector&lt;sp&lt;InputWindowHandle&gt; &gt; oldWindowHandles = mWindowHandles;</span><br><span class="line">        mWindowHandles = inputWindowHandles;</span><br><span class="line"></span><br><span class="line">        sp&lt;InputWindowHandle&gt; newFocusedWindowHandle;</span><br><span class="line">        <span class="keyword">bool</span> foundHoveredWindow = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mWindowHandles.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle = mWindowHandles.itemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!windowHandle-&gt;updateInfo() || windowHandle-&gt;getInputChannel() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mWindowHandles.removeAt(i--);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle-&gt;getInfo()-&gt;hasFocus) &#123;</span><br><span class="line">                newFocusedWindowHandle = windowHandle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle == mLastHoverWindowHandle) &#123;</span><br><span class="line">                foundHoveredWindow = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!foundHoveredWindow) &#123;</span><br><span class="line">            mLastHoverWindowHandle = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFocusedWindowHandle != newFocusedWindowHandle) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFocusedWindowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">                ALOGD(<span class="string">"Focus left window: %s"</span>,</span><br><span class="line">                        mFocusedWindowHandle-&gt;getName().<span class="built_in">string</span>());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                sp&lt;InputChannel&gt; focusedInputChannel = mFocusedWindowHandle-&gt;getInputChannel();</span><br><span class="line">                <span class="keyword">if</span> (focusedInputChannel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="function">CancelationOptions <span class="title">options</span><span class="params">(CancelationOptions::CANCEL_NON_POINTER_EVENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="string">"focus left window"</span>)</span></span>;</span><br><span class="line">                    synthesizeCancelationEventsForInputChannelLocked(</span><br><span class="line">                            focusedInputChannel, options);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newFocusedWindowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">                ALOGD(<span class="string">"Focus entered window: %s"</span>,</span><br><span class="line">                        newFocusedWindowHandle-&gt;getName().<span class="built_in">string</span>());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            mFocusedWindowHandle = newFocusedWindowHandle;</span><br><span class="line">        &#125;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>InputDispatcher::setInputWindows</code>中，可以看到这里会对mWindowHandles赋值，也有对mFocusedWindowHandle进行赋值，如果看过<code>findTouchedWindowTargetsLocked</code>，同样会发现也是基于对mWindowHandles的遍历找到目标窗口的。<br>那么谁会调用<code>setInputWindows</code>函数呢？具体可以看这篇文章<a href="http://gityuan.com/2016/12/24/input-ui/" title="Input系统—UI线程" target="_blank" rel="noopener">Input系统—UI线程</a>，其实就是在窗口进行创建和删除时进行更新。<br><img src="/archives/feabfdd/window添加流程图.png" alt="window添加流程图"></p><h2 id="如何将触摸式事件分发到Window"><a href="#如何将触摸式事件分发到Window" class="headerlink" title="如何将触摸式事件分发到Window"></a>如何将触摸式事件分发到Window</h2><p>在知道怎么找到目标Window后，最关键的问题就是如何将事件分发到该Window了。那么，到底是不是通过Binder呢？再次回到InputDispatcher中进行事件分发的地方，即<code>InputDispatcher::dispatchOnce</code>，一步步随着代码读下去，就会发现最终是通过Socket发送出去的：<br><img src="/archives/feabfdd/事件发送流程.png" alt="事件发送流程"><br>当然，关于Socket的创建我们可以在窗口建立时找到，即<code>WindowManagerService</code>中，更详细见参考资料：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建WindowState【见小节2.5.1】</span></span><br><span class="line">    WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span> &amp;&amp; (attrs.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//根据WindowState的HashCode以及title来生成InputChannel名称</span></span><br><span class="line">        String name = win.makeInputChannelName();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一对InputChannel[见小节2.6]</span></span><br><span class="line">        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">        <span class="comment">//将socket服务端保存到WindowState的mInputChannel</span></span><br><span class="line">        win.setInputChannel(inputChannels[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//socket客户端传递给outInputChannel [见小节2.7]</span></span><br><span class="line">        inputChannels[<span class="number">1</span>].transferTo(outInputChannel);</span><br><span class="line">        <span class="comment">//利用socket服务端作为参数[见小节2.8]</span></span><br><span class="line">        mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> focusChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (win.canReceiveKeys()) &#123;</span><br><span class="line">        <span class="comment">//新添加window能接收按下操作，则更新聚焦窗口。</span></span><br><span class="line">        focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">        mInputMonitor.setInputFocusLw(mCurrentFocus, <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置当前聚焦窗口【见小节2.5.2】</span></span><br><span class="line">    mInputMonitor.updateInputWindowsLw(<span class="keyword">false</span> <span class="comment">/*force*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从这两篇博客中，我们就弄清楚了整个触摸事件传递的过程，回到最开始的问题：</p><ol><li>将触摸事件发送给Window时，是如何在茫茫人海中确定眼神的？<strong>在Window创建时，会将相应的窗口信息同步更新到InputDispatcher中；然后在分发事件事件时，根据触摸事件的位置及窗口的属性来找到目标窗口。</strong></li><li>他们相隔千山万水，又是如何将触摸事件交付给对方的？<strong>通过Socket的通信方式，在窗口添加时进行创建Socket</strong></li></ol><p>借用<a href="http://gityuan.com/" title="gityuan" target="_blank" rel="noopener">gityuan</a>中图为：</p><p><img src="/archives/feabfdd/事件框架图.jpg" alt="事件框架图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://gityuan.com/2016/12/31/input-ipc/" title="Input系统—事件处理全过程" target="_blank" rel="noopener">Input系统—事件处理全过程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上篇文章&lt;a href=&quot;http://yunlinos.com/archives/9f4ea589.html&quot; title=&quot;Andro
      
    
    </summary>
    
      <category term="Android系统源码" scheme="http://yunlinos.com/categories/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="触摸事件" scheme="http://yunlinos.com/tags/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android触摸事件原理</title>
    <link href="http://yunlinos.com/archives/9f4ea589.html"/>
    <id>http://yunlinos.com/archives/9f4ea589.html</id>
    <published>2018-08-04T02:40:02.000Z</published>
    <updated>2018-08-05T02:22:29.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上篇文章<a href="http://yunlinos.com/archives/ff7c0d4a.html" title="Android Monkey源码解析">Android Monkey源码解析</a>中，我们学习了Monkey的基本用法，也知道了完整的执行流程。在大多数情况下，我们只需要一行代码即可完成最终的系统事件注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!InputManager.getInstance().injectInputEvent(keyEvent,</span><br><span class="line">        InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br></pre></td></tr></table></figure></p><p>当然，如果你阅读源码较为细心，也会发现<code>MonkeyFlipEvent</code>是用了另外一种方式进行事件注入，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">injectEvent</span><span class="params">(IWindowManager iwm, IActivityManager iam, <span class="keyword">int</span> verbose)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verbose &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">":Sending Flip keyboardOpen="</span> + mKeyboardOpen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject flip event</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"/dev/input/event0"</span>);</span><br><span class="line">        f.write(mKeyboardOpen ? FLIP_0 : FLIP_1);</span><br><span class="line">        f.close();</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Got IOException performing flip"</span> + e);</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，这两种方式又是如何将事件注入到系统中呢？再延伸下，Android系统中，触摸事件的来源是什么？又是如何传递到View上？在View中又是如何进行事件分发呢？</p><p>在下面的内容里，我们将从源码中一一找到答案。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>相关源码位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/</span><br><span class="line">- SystemServer.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/java/com/android/server/input/</span><br><span class="line">- InputManagerService.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/jni/</span><br><span class="line">- com_android_server_input_InputManagerService.cpp</span><br><span class="line"></span><br><span class="line">frameworks/<span class="keyword">native</span>/services/inputflinger/</span><br><span class="line">- EventHub.cpp</span><br><span class="line">- InputManager.cpp</span><br><span class="line">- InputReader.cpp</span><br><span class="line">- InputDispatcher.cpp</span><br></pre></td></tr></table></figure></p><p>先初步看下Android系统的触摸事件流程图，然后再分解整个流程进行剖析<br><img src="/archives/9f4ea589/触摸流程图.png" alt="触摸流程图"></p><p>将会从以下几个阶段来分析触摸事件的来源与去处：</p><ol><li>捕获触摸事件：对应流程图2-3</li><li>派发触摸事件：对应流程图4</li><li>触摸事件分发：对应流程图5-6</li></ol><h2 id="捕获触摸事件"><a href="#捕获触摸事件" class="headerlink" title="捕获触摸事件"></a>捕获触摸事件</h2><p>说到触摸事件，不得不提到InputManagerService，这是一个系统服务，主要用于处理各种输入事件，包括鼠标、键盘等。该服务在SystemServer进程启动的时候实例化，并注册到ServiceManager中去。<br>[-&gt; SystemServer.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">···</span><br><span class="line">wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">        mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">        !mFirstBoot, mOnlyCore, <span class="keyword">new</span> PhoneWindowManager());</span><br><span class="line">ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>在SystemServer的<code>startOtherServices</code>方法，会发现InputManagerService和WindowManagerService分别进行实例化，且WindowManagerService持有InputManagerService的引用，并注册到ServiceManager中。<br>我们回到InputManagerService中，在该服务的初始化过程中，会发现两个Native方法。<br>[-&gt; InputManagerService.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">(InputManagerService service,</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, MessageQueue messageQueue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure></p><p>根据这两个方法，我们找到对应的JNI方法，即：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == NULL) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    status_t result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过调用流程，会发现跟<code>NativeInputManager</code>相关，此时，我们来看看该类在初始化的过程中做了哪些事情：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="keyword">true</span>) &#123;</span><br><span class="line">···</span><br><span class="line">    sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line">    mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先实例化了EventHub和InputManager，且InputManager会持有EventHub的引用。那么，这两个都是些什么东西呢？首先我们进入EventHub去看看<br>[-&gt; EventHub.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 创建epoll对象，mEpollFd为epoll对象的描述符</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建inotify对象，mINotifyFd为inotify对象的描述符</span></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="comment">// DEVICE_PATH值为"/dev/input"，监听该目录下的设备节点创建与删除操作。通过read函数读取事件</span></span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"Could not register INotify for %s.  errno=%d"</span>,</span><br><span class="line">            DEVICE_PATH, errno);</span><br><span class="line"></span><br><span class="line">    struct epoll_event eventItem;</span><br><span class="line">    memset(&amp;eventItem, <span class="number">0</span>, sizeof(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;    <span class="comment">//监听可读事件</span></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    <span class="comment">// EPOLL_CTL_ADD表示增加事件</span></span><br><span class="line">    <span class="comment">// epoll_ctl将事件监听添加到epoll对象中去</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add INotify to epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major, minor;</span><br><span class="line">    getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line">    <span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">    mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来对于设备事件的监听，即监听<code>/dev/input/event*</code>的节点，主要依靠EventHub，利用Linux的inotify和epoll机制来获取Input事件。关于该部分的详解，可细读该部分的代码，这里不多赘述（关于EventHub和getEvent就不继续往下看了，知道这个深度对于非Framework工程师已经足够）。<br>了解到EventHub的主要功能，我们可以猜测出，InputManager持有其引用，应该是不断的读取设备的事件，并对上层进行分发消费。带着这份猜测，我们继续来看InputManager的代码。<br>[-&gt; InputManager.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">    <span class="comment">// 事件分发执行类</span></span><br><span class="line">    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">    <span class="comment">// 事件获取执行类</span></span><br><span class="line">    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) :</span><br><span class="line">        mReader(reader),</span><br><span class="line">        mDispatcher(dispatcher) &#123;</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputManager::~InputManager() &#123;</span><br><span class="line">    stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">    <span class="comment">// 事件获取线程</span></span><br><span class="line">    mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">    <span class="comment">// 事件分发线程</span></span><br><span class="line">    mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">        int32_t oldGeneration;</span><br><span class="line">        int32_t timeoutMillis;</span><br><span class="line">        bool inputDevicesChanged = <span class="keyword">false</span>;</span><br><span class="line">        Vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">// 监听事件</span></span><br><span class="line">        size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">       <span class="comment">// 处理事件</span></span><br><span class="line">         processEventsLocked(mEventBuffer, count);</span><br><span class="line">       ···</span><br><span class="line">       <span class="comment">// 派发事件</span></span><br><span class="line">        mQueuedListener-&gt;flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>确实印证了我们之前的猜测，这里用到了生产消费者模型，即一条线程不断读取设备事件，另外一条线程不断分发该事件。且事件读取线程用到了epoll机制，避免的性能的损耗。InputReader不断的通过EventHub获取到Input事件，经过<code>processEventsLocked</code>进行简单的封装，再通过<code>mQueuedListener-&gt;flush()</code>进行事件的派发。<br>到这里，捕获触摸事件的流程我们弄清楚里，总结如下：<br><img src="/archives/9f4ea589/捕获触摸事件.png" alt="捕获触摸事件"></p><h2 id="派发触摸事件"><a href="#派发触摸事件" class="headerlink" title="派发触摸事件"></a>派发触摸事件</h2><p>以上，我们知道了触摸事件的来源；现在，我们来关注触摸事件的去处。<br>[-&gt; InputManager.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有挂起的命令，运行分派循环。</span></span><br><span class="line">        <span class="comment">// 分派循环可能会将命令编入队列，以便随后运行。</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行所有存在的挂起的命令。</span></span><br><span class="line">        <span class="comment">// 如果有任何命令运行，则强制下一个轮询立即唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里主要是消息处理模型，如果有input事件的话则被唤醒处理事件，如果没有的话继续睡眠等待。我们主要关注<code>dispatchOnceInnerLocked(&amp;nextWakeupTime)</code>方法，该方法内会对事件类型进行判断并执行不同的处理方法，包括<code>EventEntry::TYPE_KEY</code>、<code>EventEntry::TYPE_MOTION</code>等等，我们只关注触摸事件的处理方式，即。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">        ···</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        ···</span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchMotionLocked(</span><br><span class="line">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ···    </span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">bool</span> conflictingPointerActions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">    <span class="comment">// 找到目标Window</span></span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//  派发</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由以上代码可以看出，对于触摸事件会首先通过<code>findTouchedWindowTargetsLocked</code>找到目标Window，进而通过dispatchEventLocked将消息发送到目标窗口。关于如何找到对应的Window，如何将派发给对应的Window，过程较为复杂，而我们此次仅关注整体流程，故在下篇博客中阐述。</p><h2 id="触摸事件分发"><a href="#触摸事件分发" class="headerlink" title="触摸事件分发"></a>触摸事件分发</h2><p>当触摸事件到达View中时，就涉及到应用端的事件分发机制了。该部分没必要另起介绍了，推荐两个比较优秀的文章：</p><ul><li><a href="http://www.monkeyliu.com/blog/2016/06/17/touchevent/" title="Android触摸事件分发机制" target="_blank" rel="noopener">Android触摸事件分发机制</a></li><li><a href="https://blog.csdn.net/guolin_blog/article/details/9097463" title="Android事件分发机制完全解析" target="_blank" rel="noopener">Android事件分发机制完全解析</a></li></ul><h2 id="解疑"><a href="#解疑" class="headerlink" title="解疑"></a>解疑</h2><p>让我们再次回到文章开始的疑问：</p><ol><li>触摸事件的来源是什么？<strong>InputReader通过EventHub获取到Input事件，并通过InputDispatcher 发出事件通知。</strong></li><li>又是如何传递到View上？<strong>在InputDispatcher找到对应的Window，并将事件发送到Window中。</strong></li><li>在View中又是如何进行事件分发呢？<strong>详见上面推荐的两篇博客。</strong></li></ol><p>最后一个问题，<code>InputManager.getInstance().injectInputEvent</code>又是如何进行事件注入的了。让我们从源码中来找到答案：<br>[-&gt; InputManagerService.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span> <span class="comment">// Binder call</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">injectInputEvent</span><span class="params">(InputEvent event, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> injectInputEventInternal(event, Display.DEFAULT_DISPLAY, mode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">injectInputEventInternal</span><span class="params">(InputEvent event, <span class="keyword">int</span> displayId, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"event must not be null"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mode != InputManager.INJECT_INPUT_EVENT_MODE_ASYNC</span><br><span class="line">              &amp;&amp; mode != InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH</span><br><span class="line">              &amp;&amp; mode != InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mode is invalid"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> pid = Binder.getCallingPid();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> uid = Binder.getCallingUid();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          result = nativeInjectInputEvent(mPtr, event, displayId, pid, uid, mode,</span><br><span class="line">                  INJECTION_TIMEOUT_MILLIS, WindowManagerPolicy.FLAG_DISABLE_KEY_REPEAT);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          Binder.restoreCallingIdentity(ident);</span><br><span class="line">      &#125;</span><br><span class="line">···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>应用通过Binder调用到InputManagerService中的方法，并且调用到Native方法<code>nativeInjectInputEvent</code>，让我们再次跟随源码的脚本进入<code>com_android_server_input_InputManagerService.cpp</code>到中：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeInjectInputEvent</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jobject inputEventObj, jint displayId, jint injectorPid, jint injectorUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint syncMode, jint timeoutMillis, jint policyFlags)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsInstanceOf(inputEventObj, gKeyEventClassInfo.clazz)) &#123;</span><br><span class="line">        KeyEvent keyEvent;</span><br><span class="line">        <span class="keyword">status_t</span> status = android_view_KeyEvent_toNative(env, inputEventObj, &amp; keyEvent);</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            jniThrowRuntimeException(env, <span class="string">"Could not read contents of KeyEvent object."</span>);</span><br><span class="line">            <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (jint) im-&gt;getInputManager()-&gt;getDispatcher()-&gt;injectInputEvent(</span><br><span class="line">                &amp; keyEvent, displayId, injectorPid, injectorUid, syncMode, timeoutMillis,</span><br><span class="line">                <span class="keyword">uint32_t</span>(policyFlags));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env-&gt;IsInstanceOf(inputEventObj, gMotionEventClassInfo.clazz)) &#123;</span><br><span class="line">        <span class="keyword">const</span> MotionEvent* motionEvent = android_view_MotionEvent_getNativePtr(env, inputEventObj);</span><br><span class="line">        <span class="keyword">if</span> (!motionEvent) &#123;</span><br><span class="line">            jniThrowRuntimeException(env, <span class="string">"Could not read contents of MotionEvent object."</span>);</span><br><span class="line">            <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (jint) im-&gt;getInputManager()-&gt;getDispatcher()-&gt;injectInputEvent(</span><br><span class="line">                motionEvent, displayId, injectorPid, injectorUid, syncMode, timeoutMillis,</span><br><span class="line">                <span class="keyword">uint32_t</span>(policyFlags));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Invalid input event type."</span>);</span><br><span class="line">        <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里，惊不惊喜，意不意外，其实并没有什么精妙或者牛逼的处理方式，就是直接获取到InputDispatcher对事件进行分发。殊途同归，最终还是回到了最开始的地方。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我们来总结下整个触摸事件的流程：</p><ol><li>InputManagerService在SystemServer中初始化，并向ServiceManager进行注册</li><li>初始化过程中生成InputManager和EventHub实例，InputManager持有EventHub的引用</li><li>InputManager实例化InputReader和InputDispatcher</li><li>InputReader通过EventHub监听Input事件</li><li>InputDispatcher进行事件的派发，即先找到对应的Window，并将Input事件传到该Window</li><li>Input事件传到应用，进入到View的事件分发，通过<code>dispatchTouchEven</code>、<code>onInterceptTouchEvent</code>等方法进行选择性分发</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://source.android.com/devices/input/touch-devices" title="Android触摸设备" target="_blank" rel="noopener">Android触摸设备</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上篇文章&lt;a href=&quot;http://yunlinos.com/archives/ff7c0d4a.html&quot; title=&quot;Andro
      
    
    </summary>
    
      <category term="Android系统源码" scheme="http://yunlinos.com/categories/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="触摸事件" scheme="http://yunlinos.com/tags/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android Monkey源码解析</title>
    <link href="http://yunlinos.com/archives/ff7c0d4a.html"/>
    <id>http://yunlinos.com/archives/ff7c0d4a.html</id>
    <published>2018-08-03T06:57:41.000Z</published>
    <updated>2018-08-04T01:59:29.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间在梳理公司的自动化测试脚本时，发现Monkey是个挺有意思的工具，它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试，这个倒很像一个梗<code>π里面藏着一部莎士比亚</code>。比较好奇它的实现原理，于是就有了研究源码的想法，说干就干，Read the Fucking Source Code。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>先将源码从系统中导出，我手头的AOSP是Android 5.1</p><ul><li>Monkey程序由Android系统自带，使用Java语言开发。在Android文件系统中的存放位置为：<code>/system/framework/monkey.jar</code>。在源码中的位置为<code>/development/cmds/monkey</code></li><li>Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本位于Android文件系统中：<code>/system/bin/monkey</code>。在源码中的位置为<code>development/cmds/monkey/monkey</code></li></ul><p>下面，就将开始Monkey的源码阅读之旅。</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>Monkey是由system/bin/monkey脚本启动system/framework/monkey.jar。下面是monkey脚本的内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Script to start "monkey" on the device, which has a very rudimentary</span><br><span class="line"><span class="meta">#</span> shell.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">base=/system</span><br><span class="line"><span class="meta">#</span> 设置monkey的CLASSPATH环境变量指向monkey.jar</span><br><span class="line">export CLASSPATH=$base/framework/monkey.jar</span><br><span class="line">trap "" HUP</span><br><span class="line"><span class="meta">#</span> 通过app_process指定monkey的入口和传进来的所有参数启动上面CLASSPATH设定的monkey.jar</span><br><span class="line">exec app_process $base/bin com.android.commands.monkey.Monkey $*</span><br></pre></td></tr></table></figure></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>可以通过adb命令执行Monkey脚本<code>adb shell monkey -p com.android.settings 500</code>，其基本流程如下：</p><ul><li>解析命令行参数</li><li>根据命令行参数选择不同的事件输入源，也就是事件源是从网络过来还是通过内部随机产生</li><li>跳入runMonkeyCycle方法针对不同事件源获取并开始执行不同的事件</li></ul><ol><li><p>入口在main方法，代码位于com.android.commands.monkey.Monkey.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Command-line entry point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args The command-line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Set the process name showing in "ps" or "top"</span></span><br><span class="line">        Process.setArgV0(<span class="string">"com.android.commands.monkey"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> resultCode = (<span class="keyword">new</span> Monkey()).run(args);</span><br><span class="line">        System.exit(resultCode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>解析输入参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the command!</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args The command-line arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Returns a posix-style result code. 0 for no error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">···</span><br><span class="line">        <span class="keyword">if</span> (!processOptions()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>根据输入的参数选择不同的事件输入流</p></li></ol><ul><li>MonkeySourceScript：通过相应的规则编写monkey脚本来驱动monkey进行事件注入，为非随机事件</li><li>MonkeySourceRandomScript：随机内部事件源，由脚本来触发，为随机事件</li><li>MonkeySourceNetwork：由网络（比如MonkeyRunner）发送过来的事件</li><li>MonkeySourceRandom：由monkey内部产生的随机事件集<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mScriptFileNames != <span class="keyword">null</span> &amp;&amp; mScriptFileNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// script mode, ignore other options</span></span><br><span class="line">    mEventSource = <span class="keyword">new</span> MonkeySourceScript(mRandom, mScriptFileNames.get(<span class="number">0</span>), mThrottle,</span><br><span class="line">            mRandomizeThrottle, mProfileWaitTime, mDeviceSleepTime);</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line"></span><br><span class="line">    mCountEvents = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mScriptFileNames != <span class="keyword">null</span> &amp;&amp; mScriptFileNames.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mSetupFileName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceRandomScript(mSetupFileName,</span><br><span class="line">                mScriptFileNames, mThrottle, mRandomizeThrottle, mRandom,</span><br><span class="line">                mProfileWaitTime, mDeviceSleepTime, mRandomizeScript);</span><br><span class="line">        mCount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceRandomScript(mScriptFileNames,</span><br><span class="line">                mThrottle, mRandomizeThrottle, mRandom,</span><br><span class="line">                mProfileWaitTime, mDeviceSleepTime, mRandomizeScript);</span><br><span class="line">    &#125;</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line">    mCountEvents = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mServerPort != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceNetwork(mServerPort);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Error binding to network socket."</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mCount = Integer.MAX_VALUE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// random source by default</span></span><br><span class="line">    <span class="keyword">if</span> (mVerbose &gt;= <span class="number">2</span>) &#123; <span class="comment">// check seeding performance</span></span><br><span class="line">        System.out.println(<span class="string">"// Seeded: "</span> + mSeed);</span><br><span class="line">    &#125;</span><br><span class="line">    mEventSource = <span class="keyword">new</span> MonkeySourceRandom(mRandom, mMainApps, mThrottle, mRandomizeThrottle);</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line">    <span class="comment">// set any of the factors that has been set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MonkeySourceRandom.FACTORZ_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactors[i] &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">            ((MonkeySourceRandom) mEventSource).setFactors(i, mFactors[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in random mode, we start with a random activity</span></span><br><span class="line">    ((MonkeySourceRandom) mEventSource).generateActivity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>循环执行事件<br>run方法根据参数从不同的事件源获得事件并放入到EventQueue后，就会开始执行一个循环去从EventQueue里获取事件进行执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">···</span><br><span class="line">        mNetworkMonitor.start();</span><br><span class="line">        <span class="keyword">int</span> crashedAtCycle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crashedAtCycle = runMonkeyCycles();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the rotation lock if it's still held and restore the</span></span><br><span class="line">            <span class="comment">// original orientation.</span></span><br><span class="line">            <span class="keyword">new</span> MonkeyRotationEvent(Surface.ROTATION_0, <span class="keyword">false</span>).injectEvent(</span><br><span class="line">                    mWm, mAm, mVerbose);</span><br><span class="line">        &#125;</span><br><span class="line">        mNetworkMonitor.stop();</span><br><span class="line">···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>runMonkeyCyles方法会根据不同的数据源开始一条条的获取事件并进行执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">MonkeyEvent ev = mEventSource.getNextEvent();</span><br><span class="line"><span class="keyword">if</span> (ev != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> injectCode = ev.injectEvent(mWm, mAm, mVerbose);</span><br><span class="line">    <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_FAIL) &#123;</span><br><span class="line">        System.out.println(<span class="string">"    // Injection Failed"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyKeyEvent) &#123;</span><br><span class="line">            mDroppedKeyEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyMotionEvent) &#123;</span><br><span class="line">            mDroppedPointerEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyFlipEvent) &#123;</span><br><span class="line">            mDroppedFlipEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyRotationEvent) &#123;</span><br><span class="line">            mDroppedRotationEvents++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_ERROR_REMOTE_EXCEPTION) &#123;</span><br><span class="line">        systemCrashed = <span class="keyword">true</span>;</span><br><span class="line">        System.err.println(<span class="string">"** Error: RemoteException while injecting event."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_ERROR_SECURITY_EXCEPTION) &#123;</span><br><span class="line">        systemCrashed = !mIgnoreSecurityExceptions;</span><br><span class="line">        <span class="keyword">if</span> (systemCrashed) &#123;</span><br><span class="line">            System.err.println(<span class="string">"** Error: SecurityException while injecting event."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't count throttling as an event.</span></span><br><span class="line">    <span class="keyword">if</span> (!(ev <span class="keyword">instanceof</span> MonkeyThrottleEvent)) &#123;</span><br><span class="line">        eventCounter++;</span><br><span class="line">        <span class="keyword">if</span> (mCountEvents) &#123;</span><br><span class="line">            cycleCounter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mCountEvents) &#123;</span><br><span class="line">        cycleCounter++;</span><br><span class="line">        writeScriptLog(cycleCounter);</span><br><span class="line">        <span class="comment">//Capture the bugreport after n iteration</span></span><br><span class="line">        <span class="keyword">if</span> (mGetPeriodicBugreport) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cycleCounter % mBugreportFrequency) == <span class="number">0</span>) &#123;</span><br><span class="line">                mRequestPeriodicBugreport = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Event Source has signaled that we have no more events to process</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行事件主要为与MonkeyEvent的injectEvent方法，例如MonkeykeyEvent事件的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">injectEvent</span><span class="params">(IWindowManager iwm, IActivityManager iam, <span class="keyword">int</span> verbose)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verbose &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        String note;</span><br><span class="line">        <span class="keyword">if</span> (mAction == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">            note = <span class="string">"ACTION_UP"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            note = <span class="string">"ACTION_DOWN"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">":Sending Key ("</span> + note + <span class="string">"): "</span></span><br><span class="line">                    + mKeyCode + <span class="string">"    // "</span></span><br><span class="line">                    + MonkeySourceRandom.getKeyName(mKeyCode));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">":Sending Key ("</span> + note + <span class="string">"): "</span></span><br><span class="line">                    + mKeyCode + <span class="string">"    // Unknown key event"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyEvent keyEvent = mKeyEvent;</span><br><span class="line">    <span class="keyword">if</span> (keyEvent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> eventTime = mEventTime;</span><br><span class="line">        <span class="keyword">if</span> (eventTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            eventTime = SystemClock.uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> downTime = mDownTime;</span><br><span class="line">        <span class="keyword">if</span> (downTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            downTime = eventTime;</span><br><span class="line">        &#125;</span><br><span class="line">        keyEvent = <span class="keyword">new</span> KeyEvent(downTime, eventTime, mAction, mKeyCode,</span><br><span class="line">                mRepeatCount, mMetaState, mDeviceId, mScanCode,</span><br><span class="line">                KeyEvent.FLAG_FROM_SYSTEM, InputDevice.SOURCE_KEYBOARD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!InputManager.getInstance().injectInputEvent(keyEvent,</span><br><span class="line">            InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上，基本就完成了整个事件注入的流程</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Monkey的软件架构图：<br><img src="/archives/ff7c0d4a/Monkey结构图.png" alt="你想输入的替代文字"></p><p>Monkey的工作原理图：<br><img src="/archives/ff7c0d4a/自动化测试架构图.png" alt="Monkey的工作原理图"></p><p>再次总结下其工作流程如下：</p><ol><li>由<code>system/bin/monkey</code>启动Monkey进程</li><li>解析命令行参数</li><li>根据输入的参数选择不同的事件输入流：是从网络过来还是通过内部随机产生</li><li>跳入runMonkeyCycle方法针对不同事件源获取事件</li><li>向系统注入事件</li></ol><p>另外，关于如何向Android中进行事件注入，将在下篇博客中展现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间在梳理公司的自动化测试脚本时，发现Monkey是个挺有意思的工具，它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等
      
    
    </summary>
    
      <category term="Android系统源码" scheme="http://yunlinos.com/categories/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="自动化测试" scheme="http://yunlinos.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Monkey" scheme="http://yunlinos.com/tags/Monkey/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yunlinos.com/archives/4a17b156.html"/>
    <id>http://yunlinos.com/archives/4a17b156.html</id>
    <published>2018-08-01T12:23:53.033Z</published>
    <updated>2018-08-04T01:09:04.963Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到YunLin的博客，本博客基于<a href="https://github.com/" title="Github" target="_blank" rel="noopener">Github</a>和<a href="https://hexo.io/zh-cn/" title="Hexo" target="_blank" rel="noopener">Hexo</a>搭建，使用<a href="https://github.com/iissnan/hexo-theme-next" title="NexT.Mist" target="_blank" rel="noopener">NexT.Mist</a>主题。在阿里云购买的域名，分别为<a href="http://yunlinos.com/" title="www.yunlinos.com">www.yunlinos.com</a>和<a href="http://yunlinos.cn/" title="www.yunlinos.cn" target="_blank" rel="noopener">www.yunlinos.cn</a>。</p><p>在这里，坚决减少记录性内容，避免环境的简单搭建；多些源码的解读、架构的思考、底层的原理，确保内容高质量。</p><p>现阶段内容包括不限于：</p><ul><li>开源项目的源码解读，偏向于设计思想和优秀的代码实现</li><li>Android源码的实现，偏向于功能的原理性解读</li><li>深耕计算机网络、Java虚拟机方面</li></ul><p>当然，最重要的还是坚持，让更多的人得到帮助，也让自己的成长滴水成河。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到YunLin的博客，本博客基于&lt;a href=&quot;https://github.com/&quot; title=&quot;Github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;和&lt;a href=&quot;https://hexo.io/zh-cn/
      
    
    </summary>
    
      <category term="个人思考总结" scheme="http://yunlinos.com/categories/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yunlinos.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
