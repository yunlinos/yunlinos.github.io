<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YunLinOS Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yunlinos.com/"/>
  <updated>2018-08-05T02:22:29.251Z</updated>
  <id>http://yunlinos.com/</id>
  
  <author>
    <name>YunLinOS</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android触摸事件原理</title>
    <link href="http://yunlinos.com/archives/9f4ea589.html"/>
    <id>http://yunlinos.com/archives/9f4ea589.html</id>
    <published>2018-08-04T02:40:02.000Z</published>
    <updated>2018-08-05T02:22:29.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上篇文章<a href="http://yunlinos.com/archives/ff7c0d4a.html" title="Android Monkey源码解析">Android Monkey源码解析</a>中，我们学习了Monkey的基本用法，也知道了完整的执行流程。在大多数情况下，我们只需要一行代码即可完成最终的系统事件注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!InputManager.getInstance().injectInputEvent(keyEvent,</span><br><span class="line">        InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br></pre></td></tr></table></figure></p><p>当然，如果你阅读源码较为细心，也会发现<code>MonkeyFlipEvent</code>是用了另外一种方式进行事件注入，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">injectEvent</span><span class="params">(IWindowManager iwm, IActivityManager iam, <span class="keyword">int</span> verbose)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verbose &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">":Sending Flip keyboardOpen="</span> + mKeyboardOpen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject flip event</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"/dev/input/event0"</span>);</span><br><span class="line">        f.write(mKeyboardOpen ? FLIP_0 : FLIP_1);</span><br><span class="line">        f.close();</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Got IOException performing flip"</span> + e);</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，这两种方式又是如何将事件注入到系统中呢？再延伸下，Android系统中，触摸事件的来源是什么？又是如何传递到View上？在View中又是如何进行事件分发呢？</p><p>在下面的内容里，我们将从源码中一一找到答案。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>相关源码位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/</span><br><span class="line">- SystemServer.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/java/com/android/server/input/</span><br><span class="line">- InputManagerService.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/jni/</span><br><span class="line">- com_android_server_input_InputManagerService.cpp</span><br><span class="line"></span><br><span class="line">frameworks/<span class="keyword">native</span>/services/inputflinger/</span><br><span class="line">- EventHub.cpp</span><br><span class="line">- InputManager.cpp</span><br><span class="line">- InputReader.cpp</span><br><span class="line">- InputDispatcher.cpp</span><br></pre></td></tr></table></figure></p><p>先初步看下Android系统的触摸事件流程图，然后再分解整个流程进行剖析<br><img src="/archives/9f4ea589/触摸流程图.png" alt="触摸流程图"></p><p>将会从以下几个阶段来分析触摸事件的来源与去处：</p><ol><li>捕获触摸事件：对应流程图2-3</li><li>派发触摸事件：对应流程图4</li><li>触摸事件分发：对应流程图5-6</li></ol><h2 id="捕获触摸事件"><a href="#捕获触摸事件" class="headerlink" title="捕获触摸事件"></a>捕获触摸事件</h2><p>说到触摸事件，不得不提到InputManagerService，这是一个系统服务，主要用于处理各种输入事件，包括鼠标、键盘等。该服务在SystemServer进程启动的时候实例化，并注册到ServiceManager中去。<br>[-&gt; SystemServer.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">···</span><br><span class="line">wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">        mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">        !mFirstBoot, mOnlyCore, <span class="keyword">new</span> PhoneWindowManager());</span><br><span class="line">ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>在SystemServer的<code>startOtherServices</code>方法，会发现InputManagerService和WindowManagerService分别进行实例化，且WindowManagerService持有InputManagerService的引用，并注册到ServiceManager中。<br>我们回到InputManagerService中，在该服务的初始化过程中，会发现两个Native方法。<br>[-&gt; InputManagerService.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">(InputManagerService service,</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, MessageQueue messageQueue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure></p><p>根据这两个方法，我们找到对应的JNI方法，即：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == NULL) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    status_t result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过调用流程，会发现跟<code>NativeInputManager</code>相关，此时，我们来看看该类在初始化的过程中做了哪些事情：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="keyword">true</span>) &#123;</span><br><span class="line">···</span><br><span class="line">    sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line">    mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先实例化了EventHub和InputManager，且InputManager会持有EventHub的引用。那么，这两个都是些什么东西呢？首先我们进入EventHub去看看<br>[-&gt; EventHub.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 创建epoll对象，mEpollFd为epoll对象的描述符</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建inotify对象，mINotifyFd为inotify对象的描述符</span></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="comment">// DEVICE_PATH值为"/dev/input"，监听该目录下的设备节点创建与删除操作。通过read函数读取事件</span></span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"Could not register INotify for %s.  errno=%d"</span>,</span><br><span class="line">            DEVICE_PATH, errno);</span><br><span class="line"></span><br><span class="line">    struct epoll_event eventItem;</span><br><span class="line">    memset(&amp;eventItem, <span class="number">0</span>, sizeof(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;    <span class="comment">//监听可读事件</span></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    <span class="comment">// EPOLL_CTL_ADD表示增加事件</span></span><br><span class="line">    <span class="comment">// epoll_ctl将事件监听添加到epoll对象中去</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add INotify to epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major, minor;</span><br><span class="line">    getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line">    <span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">    mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来对于设备事件的监听，即监听<code>/dev/input/event*</code>的节点，主要依靠EventHub，利用Linux的inotify和epoll机制来获取Input事件。关于该部分的详解，可细读该部分的代码，这里不多赘述（关于EventHub和getEvent就不继续往下看了，知道这个深度对于非Framework工程师已经足够）。<br>了解到EventHub的主要功能，我们可以猜测出，InputManager持有其引用，应该是不断的读取设备的事件，并对上层进行分发消费。带着这份猜测，我们继续来看InputManager的代码。<br>[-&gt; InputManager.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">    <span class="comment">// 事件分发执行类</span></span><br><span class="line">    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">    <span class="comment">// 事件获取执行类</span></span><br><span class="line">    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) :</span><br><span class="line">        mReader(reader),</span><br><span class="line">        mDispatcher(dispatcher) &#123;</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputManager::~InputManager() &#123;</span><br><span class="line">    stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">    <span class="comment">// 事件获取线程</span></span><br><span class="line">    mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">    <span class="comment">// 事件分发线程</span></span><br><span class="line">    mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">        int32_t oldGeneration;</span><br><span class="line">        int32_t timeoutMillis;</span><br><span class="line">        bool inputDevicesChanged = <span class="keyword">false</span>;</span><br><span class="line">        Vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">// 监听事件</span></span><br><span class="line">        size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">       <span class="comment">// 处理事件</span></span><br><span class="line">         processEventsLocked(mEventBuffer, count);</span><br><span class="line">       ···</span><br><span class="line">       <span class="comment">// 派发事件</span></span><br><span class="line">        mQueuedListener-&gt;flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>确实印证了我们之前的猜测，这里用到了生产消费者模型，即一条线程不断读取设备事件，另外一条线程不断分发该事件。且事件读取线程用到了epoll机制，避免的性能的损耗。InputReader不断的通过EventHub获取到Input事件，经过<code>processEventsLocked</code>进行简单的封装，再通过<code>mQueuedListener-&gt;flush()</code>进行事件的派发。<br>到这里，捕获触摸事件的流程我们弄清楚里，总结如下：<br><img src="/archives/9f4ea589/捕获触摸事件.png" alt="捕获触摸事件"></p><h2 id="派发触摸事件"><a href="#派发触摸事件" class="headerlink" title="派发触摸事件"></a>派发触摸事件</h2><p>以上，我们知道了触摸事件的来源；现在，我们来关注触摸事件的去处。<br>[-&gt; InputManager.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有挂起的命令，运行分派循环。</span></span><br><span class="line">        <span class="comment">// 分派循环可能会将命令编入队列，以便随后运行。</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行所有存在的挂起的命令。</span></span><br><span class="line">        <span class="comment">// 如果有任何命令运行，则强制下一个轮询立即唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里主要是消息处理模型，如果有input事件的话则被唤醒处理事件，如果没有的话继续睡眠等待。我们主要关注<code>dispatchOnceInnerLocked(&amp;nextWakeupTime)</code>方法，该方法内会对事件类型进行判断并执行不同的处理方法，包括<code>EventEntry::TYPE_KEY</code>、<code>EventEntry::TYPE_MOTION</code>等等，我们只关注触摸事件的处理方式，即。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">        ···</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        ···</span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchMotionLocked(</span><br><span class="line">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ···    </span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">bool</span> conflictingPointerActions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">    <span class="comment">// 找到目标Window</span></span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//  派发</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由以上代码可以看出，对于触摸事件会首先通过<code>findTouchedWindowTargetsLocked</code>找到目标Window，进而通过dispatchEventLocked将消息发送到目标窗口。关于如何找到对应的Window，如何将派发给对应的Window，过程较为复杂，而我们此次仅关注整体流程，故在下篇博客中阐述。</p><h2 id="触摸事件分发"><a href="#触摸事件分发" class="headerlink" title="触摸事件分发"></a>触摸事件分发</h2><p>当触摸事件到达View中时，就涉及到应用端的事件分发机制了。该部分没必要另起介绍了，推荐两个比较优秀的文章：</p><ul><li><a href="http://www.monkeyliu.com/blog/2016/06/17/touchevent/" title="Android触摸事件分发机制" target="_blank" rel="noopener">Android触摸事件分发机制</a></li><li><a href="https://blog.csdn.net/guolin_blog/article/details/9097463" title="Android事件分发机制完全解析" target="_blank" rel="noopener">Android事件分发机制完全解析</a></li></ul><h2 id="解疑"><a href="#解疑" class="headerlink" title="解疑"></a>解疑</h2><p>让我们再次回到文章开始的疑问：</p><ol><li>触摸事件的来源是什么？<strong>InputReader通过EventHub获取到Input事件，并通过InputDispatcher 发出事件通知。</strong></li><li>又是如何传递到View上？<strong>在InputDispatcher找到对应的Window，并将事件发送到Window中。</strong></li><li>在View中又是如何进行事件分发呢？<strong>详见上面推荐的两篇博客。</strong></li></ol><p>最后一个问题，<code>InputManager.getInstance().injectInputEvent</code>又是如何进行事件注入的了。让我们从源码中来找到答案：<br>[-&gt; InputManagerService.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span> <span class="comment">// Binder call</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">injectInputEvent</span><span class="params">(InputEvent event, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> injectInputEventInternal(event, Display.DEFAULT_DISPLAY, mode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">injectInputEventInternal</span><span class="params">(InputEvent event, <span class="keyword">int</span> displayId, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"event must not be null"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mode != InputManager.INJECT_INPUT_EVENT_MODE_ASYNC</span><br><span class="line">              &amp;&amp; mode != InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH</span><br><span class="line">              &amp;&amp; mode != InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mode is invalid"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> pid = Binder.getCallingPid();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> uid = Binder.getCallingUid();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          result = nativeInjectInputEvent(mPtr, event, displayId, pid, uid, mode,</span><br><span class="line">                  INJECTION_TIMEOUT_MILLIS, WindowManagerPolicy.FLAG_DISABLE_KEY_REPEAT);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          Binder.restoreCallingIdentity(ident);</span><br><span class="line">      &#125;</span><br><span class="line">···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>应用通过Binder调用到InputManagerService中的方法，并且调用到Native方法<code>nativeInjectInputEvent</code>，让我们再次跟随源码的脚本进入<code>com_android_server_input_InputManagerService.cpp</code>到中：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeInjectInputEvent</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jobject inputEventObj, jint displayId, jint injectorPid, jint injectorUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint syncMode, jint timeoutMillis, jint policyFlags)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsInstanceOf(inputEventObj, gKeyEventClassInfo.clazz)) &#123;</span><br><span class="line">        KeyEvent keyEvent;</span><br><span class="line">        <span class="keyword">status_t</span> status = android_view_KeyEvent_toNative(env, inputEventObj, &amp; keyEvent);</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            jniThrowRuntimeException(env, <span class="string">"Could not read contents of KeyEvent object."</span>);</span><br><span class="line">            <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (jint) im-&gt;getInputManager()-&gt;getDispatcher()-&gt;injectInputEvent(</span><br><span class="line">                &amp; keyEvent, displayId, injectorPid, injectorUid, syncMode, timeoutMillis,</span><br><span class="line">                <span class="keyword">uint32_t</span>(policyFlags));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env-&gt;IsInstanceOf(inputEventObj, gMotionEventClassInfo.clazz)) &#123;</span><br><span class="line">        <span class="keyword">const</span> MotionEvent* motionEvent = android_view_MotionEvent_getNativePtr(env, inputEventObj);</span><br><span class="line">        <span class="keyword">if</span> (!motionEvent) &#123;</span><br><span class="line">            jniThrowRuntimeException(env, <span class="string">"Could not read contents of MotionEvent object."</span>);</span><br><span class="line">            <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (jint) im-&gt;getInputManager()-&gt;getDispatcher()-&gt;injectInputEvent(</span><br><span class="line">                motionEvent, displayId, injectorPid, injectorUid, syncMode, timeoutMillis,</span><br><span class="line">                <span class="keyword">uint32_t</span>(policyFlags));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Invalid input event type."</span>);</span><br><span class="line">        <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里，惊不惊喜，意不意外，其实并没有什么精妙或者牛逼的处理方式，就是直接获取到InputDispatcher对事件进行分发。殊途同归，最终还是回到了最开始的地方。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我们来总结下整个触摸事件的流程：</p><ol><li>InputManagerService在SystemServer中初始化，并向ServiceManager进行注册</li><li>初始化过程中生成InputManager和EventHub实例，InputManager持有EventHub的引用</li><li>InputManager实例化InputReader和InputDispatcher</li><li>InputReader通过EventHub监听Input事件</li><li>InputDispatcher进行事件的派发，即先找到对应的Window，并将Input事件传到该Window</li><li>Input事件传到应用，进入到View的事件分发，通过<code>dispatchTouchEven</code>、<code>onInterceptTouchEvent</code>等方法进行选择性分发</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://source.android.com/devices/input/touch-devices" title="Android触摸设备" target="_blank" rel="noopener">Android触摸设备</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上篇文章&lt;a href=&quot;http://yunlinos.com/archives/ff7c0d4a.html&quot; title=&quot;Andro
      
    
    </summary>
    
      <category term="Android系统源码" scheme="http://yunlinos.com/categories/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="触摸事件" scheme="http://yunlinos.com/tags/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android Monkey源码解析</title>
    <link href="http://yunlinos.com/archives/ff7c0d4a.html"/>
    <id>http://yunlinos.com/archives/ff7c0d4a.html</id>
    <published>2018-08-03T06:57:41.000Z</published>
    <updated>2018-08-04T01:59:29.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间在梳理公司的自动化测试脚本时，发现Monkey是个挺有意思的工具，它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试，这个倒很像一个梗<code>π里面藏着一部莎士比亚</code>。比较好奇它的实现原理，于是就有了研究源码的想法，说干就干，Read the Fucking Source Code。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>先将源码从系统中导出，我手头的AOSP是Android 5.1</p><ul><li>Monkey程序由Android系统自带，使用Java语言开发。在Android文件系统中的存放位置为：<code>/system/framework/monkey.jar</code>。在源码中的位置为<code>/development/cmds/monkey</code></li><li>Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本位于Android文件系统中：<code>/system/bin/monkey</code>。在源码中的位置为<code>development/cmds/monkey/monkey</code></li></ul><p>下面，就将开始Monkey的源码阅读之旅。</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>Monkey是由system/bin/monkey脚本启动system/framework/monkey.jar。下面是monkey脚本的内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Script to start "monkey" on the device, which has a very rudimentary</span><br><span class="line"><span class="meta">#</span> shell.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">base=/system</span><br><span class="line"><span class="meta">#</span> 设置monkey的CLASSPATH环境变量指向monkey.jar</span><br><span class="line">export CLASSPATH=$base/framework/monkey.jar</span><br><span class="line">trap "" HUP</span><br><span class="line"><span class="meta">#</span> 通过app_process指定monkey的入口和传进来的所有参数启动上面CLASSPATH设定的monkey.jar</span><br><span class="line">exec app_process $base/bin com.android.commands.monkey.Monkey $*</span><br></pre></td></tr></table></figure></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>可以通过adb命令执行Monkey脚本<code>adb shell monkey -p com.android.settings 500</code>，其基本流程如下：</p><ul><li>解析命令行参数</li><li>根据命令行参数选择不同的事件输入源，也就是事件源是从网络过来还是通过内部随机产生</li><li>跳入runMonkeyCycle方法针对不同事件源获取并开始执行不同的事件</li></ul><ol><li><p>入口在main方法，代码位于com.android.commands.monkey.Monkey.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Command-line entry point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args The command-line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Set the process name showing in "ps" or "top"</span></span><br><span class="line">        Process.setArgV0(<span class="string">"com.android.commands.monkey"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> resultCode = (<span class="keyword">new</span> Monkey()).run(args);</span><br><span class="line">        System.exit(resultCode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>解析输入参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the command!</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args The command-line arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Returns a posix-style result code. 0 for no error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">···</span><br><span class="line">        <span class="keyword">if</span> (!processOptions()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>根据输入的参数选择不同的事件输入流</p></li></ol><ul><li>MonkeySourceScript：通过相应的规则编写monkey脚本来驱动monkey进行事件注入，为非随机事件</li><li>MonkeySourceRandomScript：随机内部事件源，由脚本来触发，为随机事件</li><li>MonkeySourceNetwork：由网络（比如MonkeyRunner）发送过来的事件</li><li>MonkeySourceRandom：由monkey内部产生的随机事件集<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mScriptFileNames != <span class="keyword">null</span> &amp;&amp; mScriptFileNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// script mode, ignore other options</span></span><br><span class="line">    mEventSource = <span class="keyword">new</span> MonkeySourceScript(mRandom, mScriptFileNames.get(<span class="number">0</span>), mThrottle,</span><br><span class="line">            mRandomizeThrottle, mProfileWaitTime, mDeviceSleepTime);</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line"></span><br><span class="line">    mCountEvents = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mScriptFileNames != <span class="keyword">null</span> &amp;&amp; mScriptFileNames.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mSetupFileName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceRandomScript(mSetupFileName,</span><br><span class="line">                mScriptFileNames, mThrottle, mRandomizeThrottle, mRandom,</span><br><span class="line">                mProfileWaitTime, mDeviceSleepTime, mRandomizeScript);</span><br><span class="line">        mCount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceRandomScript(mScriptFileNames,</span><br><span class="line">                mThrottle, mRandomizeThrottle, mRandom,</span><br><span class="line">                mProfileWaitTime, mDeviceSleepTime, mRandomizeScript);</span><br><span class="line">    &#125;</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line">    mCountEvents = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mServerPort != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceNetwork(mServerPort);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Error binding to network socket."</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mCount = Integer.MAX_VALUE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// random source by default</span></span><br><span class="line">    <span class="keyword">if</span> (mVerbose &gt;= <span class="number">2</span>) &#123; <span class="comment">// check seeding performance</span></span><br><span class="line">        System.out.println(<span class="string">"// Seeded: "</span> + mSeed);</span><br><span class="line">    &#125;</span><br><span class="line">    mEventSource = <span class="keyword">new</span> MonkeySourceRandom(mRandom, mMainApps, mThrottle, mRandomizeThrottle);</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line">    <span class="comment">// set any of the factors that has been set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MonkeySourceRandom.FACTORZ_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactors[i] &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">            ((MonkeySourceRandom) mEventSource).setFactors(i, mFactors[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in random mode, we start with a random activity</span></span><br><span class="line">    ((MonkeySourceRandom) mEventSource).generateActivity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>循环执行事件<br>run方法根据参数从不同的事件源获得事件并放入到EventQueue后，就会开始执行一个循环去从EventQueue里获取事件进行执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">···</span><br><span class="line">        mNetworkMonitor.start();</span><br><span class="line">        <span class="keyword">int</span> crashedAtCycle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crashedAtCycle = runMonkeyCycles();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the rotation lock if it's still held and restore the</span></span><br><span class="line">            <span class="comment">// original orientation.</span></span><br><span class="line">            <span class="keyword">new</span> MonkeyRotationEvent(Surface.ROTATION_0, <span class="keyword">false</span>).injectEvent(</span><br><span class="line">                    mWm, mAm, mVerbose);</span><br><span class="line">        &#125;</span><br><span class="line">        mNetworkMonitor.stop();</span><br><span class="line">···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>runMonkeyCyles方法会根据不同的数据源开始一条条的获取事件并进行执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">MonkeyEvent ev = mEventSource.getNextEvent();</span><br><span class="line"><span class="keyword">if</span> (ev != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> injectCode = ev.injectEvent(mWm, mAm, mVerbose);</span><br><span class="line">    <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_FAIL) &#123;</span><br><span class="line">        System.out.println(<span class="string">"    // Injection Failed"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyKeyEvent) &#123;</span><br><span class="line">            mDroppedKeyEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyMotionEvent) &#123;</span><br><span class="line">            mDroppedPointerEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyFlipEvent) &#123;</span><br><span class="line">            mDroppedFlipEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyRotationEvent) &#123;</span><br><span class="line">            mDroppedRotationEvents++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_ERROR_REMOTE_EXCEPTION) &#123;</span><br><span class="line">        systemCrashed = <span class="keyword">true</span>;</span><br><span class="line">        System.err.println(<span class="string">"** Error: RemoteException while injecting event."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_ERROR_SECURITY_EXCEPTION) &#123;</span><br><span class="line">        systemCrashed = !mIgnoreSecurityExceptions;</span><br><span class="line">        <span class="keyword">if</span> (systemCrashed) &#123;</span><br><span class="line">            System.err.println(<span class="string">"** Error: SecurityException while injecting event."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't count throttling as an event.</span></span><br><span class="line">    <span class="keyword">if</span> (!(ev <span class="keyword">instanceof</span> MonkeyThrottleEvent)) &#123;</span><br><span class="line">        eventCounter++;</span><br><span class="line">        <span class="keyword">if</span> (mCountEvents) &#123;</span><br><span class="line">            cycleCounter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mCountEvents) &#123;</span><br><span class="line">        cycleCounter++;</span><br><span class="line">        writeScriptLog(cycleCounter);</span><br><span class="line">        <span class="comment">//Capture the bugreport after n iteration</span></span><br><span class="line">        <span class="keyword">if</span> (mGetPeriodicBugreport) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cycleCounter % mBugreportFrequency) == <span class="number">0</span>) &#123;</span><br><span class="line">                mRequestPeriodicBugreport = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Event Source has signaled that we have no more events to process</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行事件主要为与MonkeyEvent的injectEvent方法，例如MonkeykeyEvent事件的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">injectEvent</span><span class="params">(IWindowManager iwm, IActivityManager iam, <span class="keyword">int</span> verbose)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verbose &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        String note;</span><br><span class="line">        <span class="keyword">if</span> (mAction == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">            note = <span class="string">"ACTION_UP"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            note = <span class="string">"ACTION_DOWN"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">":Sending Key ("</span> + note + <span class="string">"): "</span></span><br><span class="line">                    + mKeyCode + <span class="string">"    // "</span></span><br><span class="line">                    + MonkeySourceRandom.getKeyName(mKeyCode));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">":Sending Key ("</span> + note + <span class="string">"): "</span></span><br><span class="line">                    + mKeyCode + <span class="string">"    // Unknown key event"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyEvent keyEvent = mKeyEvent;</span><br><span class="line">    <span class="keyword">if</span> (keyEvent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> eventTime = mEventTime;</span><br><span class="line">        <span class="keyword">if</span> (eventTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            eventTime = SystemClock.uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> downTime = mDownTime;</span><br><span class="line">        <span class="keyword">if</span> (downTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            downTime = eventTime;</span><br><span class="line">        &#125;</span><br><span class="line">        keyEvent = <span class="keyword">new</span> KeyEvent(downTime, eventTime, mAction, mKeyCode,</span><br><span class="line">                mRepeatCount, mMetaState, mDeviceId, mScanCode,</span><br><span class="line">                KeyEvent.FLAG_FROM_SYSTEM, InputDevice.SOURCE_KEYBOARD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!InputManager.getInstance().injectInputEvent(keyEvent,</span><br><span class="line">            InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上，基本就完成了整个事件注入的流程</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Monkey的软件架构图：<br><img src="/archives/ff7c0d4a/Monkey结构图.png" alt="你想输入的替代文字"></p><p>Monkey的工作原理图：<br><img src="/archives/ff7c0d4a/自动化测试架构图.png" alt="Monkey的工作原理图"></p><p>再次总结下其工作流程如下：</p><ol><li>由<code>system/bin/monkey</code>启动Monkey进程</li><li>解析命令行参数</li><li>根据输入的参数选择不同的事件输入流：是从网络过来还是通过内部随机产生</li><li>跳入runMonkeyCycle方法针对不同事件源获取事件</li><li>向系统注入事件</li></ol><p>另外，关于如何向Android中进行事件注入，将在下篇博客中展现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间在梳理公司的自动化测试脚本时，发现Monkey是个挺有意思的工具，它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等
      
    
    </summary>
    
      <category term="Android系统源码" scheme="http://yunlinos.com/categories/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="Monkey" scheme="http://yunlinos.com/tags/Monkey/"/>
    
      <category term="自动化测试" scheme="http://yunlinos.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yunlinos.com/archives/4a17b156.html"/>
    <id>http://yunlinos.com/archives/4a17b156.html</id>
    <published>2018-08-01T12:23:53.033Z</published>
    <updated>2018-08-04T01:09:04.963Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到YunLin的博客，本博客基于<a href="https://github.com/" title="Github" target="_blank" rel="noopener">Github</a>和<a href="https://hexo.io/zh-cn/" title="Hexo" target="_blank" rel="noopener">Hexo</a>搭建，使用<a href="https://github.com/iissnan/hexo-theme-next" title="NexT.Mist" target="_blank" rel="noopener">NexT.Mist</a>主题。在阿里云购买的域名，分别为<a href="http://yunlinos.com/" title="www.yunlinos.com">www.yunlinos.com</a>和<a href="http://yunlinos.cn/" title="www.yunlinos.cn" target="_blank" rel="noopener">www.yunlinos.cn</a>。</p><p>在这里，坚决减少记录性内容，避免环境的简单搭建；多些源码的解读、架构的思考、底层的原理，确保内容高质量。</p><p>现阶段内容包括不限于：</p><ul><li>开源项目的源码解读，偏向于设计思想和优秀的代码实现</li><li>Android源码的实现，偏向于功能的原理性解读</li><li>深耕计算机网络、Java虚拟机方面</li></ul><p>当然，最重要的还是坚持，让更多的人得到帮助，也让自己的成长滴水成河。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到YunLin的博客，本博客基于&lt;a href=&quot;https://github.com/&quot; title=&quot;Github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;和&lt;a href=&quot;https://hexo.io/zh-cn/
      
    
    </summary>
    
      <category term="个人思考总结" scheme="http://yunlinos.com/categories/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yunlinos.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
