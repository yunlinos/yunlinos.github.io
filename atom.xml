<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YunLinOS Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yunlinos.com/"/>
  <updated>2018-09-25T08:47:50.575Z</updated>
  <id>http://yunlinos.com/</id>
  
  <author>
    <name>YunLinOS</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Activity Hook之启动流程</title>
    <link href="http://yunlinos.com/archives/12d6dd90.html"/>
    <id>http://yunlinos.com/archives/12d6dd90.html</id>
    <published>2018-09-25T08:41:53.000Z</published>
    <updated>2018-09-25T08:47:50.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是Activity Hook系列文章的上篇。在对Activity启动过程进行实际Hook前，我们应该对启动流程了如指掌，这样才能找到最佳的Hook点。而在这篇文章中，我们将会跟随源码的步伐，一步步看清楚Activity的启动流程。</p><p>但是，整个Activity的启动流程异常复杂，包括对Launch mode的判断、对Flag的处理、对生命周期的管理，如果我们过于深究细节，将会在代码中迷失自己。故在此篇文章中，我们需要把握整体，仅仅立足于整个流程的主要路径，只对几个关键点进行重点介绍，力求语言简洁，突出重点。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>基于Android 7.1的源码分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/core/java/com/android/server/am/</span><br><span class="line">  - ActivityManagerService.java</span><br><span class="line">  - ActivityStackSupervisor.java</span><br><span class="line">  - ActivityStack.java</span><br><span class="line">  - ActivityRecord.java</span><br><span class="line">  - ProcessRecord.java</span><br><span class="line"></span><br><span class="line">frameworks/base/core/java/android/app/</span><br><span class="line">  - IActivityManager.java</span><br><span class="line">  - ActivityManagerNative.java (内含AMP)</span><br><span class="line">  - ActivityManager.java</span><br><span class="line">  </span><br><span class="line">  - IApplicationThread.java</span><br><span class="line">  - ApplicationThreadNative.java (内含ATP)</span><br><span class="line">  - ActivityThread.java (内含ApplicationThread)</span><br><span class="line">  </span><br><span class="line">  - ContextImpl.java</span><br></pre></td></tr></table></figure><p>主要服务的简单介绍：</p><ol><li>zygote进程：Android系统开启新进程的方式，是通过fork zygote进程实现的，其他应用所在的进程都是zygote的子进程。</li><li>SystemServer进程：也是zygote进程fork出来的子进程。系统里面所有重要的服务都是在该进程里面开启的，比如ActivityManagerService、PackageManagerService、WindowManagerService等等。</li><li>ActivityManagerService：负责系统中所有Activity的生命周期，其他应用通过binder和该服务通信。</li></ol><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>在源码阅读前，强烈建议先了解binder机制。作为Android系统提供的一种IPC机制，无论从系统开发还是应用开发，都是Android系统中最重要的组成，也是最难理解的一块知识点，源码中大多数地方都是通过binder机制进行通信。详情可见：<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列</a></p><ol><li><p>Activity.startActivity<br>[Activity.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void startActivity(Intent intent) &#123;</span><br><span class="line">    this.startActivity(intent, null);</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">@Override</span><br><span class="line">public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">    if (options != null) &#123;</span><br><span class="line">        startActivityForResult(intent, -1, options);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Note we want to go through this call for compatibility with</span><br><span class="line">        // applications that may have overridden the method.</span><br><span class="line">        startActivityForResult(intent, -1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,</span><br><span class="line">        @Nullable Bundle options) &#123;</span><br><span class="line">    if (mParent == null) &#123;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        // 通过Instrumentation进行Activity的实际启动</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        if (ar != null) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Instrumentation.execStartActivity<br>[Instrumentation.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">    ···</span><br><span class="line">    try &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        int result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                    requestCode, 0, null, options);</span><br><span class="line">        // 检查Activity是否启动成功</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ActivityManager.getService<br>[ActivityManager.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">public static IActivityManager getService() &#123;</span><br><span class="line">    return IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected IActivityManager create() &#123;</span><br><span class="line">                // 拿到ActivityManagerService的代理对象，即可通过binder机制远程调用方法</span><br><span class="line">                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                final IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                return am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></li><li><p>ActivityManagerService.startActivity<br>[ActivityManagerService.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;</span><br><span class="line">    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">@Override</span><br><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123;</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class="line">            userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);</span><br><span class="line">    // TODO: Switch to user app stacks here.</span><br><span class="line">    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,</span><br><span class="line">            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, null, null, bOptions, false, userId, null, null,</span><br><span class="line">            &quot;startActivityAsUser&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，逻辑就已经进入到AMS中了。这里面的逻辑异常复杂，将会处理各种场景，包括launch mode、flag、生命周期等等，在这里就不进行详解了，如果大家对这块感兴趣的话可自行阅读源码。原因有两个：</p><ul><li>我们更多的是关注整个流程和路径，而不深究细节</li><li>我们在Hook Activity启动流程时，是没法对AMS这部分进行hook的，故这部分代码暂不细读</li></ul><p>我们直接来到Activity启动的最后一站，在<code>ActivityStackSupervisor</code>中。</p></li><li><p>ActivityStackSupervisor.realStartActivityLocked<br>[ActivityStackSupervisor.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">        boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">    ···</span><br><span class="line">        // 拿到Applicationthread的代理对象，即可通过binder机制远程调用方法</span><br><span class="line">        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                System.identityHashCode(r), r.info,</span><br><span class="line">                // TODO: Have this take the merged configuration instead of separate global and</span><br><span class="line">                // override configs.</span><br><span class="line">                mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ApplicationThread.scheduleLaunchActivity<br>[ActivityThread.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private class ApplicationThread extends IApplicationThread.Stub &#123;</span><br><span class="line">    private static final String DB_INFO_FORMAT = &quot;  %8s %8s %14s %14s  %s&quot;;</span><br><span class="line">     </span><br><span class="line">    private int mLastProcessState = -1;</span><br><span class="line">    </span><br><span class="line">    ···</span><br><span class="line">    @Override</span><br><span class="line">    public final void scheduleRelaunchActivity(IBinder token,</span><br><span class="line">            List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">            int configChanges, boolean notResumed, Configuration config,</span><br><span class="line">            Configuration overrideConfig, boolean preserveWindow) &#123;</span><br><span class="line">        // binder远程调用方法。在ActivityStackSupervisor中调用，实际执行是在ApplicationThread中</span><br><span class="line">        requestRelaunchActivity(token, pendingResults, pendingNewIntents,</span><br><span class="line">                configChanges, notResumed, config, overrideConfig, true, preserveWindow);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">public final void requestRelaunchActivity(IBinder token,</span><br><span class="line">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">        int configChanges, boolean notResumed, Configuration config,</span><br><span class="line">        Configuration overrideConfig, boolean fromServer, boolean preserveWindow) &#123;</span><br><span class="line">    ActivityClientRecord target = null;</span><br><span class="line">     </span><br><span class="line">    synchronized (mResourcesManager) &#123;</span><br><span class="line">        ···</span><br><span class="line">        if (target == null) &#123;</span><br><span class="line">            if (DEBUG_ORDER) Slog.d(TAG, &quot;requestRelaunchActivity: target is null, fromServer:&quot;</span><br><span class="line">                    + fromServer);</span><br><span class="line">            target = new ActivityClientRecord();</span><br><span class="line">            target.token = token;</span><br><span class="line">            target.pendingResults = pendingResults;</span><br><span class="line">            target.pendingIntents = pendingNewIntents;</span><br><span class="line">            target.mPreserveWindow = preserveWindow;</span><br><span class="line">            if (!fromServer) &#123;</span><br><span class="line">                final ActivityClientRecord existing = mActivities.get(token);</span><br><span class="line">                if (DEBUG_ORDER) Slog.d(TAG, &quot;requestRelaunchActivity: &quot; + existing);</span><br><span class="line">                if (existing != null) &#123;</span><br><span class="line">                    if (DEBUG_ORDER) Slog.d(TAG, &quot;requestRelaunchActivity: paused= &quot;</span><br><span class="line">                            + existing.paused);;</span><br><span class="line">                    target.startsNotResumed = existing.paused;</span><br><span class="line">                    target.overrideConfig = existing.overrideConfig;</span><br><span class="line">                &#125;</span><br><span class="line">                target.onlyLocalRequest = true;</span><br><span class="line">            &#125;</span><br><span class="line">            mRelaunchingActivities.add(target);</span><br><span class="line">            // 通过sendMessage来执行方法</span><br><span class="line">            sendMessage(H.RELAUNCH_ACTIVITY, target);</span><br><span class="line">        &#125;</span><br><span class="line">    ···</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_ORDER) Slog.d(TAG, &quot;relaunchActivity &quot; + ActivityThread.this + &quot;, target &quot;</span><br><span class="line">            + target + &quot; operation received seq: &quot; + target.relaunchSeq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>H.handleMessage<br>[ActivityThread.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">            //【见流程8】</span><br><span class="line">            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ActivityThread.handleLaunchActivity<br>[ActivityThread.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">    // If we are getting ready to gc after going to the background, well</span><br><span class="line">    // we are back active so skip it.</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = true;</span><br><span class="line">     </span><br><span class="line">    if (r.profilerInfo != null) &#123;</span><br><span class="line">        mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // Make sure we are running with the most recent config.</span><br><span class="line">    handleConfigurationChanged(null, null);</span><br><span class="line">     </span><br><span class="line">    if (localLOGV) Slog.v(</span><br><span class="line">        TAG, &quot;Handling launch of &quot; + r);</span><br><span class="line">     </span><br><span class="line">    // Initialize before creating the activity</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">     </span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">     </span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">        r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">     </span><br><span class="line">        if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">            // The activity manager actually wants this one to start out paused, because it</span><br><span class="line">            // needs to be visible but isn&apos;t in the foreground. We accomplish this by going</span><br><span class="line">            // through the normal startup (because activities expect to go through onResume()</span><br><span class="line">            // the first time they run, before their window is displayed), and then pausing it.</span><br><span class="line">            // However, in this case we do -not- need to do the full pause cycle (of freezing</span><br><span class="line">            // and such) because the activity manager assumes it can just retain the current</span><br><span class="line">            // state it has.</span><br><span class="line">            performPauseActivityIfNeeded(r, reason);</span><br><span class="line">     </span><br><span class="line">            // We need to keep around the original state, in case we need to be created again.</span><br><span class="line">            // But we only do this for pre-Honeycomb apps, which always save their state when</span><br><span class="line">            // pausing, so we can not have them save their state when restarting from a paused</span><br><span class="line">            // state. For HC and later, we want to (and can) let the state be saved as the</span><br><span class="line">            // normal part of stopping the activity.</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                r.state = oldState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果出现任何错误，通过binder通知ActivityManagerService停止启动</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                        Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来，就是Activity正常的onCreate、onStart、onResume生命周期。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过源码阅读，我们大概知道了应用的整个启动流程，即：</p><ol><li>A进程通过binder机制向system_server进程发起startActivity请求</li><li>system_server进程收到请求后，通过socket机制向zygote进程发起创建进程的请求</li><li>zygote进程fork出新的子线程，即B进程</li><li>B进程通过binder机制向sytem_server进程发起attachApplication请求</li><li>system_server进程在收到请求后，进行相应处理，再通过binder机制向B进程发送scheduleLaunchActivity请求</li><li>B进程收到请求后，通过handler向主线程发送<code>LAUNCH_ACTIVITY</code>消息</li><li>主线程收到消息后，创建相关的Activity并执行其生命周期</li></ol><p>借用Gityuan中的流程图为：<br><img src="/archives/12d6dd90/Activity启动流程图.jpg" alt="Activity启动流程图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是Activity Hook系列文章的上篇。在对Activity启动过程进行实际Hook前，我们应该对启动流程了如指掌，这样才能找到最佳
      
    
    </summary>
    
      <category term="Android插件化和热修复" scheme="http://yunlinos.com/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="Activity" scheme="http://yunlinos.com/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Java 动态代理机制</title>
    <link href="http://yunlinos.com/archives/875ee7f0.html"/>
    <id>http://yunlinos.com/archives/875ee7f0.html</id>
    <published>2018-09-21T11:40:56.000Z</published>
    <updated>2018-09-21T11:44:45.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式，也就是Proxy，在软件项目中无处不在。如果一个类的类名带有Proxy，基本上就是代理类，也就是用了代理模式。比如Android源码中的ActivityManagerProxy。</p><p>代理模式的官方定义为：为其他对象提供一种代理以控制对这个对象的访问。</p><p>通过阅读本文，我们将会对 Java 动态代理机制有更加深入的理解。本文首先会介绍静态代理，然后从动态代理的运行机制和特点出发，对其代码进行了分析，最后通过开源项目的代码来呈现动态代理的实际使用场景。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>实现静态代理的基本要点为：</p><ul><li>定义公用接口</li><li>代理类和委托类实现该接口</li><li>由代理类的构造函数参数传入真正的委托类</li></ul><p>我们来看下具体实现：</p><ol><li><p>接口提供请求方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>委托类的实现（真实实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RealSubject request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理类的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProxySubject request"</span>);</span><br><span class="line">        realSubject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类及其结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> ProxySubject();</span><br><span class="line">        subject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">ProxySubject request</span><br><span class="line">RealSubject request</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ol><p>在该例子中，我们使用静态代理模式，实际上是将整个处理流程复杂化，本应直接实例化运行即可。但是，在实际项目中，使用代理模式可以减轻项目的耦合性并能提高后期的可维护性：比如我们项目中进行图片缓存，如果后期需要更换图片加载库，只需要修改代理类即可；比如我们需要对相关的事件进行拦截、转发、预处理等；再比如在Android源码中的AIDL调用，也都是通过代理类实现。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在静态代理，我们需要为每个实际执行类都生成相应的代理类，在后期项目中会生成大量的代理类。而动态代理则是通过调用处理器（invocation handler）的invoke方法负责处理所有委托类的方法调用。上面的例子的动态代理实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    processJDKProxy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processJDKProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">    Subject proxyInstance = (Subject) Proxy.newProxyInstance(</span><br><span class="line">            ProxyDemo.class.getClassLoader(),</span><br><span class="line">            subject.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"processJDKProxy start"</span>);</span><br><span class="line">                    method.invoke(subject, args);</span><br><span class="line">                    System.out.println(<span class="string">"processJDKProxy end"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    proxyInstance.request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">processJDKProxy start</span><br><span class="line">RealSubject request</span><br><span class="line">processJDKProxy end</span><br></pre></td></tr></table></figure><p>从上面的例子中，我们知道了动态代理的简单运用。现在，来通过源码来了解其实现机制，首先来看下相关的类和接口：</p><ul><li><p>java.lang.reflect.Proxy：是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。</p><p>Proxy的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">getProxyClass</span><span class="params">(ClassLoader loader, Class[] interfaces)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 3：该方法用于判断指定类对象是否是一个动态代理类</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class cl)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class[] interfaces, </span></span></span><br><span class="line"><span class="function"><span class="params">    InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure></li><li><p>java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p><p>InvocationHandler 的核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象</span></span><br><span class="line"><span class="comment">// 第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure><p>每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象（参见 Proxy 静态方法 4 的第三个参数）</p></li><li><p>java.lang.ClassLoader：这是类装载器类，负责将类的字节码装载到 Java 虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。</p><p>每次生成动态代理类对象时都需要指定一个类装载器对象（参见 Proxy 静态方法 4 的第一个参数）</p></li></ul><p>在动态代理的具体实现中，被代理的类必须实现接口，未实现接口则没办法完成动态代理。不过该问题可以通过cglib来解决，详情可见：<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">https://github.com/cglib/cglib</a></p><h2 id="动态代理的实际应用"><a href="#动态代理的实际应用" class="headerlink" title="动态代理的实际应用"></a>动态代理的实际应用</h2><p>下面将会以Retrofit来了解动态代理机制的实际应用。</p><p>Retrofit 的使用方式比较特殊，是通过定义一个接口类，通过给接口中方法和方法参数添加注解的方式来定义网络请求接口。即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure><p>因为接口是不可以直接new出来的，那么GitHubService是如何产生的呢？其实其内部实现就是动态代理实现的，我们来看下具体源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// Single-interface proxy creation guarded by parameter safety.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> loadServiceMethod(method).invoke(args);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这坨代码，我们应该就比较熟悉了，实际上就是通过动态代理实现。然后我们深入到<code>loadServiceMethod</code>方法中，来看内部是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先通过缓存来获取ServiceMethod，如果缓存中没有，就执行具体方法<code>parseAnnotations</code>来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">  &#125;</span><br><span class="line">···</span><br><span class="line">    <span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">        parseMethodAnnotation(annotation);</span><br><span class="line">      &#125;</span><br><span class="line">···</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"DELETE"</span>, ((DELETE) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"GET"</span>, ((GET) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"HEAD"</span>, ((HEAD) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"PATCH"</span>, ((PATCH) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"POST"</span>, ((POST) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"PUT"</span>, ((PUT) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> OPTIONS) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">"OPTIONS"</span>, ((OPTIONS) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">        HTTP http = (HTTP) annotation;</span><br><span class="line">        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> retrofit2.http.Headers) &#123;</span><br><span class="line">        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">        <span class="keyword">if</span> (headersToParse.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(method, <span class="string">"@Headers annotation is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        headers = parseHeaders(headersToParse);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        isMultipart = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        isFormEncoded = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">····</span><br></pre></td></tr></table></figure><p>如果对该部分代码感兴趣可以详读源码。简单来说，原理就是先通过动态代理，再拿到方法上的注解，获得具体的值，然后拿到除了回调之外的其他参数，获得参数上的注解，然后根据注解取得对应的值，还有原来的参数值，将方法上的注解的值中进行替换。使用OkHttp构造请求，请求完成后根据将结果解析为回调中的类型。整个过程如下：</p><ol><li>拦截到方法、参数</li><li>注解识别</li><li>拼接为Okhttp请求</li><li>执行请求</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Retrofit中，使用动态代理、注解、反射等方式，简化了调用者关注的内容和具体实现。让HTTP请求成为一种更优雅的方式。而在我们项目的具体实现中，也同样可以参考该设计方式，让自己的代码更加简洁和易读。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java 动态代理机制分析及扩展，第 1部分</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代理模式，也就是Proxy，在软件项目中无处不在。如果一个类的类名带有Proxy，基本上就是代理类，也就是用了代理模式。比如Android源
      
    
    </summary>
    
      <category term="Android插件化和热修复" scheme="http://yunlinos.com/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="静态代理" scheme="http://yunlinos.com/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="动态代理" scheme="http://yunlinos.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="retrofit" scheme="http://yunlinos.com/tags/retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射机制</title>
    <link href="http://yunlinos.com/archives/92291dc1.html"/>
    <id>http://yunlinos.com/archives/92291dc1.html</id>
    <published>2018-09-17T00:29:25.000Z</published>
    <updated>2018-09-17T00:32:32.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>反射作为Java程序开发中的一把黄油刀，在很多功能场景下都占据着重要的位置，比如热加载、动态配置化等等。很多Android的开源项目也有用到反射机制，来减轻开发者的工作量，比如说EventBus。</p><p>在这篇文章中，我们将会从反射的定义、原理、用途、运用、实例五个方面来进行具体分析。</p><h2 id="反射的定义"><a href="#反射的定义" class="headerlink" title="反射的定义"></a>反射的定义</h2><p>Oracle官方对反射的解释是：</p><blockquote><p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p></blockquote><p>简而言之，是指通过反射机制，在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。</p><p>这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。而且，不仅仅是获取该类的属性和方法，而且我们可以动态的修改该类的成员变量，来替换成我们需要的值。</p><p>其常用的功能是：</p><ul><li>得到类的对象；</li><li>获取以及设置该类的字段、方法和属性（共有或私有）；</li></ul><h2 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h2><p>我们可以看下这张经典的Java内存模型：</p><p><img src="/archives/92291dc1/Java内存模型.jpg" alt="Java 内存模型"></p><p>在程序中，每个java文件最终都会被编译成一个.class文件，这些Class对象承载了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些.class文件在程序运行时会被ClassLoader加载到虚拟机中。</p><p>当一个类被加载以后，Java虚拟机就会在内存中自动产生一个Class对象，而我们一般情况下用new来创建对象，有了class对象的引用，就相当于有了Method、Field、Constructor的相关信息，这样就能创建对象、获取对象信息等操作。</p><h2 id="反射的用途"><a href="#反射的用途" class="headerlink" title="反射的用途"></a>反射的用途</h2><p>反射在实际项目开发中用得较为广泛，比如调用类的私有方法、修改对象的成员变量等。</p><p>而在开源项目EventBus中，最终的事件分发即是用了反射机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合注解的使用，鸡肉味嘎嘣脆。</p><h2 id="反射的运用"><a href="#反射的运用" class="headerlink" title="反射的运用"></a>反射的运用</h2><h3 id="得到类的对象"><a href="#得到类的对象" class="headerlink" title="得到类的对象"></a>得到类的对象</h3><ol><li><p>getClass</p><p>通过对象，来获取该类。类型用Class表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String reflectContent = <span class="string">"Hello world!"</span>;</span><br><span class="line">Class cl = reflectContent.getClass();</span><br><span class="line">System.out.println(cl);</span><br></pre></td></tr></table></figure></li><li><p>Class.fromName</p><p>通过字符串，来获取类型。类型用Class表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class clFromName = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">    System.out.println(clFromName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="获取以及设置该类的字段、方法和属性"><a href="#获取以及设置该类的字段、方法和属性" class="headerlink" title="获取以及设置该类的字段、方法和属性"></a>获取以及设置该类的字段、方法和属性</h3><p>首先我们定义测试类，后面所有的实例将会以该测试类展开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"yunlinos"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectModel</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>调用构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectModel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clFromName = Class.forName(<span class="string">"com.yunlinos.reflectutils.ReflectModel"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数构造函数</span></span><br><span class="line">    Constructor constructor0 = clFromName.getDeclaredConstructor();</span><br><span class="line">    ReflectModel reflectModel0 = (ReflectModel) constructor0.newInstance();</span><br><span class="line">    reflectModel0.printName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参数构造函数</span></span><br><span class="line">    Class[] parameters = &#123;String.class, <span class="keyword">int</span>.class&#125;;</span><br><span class="line">    Constructor constructor1 = clFromName.getDeclaredConstructor(parameters);</span><br><span class="line">    ReflectModel reflectModel1 = (ReflectModel) constructor1.newInstance(<span class="string">"else"</span>, <span class="number">10</span>);</span><br><span class="line">    reflectModel1.printName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数构造函数</span></span><br><span class="line">    ReflectModel reflectModel2 = (ReflectModel) clFromName.newInstance();</span><br><span class="line">    reflectModel2.printName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用类的私有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clFromName = Class.forName(<span class="string">"com.yunlinos.reflectutils.ReflectModel"</span>);</span><br><span class="line">    Object object = clFromName.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数私有方法</span></span><br><span class="line">    Method method0 = clFromName.getDeclaredMethod(<span class="string">"printOtherName"</span>);</span><br><span class="line">    method0.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    method0.invoke(object);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参数私有方法</span></span><br><span class="line">    Method method1 = clFromName.getDeclaredMethod(<span class="string">"printOtherName"</span>, String.class);</span><br><span class="line">    method1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    method1.invoke(object, <span class="string">"yunlinos printOtherName"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用类的静态私有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectStaticMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clFromName = Class.forName(<span class="string">"com.yunlinos.reflectutils.ReflectModel"</span>);</span><br><span class="line">    </span><br><span class="line">    Method method = clFromName.getDeclaredMethod(<span class="string">"workStatic"</span>);</span><br><span class="line">    method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    method.invoke(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取并修改类的私有字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectField</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clFromName = Class.forName(<span class="string">"com.yunlinos.reflectutils.ReflectModel"</span>);</span><br><span class="line">    ReflectModel reflectModel = (ReflectModel) clFromName.newInstance();</span><br><span class="line"></span><br><span class="line">    Field field = clFromName.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object name = field.get(reflectModel);</span><br><span class="line">    System.out.println(name);</span><br><span class="line"></span><br><span class="line">    field.set(reflectModel, <span class="string">"yunlin reflect"</span>);</span><br><span class="line">    System.out.println(field.get(reflectModel));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取并修改类的静态私有字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectStaticField</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clFromName = Class.forName(<span class="string">"com.yunlinos.reflectutils.ReflectModel"</span>);</span><br><span class="line"></span><br><span class="line">    Field field = clFromName.getDeclaredField(<span class="string">"tag"</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object tag = field.get(<span class="keyword">null</span>);</span><br><span class="line">    System.out.println(tag);</span><br><span class="line"></span><br><span class="line">    field.set(<span class="keyword">null</span>, <span class="string">"yunlin tag"</span>);</span><br><span class="line">    System.out.println(field.get(<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="反射在Android中的实例"><a href="#反射在Android中的实例" class="headerlink" title="反射在Android中的实例"></a>反射在Android中的实例</h2><p>在Android中，如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；比如修改参数，替换返回值等，这个技术我们通常也称之为Hook。</p><p>现在我们就是要hook掉系统的onClickListener对象，替换成我们自定义的代理对象，然后在代理对象中打印一条日志。</p><p>首先我们来看下系统点击事件的监听过程，即<code>setOnClickListener</code>后所发生的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a callback to be invoked when this view is clicked. If this view is not</span></span><br><span class="line"><span class="comment"> * clickable, it becomes clickable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> l The callback that will run</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setClickable(boolean)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">        setClickable(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getListenerInfo().mOnClickListener = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设置时间监听器后，将其赋值给了<code>mOnClickListener</code>这个变量，我们再来看下<code>getListenerInfo()</code>拿到了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListenerInfo <span class="title">getListenerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mListenerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    mListenerInfo = <span class="keyword">new</span> ListenerInfo();</span><br><span class="line">    <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实最终拿到的就是View中的一个ListenerInfo对象。这时候，我们就可以梳理下反射修改的过程了：</p><ol><li>反射<code>getListenerInfo()</code>方法，拿到<code>mListenerInfo</code>对象</li><li>将<code>mListenerInfo</code>中的<code>mOnClickListener</code>修改我们自定义的Listener</li><li>在自定义Listener中接管相关的点击事件</li></ol><p>下面，show the code：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextView textView = findViewById(R.id.text_view);</span><br><span class="line">    textView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"onClick"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        hookClickListener(textView);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Hook fail!"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hookClickListener</span><span class="params">(View view)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 得到View的 ListenerInfo 对象</span></span><br><span class="line">        Method getListenerInfo = View.class.getDeclaredMethod(<span class="string">"getListenerInfo"</span>);</span><br><span class="line">        getListenerInfo.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object listenerInfo = getListenerInfo.invoke(view);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到原始的 OnClickListener 对象</span></span><br><span class="line">        Class&lt;?&gt; listenerInfoClz = Class.forName(<span class="string">"android.view.View$ListenerInfo"</span>);</span><br><span class="line">        Field onClickListener = listenerInfoClz.getDeclaredField(<span class="string">"mOnClickListener"</span>);</span><br><span class="line">        onClickListener.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        View.OnClickListener originOnClickListener = (View.OnClickListener) onClickListener.get(listenerInfo);</span><br><span class="line">        onClickListener.set(listenerInfo, <span class="keyword">new</span> HookOnClickListener(originOnClickListener));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HookOnClickListener</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> View.OnClickListener originOnClickListener;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HookOnClickListener</span><span class="params">(View.OnClickListener onClickListener)</span> </span>&#123;</span><br><span class="line">            originOnClickListener = onClickListener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Hook success!"</span>);</span><br><span class="line">            originOnClickListener.onClick(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>反射可以算是Java中的神兵利器。不过，由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。而且反射调用方法时可以忽略权限检查，可能会因此导致安全问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;反射作为Java程序开发中的一把黄油刀，在很多功能场景下都占据着重要的位置，比如热加载、动态配置化等等。很多Android的开源项目也有用到
      
    
    </summary>
    
      <category term="Android插件化和热修复" scheme="http://yunlinos.com/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="反射" scheme="http://yunlinos.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制：Android ClassLoader</title>
    <link href="http://yunlinos.com/archives/efd97a81.html"/>
    <id>http://yunlinos.com/archives/efd97a81.html</id>
    <published>2018-09-13T11:23:00.000Z</published>
    <updated>2018-09-13T11:32:02.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是类加载机制系列的第二篇，即Android类加载器。Android的Dalvik/ART虚拟机和Java的JVM虚拟机一样，也是需要加载class文件到内存中，但ClassLoader的加载细节会有一些区别。</p><p><img src="/archives/efd97a81/加载流程区别.png" alt="加载流程区别"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java虚拟机运行的是Java字节码，而Dalvik虚拟机运行的是专有文件格式dex。在Java程序中，Java类会被编译成一个或多个class文件，然后打包到jar文件中，接着Java虚拟机会从相应的class文件和jar文件中获取对应的字节码。Android应用虽然也使用Java语言，但是在编译成class文件后，还会通过DEX工具将所有的class文件转换成一个dex文件，Dalvik虚拟机再从中读取指令和数据。dex文件除了减少整体的文件尺寸和I/O操作次数，也提高了类的查找速度。</p><p>对于Android应用来讲，在程序首次加载时，为了提高启动速度和执行效率，系统还会将class.dex文件进一步优化，生成odex文件（Android 8.0引入vdex）。而且很多ROM厂商，同样会在编译时即对应用进行odex优化，可以极大加快首次升级的开机速度和应用启动速度。</p><p>➜  YouTube tree<br>.<br>├── YouTube.apk<br>└── oat<br>​    └── x86<br>​        ├── YouTube.odex<br>​        └── YouTube.vdex</p><p>关于odex和vdex，这里就不多介绍，可见：</p><p><a href="https://stackoverflow.com/questions/9593527/what-are-odex-files-in-android" target="_blank" rel="noopener">What are ODEX files in Android?</a></p><p><a href="https://www.zhihu.com/question/275955357/answer/383865933" target="_blank" rel="noopener">如何评价Android8.0引入的vdex？</a></p><p>当我们将APK文件解压（修改.apk为.zip并解压）后，可以看到文件目录如下所示：</p><p>➜  EN tree -L 1<br>.<br>├── AndroidManifest.xml<br>├── META-INF<br>├── classes.dex<br>├── lib<br>├── messages.properties<br>├── res<br>└── resources.arsc</p><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>在 Android 开发者官网上 <a href="https://developer.android.com/reference/java/lang/ClassLoader.html" target="_blank" rel="noopener">ClassLoader</a> 的文档说明中我们可以看到，ClassLoader 是个抽象类，其具体实现的子类有 <code>BaseDexClassLoader</code> 和 <code>SecureClassLoader</code> 。</p><p><img src="/archives/efd97a81/Android ClassLoader.png" alt="Android ClassLoader"></p><p>其类结构如下：</p><p><img src="/archives/efd97a81/Android ClassLoader类图.png" alt="Android ClassLoader类图"></p><p>我们较常用到的是<code>PathClassLoader</code> 和 <code>DexClassLoader</code>。</p><h3 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h3><p>在Android中，APP安装到手机后，apk里面class.dex中的class均是通过PathClassLoader来加载的。而且也是遵从前面提到的双亲委托机制，可见其构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, (File)<span class="keyword">null</span>, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过实例来打印出PathClassLoader和其父加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Log.v(<span class="string">"yunlinos"</span>, <span class="string">"printSomethingElse: "</span> + <span class="keyword">this</span>.getClassLoader());</span><br><span class="line">        Log.v(<span class="string">"yunlinos"</span>, <span class="string">"printSomethingElse: "</span> + <span class="keyword">this</span>.getClassLoader().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 运行结果</span><br><span class="line"><span class="number">09</span>-<span class="number">10</span> <span class="number">06</span>:<span class="number">13</span>:<span class="number">00.489</span> <span class="number">26923</span>-<span class="number">26923</span>/com.yunlinos.applicationhook V/yunlinos: printSomethingElse: dalvik.system.PathClassLoader[DexPathList[[zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/base.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_dependencies_apk.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_slice_0_apk.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_slice_1_apk.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_slice_2_apk.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_slice_3_apk.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_slice_4_apk.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_slice_5_apk.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_slice_6_apk.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_slice_7_apk.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_slice_8_apk.apk"</span>, zip file <span class="string">"/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/split_lib_slice_9_apk.apk"</span>],nativeLibraryDirectories=[/data/app/com.yunlinos.applicationhook-Kg7No_r8NVhjnP6laHWuVw==/lib/x86, /system/lib, /vendor/lib]]]</span><br><span class="line"><span class="number">09</span>-<span class="number">10</span> <span class="number">06</span>:<span class="number">13</span>:<span class="number">00.490</span> <span class="number">26923</span>-<span class="number">26923</span>/com.yunlinos.applicationhook V/yunlinos: printSomethingElse: java.lang.BootClassLoader<span class="meta">@cf</span>69ab1</span><br></pre></td></tr></table></figure><p>可以从运行结果看出，该Activity的类加载器为PathClassLoader，其父类加载器为BootClassLoader。即父类不一定为其父类加载器。</p><h2 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h2><p>该类加载是我们需要重点说明的，可以先看下官网的介绍：</p><blockquote><p>A class loader that loads classes from <code>.jar</code> and <code>.apk</code> files containing a <code>classes.dex</code> entry. This can be used to execute code not installed as part of an application.</p><p>Prior to API level 26, this class loader requires an application-private, writable directory to cache optimized classes. Use <code>Context.getCodeCacheDir()</code> to create such a directory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    File dexOutputDir = context.getCodeCacheDir();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>Do not cache optimized classes on external storage.</strong> External storage does not provide access controls necessary to protect your application from code injection attacks.</p></blockquote><p>很明显，对比 PathClassLoader 只能加载已经安装应用的 dex 或 apk 文件，DexClassLoader 则没有此限制，可以从 SD 卡上加载包含 class.dex 的 .jar 和 .apk 文件，这也是插件化和热修复的基础，在不需要安装应用的情况下，完成需要使用的 dex 的加载。</p><p>我们来看下DexClassLoader的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现只有一个构造函数，其具体实现应该在BaseDexClassLoader中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Class c = <span class="keyword">this</span>.pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + <span class="keyword">this</span>.pathList);</span><br><span class="line">            Iterator i$ = suppressedExceptions.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i$.hasNext()) &#123;</span><br><span class="line">                Throwable t = (Throwable)i$.next();</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pathList.findResource(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pathList.findResources(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pathList.findLibrary(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Package <span class="title">getPackage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; !name.isEmpty()) &#123;</span><br><span class="line">            Package pack = <span class="keyword">super</span>.getPackage(name);</span><br><span class="line">            <span class="keyword">if</span> (pack == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pack = <span class="keyword">this</span>.definePackage(name, <span class="string">"Unknown"</span>, <span class="string">"0.0"</span>, <span class="string">"Unknown"</span>, <span class="string">"Unknown"</span>, <span class="string">"0.0"</span>, <span class="string">"Unknown"</span>, (URL)<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> pack;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLdLibraryPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        File[] arr$ = <span class="keyword">this</span>.pathList.getNativeLibraryDirectories();</span><br><span class="line">        <span class="keyword">int</span> len$ = arr$.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">            File directory = arr$[i$];</span><br><span class="line">            <span class="keyword">if</span> (result.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.append(<span class="string">':'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.append(directory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getClass().getName() + <span class="string">"["</span> + <span class="keyword">this</span>.pathList + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到上面几个函数我们应该比较熟悉，即<code>findClass(String name)</code>、<code>findResource(String name)</code>等，不过其具体实现都是委托给DexPathList。其构造函数为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其参数为：</p><ul><li>definingContext：类加载器</li><li>dexPath：apk/jar/dex 的路径集</li><li>libraryPath：native 库的路径集</li><li>optimizedDirectory：缓存优化的 dex 文件的路径</li></ul><p>构造函数中最终要的一行代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions);</span><br></pre></td></tr></table></figure><p>这行代码构造了一个Element数组。那么Element是什么呢？它是DexPathList的一个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> File file;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDirectory;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> File zip;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;</span><br><span class="line">        <span class="keyword">private</span> ZipFile zipFile;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(File file, <span class="keyword">boolean</span> isDirectory, File zip, DexFile dexFile)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.file = file;</span><br><span class="line">            <span class="keyword">this</span>.isDirectory = isDirectory;</span><br><span class="line">            <span class="keyword">this</span>.zip = zip;</span><br><span class="line">            <span class="keyword">this</span>.dexFile = dexFile;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isDirectory) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"directory \""</span> + <span class="keyword">this</span>.file + <span class="string">"\""</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.zip != <span class="keyword">null</span> ? <span class="string">"zip file \""</span> + <span class="keyword">this</span>.zip + <span class="string">"\""</span> : <span class="string">"dex file \""</span> + <span class="keyword">this</span>.dexFile + <span class="string">"\""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">maybeInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">                <span class="keyword">this</span>.initialized = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.isDirectory &amp;&amp; <span class="keyword">this</span>.zip != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.zipFile = <span class="keyword">new</span> ZipFile(<span class="keyword">this</span>.zip);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">                        System.logE(<span class="string">"Unable to open zip file: "</span> + <span class="keyword">this</span>.file, var2);</span><br><span class="line">                        <span class="keyword">this</span>.zipFile = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.maybeInit();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isDirectory) &#123;</span><br><span class="line">                File resourceFile = <span class="keyword">new</span> File(<span class="keyword">this</span>.file, name);</span><br><span class="line">                <span class="keyword">if</span> (resourceFile.exists()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> resourceFile.toURI().toURL();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MalformedURLException var4) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(var4);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.zipFile != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.zipFile.getEntry(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> URL(<span class="string">"jar:"</span> + <span class="keyword">this</span>.file.toURL() + <span class="string">"!/"</span> + name);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (MalformedURLException var5) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(var5);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，它有一个非常重要的成员变量DexFile。接着回到主流程，我们通过makeDexElements()方法得到了一个elements数组。那么，makeDexElements()方法具体干了什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DexPathList.Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    ArrayList&lt;DexPathList.Element&gt; elements = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    Iterator i$ = files.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        File file;</span><br><span class="line">        File zip;</span><br><span class="line">        DexFile dex;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i$.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (DexPathList.Element[])elements.toArray(<span class="keyword">new</span> DexPathList.Element[elements.size()]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            file = (File)i$.next();</span><br><span class="line">            zip = <span class="keyword">null</span>;</span><br><span class="line">            dex = <span class="keyword">null</span>;</span><br><span class="line">            String name = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                elements.add(<span class="keyword">new</span> DexPathList.Element(file, <span class="keyword">true</span>, (File)<span class="keyword">null</span>, (DexFile)<span class="keyword">null</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(<span class="string">".dex"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var11) &#123;</span><br><span class="line">                        System.logE(<span class="string">"Unable to load dex file: "</span> + file, var11);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    zip = file;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">                        suppressedExceptions.add(var10);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(zip == <span class="keyword">null</span> &amp;&amp; dex == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        elements.add(<span class="keyword">new</span> DexPathList.Element(file, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">optimizedPathFor</span><span class="params">(File path, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">    String fileName = path.getName();</span><br><span class="line">    <span class="keyword">if</span> (!fileName.endsWith(<span class="string">".dex"</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastDot = fileName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (lastDot &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fileName = fileName + <span class="string">".dex"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(lastDot + <span class="number">4</span>);</span><br><span class="line">            sb.append(fileName, <span class="number">0</span>, lastDot);</span><br><span class="line">            sb.append(<span class="string">".dex"</span>);</span><br><span class="line">            fileName = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File result = <span class="keyword">new</span> File(optimizedDirectory, fileName);</span><br><span class="line">    <span class="keyword">return</span> result.getPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是通过loadDexFile()方法把dex文件都加载出来，然后返回一个elements数组。 不过最终调用的是native方法进行dex文件的解析，这里就不深究。</p><p>接着，我们来看DexPathList中最重要的方法findClass()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    DexPathList.Element[] arr$ = <span class="keyword">this</span>.dexElements;</span><br><span class="line">    <span class="keyword">int</span> len$ = arr$.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">        DexPathList.Element element = arr$[i$];</span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, <span class="keyword">this</span>.definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(<span class="keyword">this</span>.dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它就是通过遍历elements数组，拿到里面的每一个dex文件，通过DexFile的loadClassBinaryName()方法找到class字节码。通过查看DexFile源码，可以得知loadClassBinaryName()方法最终是调用的底层C++方法来load class。<br>至此，我们就完整地了解了ClassLoader加载class的具体实现。</p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>现在，我们将实现从本地目录中动态加载一个未安装的APK应用，并调用类中的方法。</p><ol><li><p>AndroidStudio中new module（新建应用），仅包含MainActivity文件并输出打印:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.v(<span class="string">"yunlinos"</span>, <span class="string">"Dex hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命令行执行gradle build（或者直接用IDE导出APK），将生成的apk文件push到手机中或者模拟器中（当前运行环境为Android5.1）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  debug adb push DexApp-debug.apk /sdcard/</span><br><span class="line">DexApp-debug.apk: 1 file pushed. 1.7 MB/s (1578288 bytes in 0.897s)</span><br></pre></td></tr></table></figure></li><li><p>新建宿主应用，并添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loadLocalDex();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadLocalDex</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File apkFile = <span class="keyword">new</span> File(<span class="string">"/sdcard/DexApp-debug.apk"</span>);</span><br><span class="line"></span><br><span class="line">        DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(apkFile.getAbsolutePath(),</span><br><span class="line">                Objects.requireNonNull(getExternalCacheDir()).getAbsolutePath(), <span class="keyword">null</span>, ClassLoader.getSystemClassLoader());</span><br><span class="line">        Class&lt;?&gt; mainClass = dexClassLoader.loadClass(<span class="string">"com.yunlinos.dexapp.MainActivity"</span>);</span><br><span class="line">        Object obj = mainClass.newInstance();</span><br><span class="line">        Method method = mainClass.getDeclaredMethod(<span class="string">"printHello"</span>);</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>运行该宿主应用，看能否动态加载APK，其打印为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">09</span>-<span class="number">10</span> <span class="number">20</span>:<span class="number">16</span>:<span class="number">22.862</span> <span class="number">4621</span>-<span class="number">4621</span>/? V/yunlinos: Dex hello</span><br><span class="line"><span class="number">09</span>-<span class="number">10</span> <span class="number">20</span>:<span class="number">16</span>:<span class="number">22.892</span> <span class="number">4621</span>-<span class="number">4638</span>/? D/OpenGLRenderer: Use EGL_SWAP_BEHAVIOR_PRESERVED: <span class="keyword">false</span></span><br><span class="line"><span class="number">09</span>-<span class="number">10</span> <span class="number">20</span>:<span class="number">16</span>:<span class="number">22.900</span> <span class="number">4621</span>-<span class="number">4621</span>/? D/Atlas: Validating map...</span><br><span class="line"><span class="number">09</span>-<span class="number">10</span> <span class="number">20</span>:<span class="number">16</span>:<span class="number">22.974</span> <span class="number">4621</span>-<span class="number">4638</span>/com.yunlinos.applicationhook I/OpenGLRenderer: Initialized EGL, version <span class="number">1.4</span></span><br><span class="line"><span class="number">09</span>-<span class="number">10</span> <span class="number">20</span>:<span class="number">16</span>:<span class="number">22.976</span> <span class="number">4621</span>-<span class="number">4638</span>/com.yunlinos.applicationhook D/OpenGLRenderer: Enabling debug mode <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>从打印可以看出，顺利加载APK中的类并可以反射调用其方法。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在文章最后，我们仅仅只是给出了简单的例子，用来加载未安装APK中的类而已。但是，我们仍然可以发散自己的思维，如果我们可以启动该APK中的Activity、Service或者是其他组件，或者是我们从服务端下发更新的APK，那么不就是成为了插件化开发或者是热部署嘛。</p><p>Android插件化开发的道路很长，后面我们将慢慢是领会其中的精髓。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是类加载机制系列的第二篇，即Android类加载器。Android的Dalvik/ART虚拟机和Java的JVM虚拟机一样，也是需要加载
      
    
    </summary>
    
      <category term="Android插件化和热修复" scheme="http://yunlinos.com/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="Android类加载器" scheme="http://yunlinos.com/tags/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制：Java ClassLoader</title>
    <link href="http://yunlinos.com/archives/fe0b388a.html"/>
    <id>http://yunlinos.com/archives/fe0b388a.html</id>
    <published>2018-09-09T07:14:45.000Z</published>
    <updated>2018-09-09T09:50:17.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是类加载机制系列的第一篇，即Java类加载器，下篇将介绍Android类加载器。该篇文章将从以下两个方面进行概述：</p><ol><li>介绍Java类加载器的基本概念</li><li>如何自定义类加载器</li></ol><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java类加载器（ClassLoder）：用来加载Java类到Java虚拟机中。其完整流程如下：</p><p>Java程序是在Java虚拟机上运行的。当我们编译源程序（<code>.java</code>文件）时，它将会以字节码的形式转化为平台和机器可以独立使用的文件，即<code>.class</code>文件。然后类加载器负责读取该字节码，并转换为<code>java.lang.Class</code>类的一个实例。最后通过该实例的构造方法即可创建对象。</p><p>另外，Java字节码不是只能在编译期生成，也可以在运行期动态生成，也可以从本地或者网络中拿到。所以，这种特性就允许我们做出一些很酷的事情，比如在程序运行期间进行动态加载等等。</p><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>先给出结论，在Java中，类加载器有三种：</p><ol><li><strong>Bootstrap Class Loader：</strong>引导类加载器是核心JVM的一部分，用本地代码编写。不同的平台可能有不同的实现。用来加载JDK内部类，通常加载rt.jar和其他核心类，例如java.lang.*包类。</li><li><strong>Extensions Class Loader：</strong>扩展类加载器是引导类加载器的子类，负责加载核心Java类的扩展，以便平台上运行的所有应用程序都可以使用它。从JDK extensions目录中加载类，通常是$JAVA_HOME/lib/ext目录。</li><li><strong>System Class Loader：</strong>系统类加载器负责将所有应用程序级别的类装入到JVM中。主要从当前类路径加载类，这些类可以在使用-cp或-classpath命令行选项调用程序时设置。</li></ol><p>我们可以用代码来看看不同的类加载器加载不同的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassLoaderTree.class.getClassLoader());</span><br><span class="line">        System.out.println(Logger.class.getClassLoader());</span><br><span class="line">        System.out.println(List.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 运行结果</span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">45</span>ee12a7</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>正如我们看到的，这里有三种不同的类加载器：AppClassLoader、ExtClassLoader和BootstrapClassLoader（显示为null）。除了系统提供的类加载器外，我们同样可以通过继承<code>java.lang.ClassLoader</code>类的方式来实现自己的类加载器，以满足特殊的需求，例如从本地加载字节码。</p><h2 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h2><p>除了引导类加载器外，所有的类加载器都有父类加载器。即系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器。而在我们日常开发中，如果需要自定义类加载器，也一般是继承自系统类加载器。</p><p>我们同样可以通过代码看到其继承关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = ClassLoaderTree.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line"><span class="keyword">while</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    classLoader = classLoader.getParent();</span><br><span class="line">    System.out.println(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 运行结果</span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">45</span>ee12a7</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>而在类的实际加载过程中，通常遵循委托模式，通常也被称作双亲委托（委派）模式。即类加载器会将类的加载委托给父类加载器。比如需要将某个应用的类加载到JVM中，通常是通过系统类加载器进行完成，不过系统类加载器会首先将其委托给扩展类加载器，后者又将其委托给引导类加载器。只有当引导类加载器和扩展类加载都加载失败时，系统类加载器才会加载该类。</p><p>这里，我们就会存在一个疑问：为什么系统类加载器不直接加载该类而委托给父类加载？</p><p>其主要的原因是为了防止内存中加载同样的字节码，从而保证程序的稳定性。比如类加载器A和B都需要加载<code>ClassLoaderTree</code>类：</p><ul><li>不使用委托机制，自己来进行加载时：A会加载一份<code>ClassLoaderTree</code>字节码，B也会加载一份<code>ClassLoaderTree</code>字节码。而在Java虚拟机中，判断类相同，不仅仅根据其全名来判断，还要看该类的类加载器是否相同。所以，此时加载在内存中的两个<code>ClassLoaderTree</code>类是无法兼容的。既导致性能的损耗，也会导致更多的使用问题。</li><li>但是用委托机制时：就会递归的向父类查找，也就是会首选BootstrapClassLoader进行加载，如果无法加载再使用子类加载器。而A和B同时进行加载时，如果BootstrapClassLoader发现该类已经加载过，就会直接返回内存的<code>ClassLoaderTree</code>，而不必重复加载。</li></ul><h2 id="类加载器的加载过程"><a href="#类加载器的加载过程" class="headerlink" title="类加载器的加载过程"></a>类加载器的加载过程</h2><p>要想理解类的加载过程，需要从<code>java.lang.ClassLoader</code>着手，基本上所有的类加载器都是该类的一个实例。而该类的基本职责就是根据一个指定类的名称，找到或者生成对应的自己字节代码，然后从这些自己字节代码中定义出一个Java类。这里挑出几个重要方法来解释：</p><ul><li><strong>getParent()：</strong>返回该类的父类加载器</li><li><strong>loadClass(String name)：</strong>加载名称为 <code>name</code>的类，返回的结果是 <code>java.lang.Class</code>类的实例。不建议重写但可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委托模式的实现，直接重写可能会破坏委托模式。</li><li><strong>findClass(String name)：</strong>查找名称为 <code>name</code>的类，返回的结果是 <code>java.lang.Class</code>类的实例。建议将自定义的类加载逻辑写在findClass()方法中，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</li><li><strong>defineClass(String name, byte[] b, int off, int len)：</strong>用来将byte字节流解析成JVM能够识别的Class对象(ClassLoader中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如获取本地的一个类的字节码，然后转换为byte字节流创建对应的Class对象，defineClass()方法通常与findClass()方法一起使用。一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。</li><li><strong>resolveClass(Class&lt;?&gt; c)：</strong>链接指定的 Java 类。</li></ul><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>虽然在绝大多数情况下，系统默认提供的类加载器实现已经可以满足需求。但是在某些情况下，我们还是需要为应用开发出自己的类加载器，比如在日常的开发中，需要从本地或者网络中获取字节码，然后加载并生成新的对象使用。</p><p>下面的例子就是加载从网络获取的Java字节代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] netClassData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NetClassLoader</span><span class="params">(<span class="keyword">byte</span>[] netClassData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.netClassData = netClassData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (netClassData == <span class="keyword">null</span> || netClassData.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(className, netClassData, <span class="number">0</span>, netClassData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类加载器一般只需要覆写 <code>findClass(String name)</code>方法即可，即在该方法中可以从本地、网络或者动态生成字节码，只需要修改字节码的来源即可。<code>java.lang.ClassLoader</code>类的方法 <code>loadClass()</code>封装了前面提到的双亲委托机制。该方法会首先调用 <code>findLoadedClass()</code>方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的 <code>loadClass()</code>方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用 <code>findClass()</code>方法来查找该类。</p><p>因此，为了保证类加载器实现双亲委托机制，在自定义类加载器时，最好不要覆写 <code>loadClass()</code>方法，而是覆写 <code>findClass()</code>方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的内容中，我们了解了类的加载流程，也知道了如何自定义类加载器。这也让我们的程序有了更多的可能性，比如软件的热部署、热修复等等。当然，最后的实现的难度会远远超过现有的例子。这里，只是个开始。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是类加载机制系列的第一篇，即Java类加载器，下篇将介绍Android类加载器。该篇文章将从以下两个方面进行概述：&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="Android插件化和热修复" scheme="http://yunlinos.com/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="Java类加载器" scheme="http://yunlinos.com/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java 注解处理器</title>
    <link href="http://yunlinos.com/archives/f53379a7.html"/>
    <id>http://yunlinos.com/archives/f53379a7.html</id>
    <published>2018-09-05T00:19:02.000Z</published>
    <updated>2018-09-09T06:54:43.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<code>EventBus3.0</code>中，最大的改变和亮点就是在编译时生成索引，提升初始订阅者的注册速度，这里就用到了编译时注解。而在其他开源项目中，例如：ButterKnife、ARouter等，也都有用到该技术手段，根据特定的注解生成特定的Java代码使我们项目的开发更加高效。</p><p>在这篇文章中，我们会简单的介绍以下几点，如果只对注解处理器的实现感兴趣请跳转至<a href="#实现注解处理器">实现部分</a>：</p><ol><li>注解的分类和概念</li><li>注解处理器的处理流程</li><li>如何实现注解处理器</li></ol><h2 id="注解的分类和概念"><a href="#注解的分类和概念" class="headerlink" title="注解的分类和概念"></a>注解的分类和概念</h2><p>注解根据功能、运行时机不同共分为三类：<strong>标记类注解、运行时注解、编译时注解</strong>，我们根据<code>@Retention</code>注解传入的值不同来区分这三种注解。</p><h3 id="标记类注解"><a href="#标记类注解" class="headerlink" title="标记类注解"></a>标记类注解</h3><p>该注解对应<code>RetentionPolicy.SOURCE</code>。主要用来标记一些信息，最常见的就是<code>@Override</code>、<code>@SuppressWarnings</code>等，这些注解仅仅用于标记，主要是给IDE看的，可以用作一些检验。</p><p>以下是<code>@Override</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行时注解"><a href="#运行时注解" class="headerlink" title="运行时注解"></a>运行时注解</h3><p>该注解对应<code>RetentionPolicy.RUNTIME</code>。主要用来运行时处理的注解。比如在运行期通过类的对象，然后反射拿到相关的信息，这也是<code>EventBus</code>默认的处理方式。</p><p>以下是<a href="https://github.com/yunlinos/EventFlyer" target="_blank" rel="noopener">EventFlyer</a>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RemoteSubscribe &#123;</span><br><span class="line">    <span class="function">ThreadMode <span class="title">threadMode</span><span class="params">()</span> <span class="keyword">default</span> ThreadMode.MAIN</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RemoteSubscribe subscribeAnnotation = method.getAnnotation(RemoteSubscribe.class);</span><br><span class="line"><span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译时注解"><a href="#编译时注解" class="headerlink" title="编译时注解"></a>编译时注解</h3><p>该注解对应<code>RetentionPolicy.CLASS</code>。主要用于在编译期根据注解标识，来进行相应处理。本文的主要内容就是这种注解，目的是在编译期间根据注解内容，动态生成类和文件等。因为是在编译期间生成的文件代码，所以和手写的代码完全一致，也就不需要在运行期间通过反射获取注解内容，避免性能的损耗。</p><p>以下是<code>Butter Knife</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(CLASS) <span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">  <span class="comment">/** View ID to which the field will be bound. */</span></span><br><span class="line">  <span class="meta">@IdRes</span> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解的作用对象"><a href="#注解的作用对象" class="headerlink" title="注解的作用对象"></a>注解的作用对象</h3><p>在上面三种注解类型的源码中，我们会注意到<code>@Target</code>，这个作为注解的作用对象，<code>@Target</code>接受值为<code>ElementType[]</code>，<code>ElementType</code>是一个枚举类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    TYPE,</span><br><span class="line">    FIELD,</span><br><span class="line">    METHOD,</span><br><span class="line">    PARAMETER,</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    PACKAGE,</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    TYPE_USE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ElementType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其相应的用法为：</p><table><thead><tr><th>名称</th><th>作用对象</th></tr></thead><tbody><tr><td>TYPE</td><td>接口、类、枚举、注解</td></tr><tr><td>FIELD</td><td>方法、枚举的常量</td></tr><tr><td>METHOD</td><td>方法</td></tr><tr><td>PARAMETER</td><td>方法参数</td></tr><tr><td>CONSTRUCTOR</td><td>构造函数</td></tr><tr><td>LOCAL_VARIABLE</td><td>局部变量</td></tr><tr><td>ANNOTATION_TYPE</td><td>注解</td></tr><tr><td>PACKAGE</td><td>包</td></tr><tr><td>TYPE_PARAMETER</td><td>类型参数声明（Java8新特性）</td></tr><tr><td>TYPE_USE</td><td>类型使用声明（Java8新特性）</td></tr></tbody></table><h2 id="注解处理器的处理流程"><a href="#注解处理器的处理流程" class="headerlink" title="注解处理器的处理流程"></a>注解处理器的处理流程</h2><p>本文只讨论编译时注解，其基本的处理流程为：在某些代码元素上（如：类型、函数、字段等）添加注解，在编译时编译期会检查<code>AbstractProcessor</code>的子类，并且调用该类型的<code>process</code>函数，然后将添加了注解的所有元素都传递到<code>process</code>函数中，使得开发人员可以在编译器进行相应的处理。如：根据注解生成Java类，这也是<code>EventBus</code>等开源库的基本原理。</p><p><code>AbstractProcessor</code>是处理器的抽象类，我们现在来看下具体的实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnvironment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedSourceVersion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要的实现方法为：</p><ul><li><code>init(ProcessingEnvironment processingEnvironment)</code>：这里是一个特殊的<code>init()</code>方法，它会被注解处理工具调用，并输入<code>ProcessingEnviroment</code>参数。<code>ProcessingEnviroment</code>提供很多有用的工具类<code>Elements</code>、<code>Types</code>和<code>Filer</code>。后面我们将会用到并详细说明其作用。</li><li><code>getSupportedSourceVersion()</code>:用来指定使用的Java版本。通常这里返回<code>SourceVersion.latestSupported()</code>。如果有足够的理由只支持Java 6的话，也可以返回<code>SourceVersion.RELEASE_6</code>。不过建议使用前者。</li><li><code>getSupportedAnnotationTypes()</code>：必须指定这个注解处理器是注册给哪些注解的。它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。换句话说，在这里定义注解处理器要处理哪些注解。</li><li><code>process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</code>:这里相当于每个处理器的主函数<code>main()</code>。在这里写扫描、评估、处理注解以及生成Java文件的代码。输入参数<code>RoundEnviroment</code>，可以让你查询出包含特定注解的被注解元素。</li></ul><p>不过，如果我们需要用到该注解处理器，还必须将其注册到javac中。即需要打包一个特定的文件<code>javax.annotation.processing.Processor</code>到<code>META-INF/services</code>路径下，javac会自动检查和读取该文件的内容，并且注册<code>AnnotationProcessor</code>为注解解释器。所以.jar文件看起来就像下面这样：</p><ul><li>AnnotationProcessor.jar</li><li><ul><li>com</li></ul></li><li><ul><li><ul><li>yunlinos</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AnnotationProcessor.class</li></ul></li></ul></li></ul></li><li><ul><li>META-INF</li></ul></li><li><ul><li><ul><li>services</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>javax.annotation.processing.Processor</li></ul></li></ul></li></ul></li></ul><p>看起来操作特别麻烦，好在google提供了可以让我们方便开发的工具，我们直接使用<code>@AutoService</code>注解就可以达到以上目的。要使用该注解，可以通过gradle导入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.auto.service:auto-service:1.0-rc4'</span></span><br></pre></td></tr></table></figure><p>完整注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="实现注解处理器"><a href="#实现注解处理器" class="headerlink" title="实现注解处理器"></a>实现注解处理器</h2><p>在上一篇文章<a href="http://yunlinos.com/archives/46aebf49.html">Android IPC库EventFlyer</a>中，我们使用了运行时注解（通过反射机制）来获取到订阅者的相关信息。现在，我们尝试使用编译时注解来获取相关索引，一步步来实现类似于<code>EventBus3.0</code>中的索引机制。</p><p><strong>完整源码地址：</strong><a href="https://github.com/yunlinos/ApplicationAnnotation" target="_blank" rel="noopener">Github</a></p><ol><li><p>定义相关的注解，即编译时注解<code>RetentionPolicy.CLASS</code>，注解修饰方法<code>ElementType.METHOD</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RemoteSubscribe &#123;</span><br><span class="line">    <span class="function">ThreadMode <span class="title">threadMode</span><span class="params">()</span> <span class="keyword">default</span> ThreadMode.MAIN</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>让项目依赖依赖相关库，<code>auto-service</code>的作用前面已经提到，用来动态生成生成<code>Processor</code>文件；而<code>javapoet</code>则会在后面用到时详细说明，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.auto.service:auto-service:1.0-rc4'</span></span><br><span class="line">implementation <span class="string">'com.squareup:javapoet:1.10.0'</span></span><br></pre></td></tr></table></figure></li><li><p>构建实际的注解处理器<code>RemoteSubscribeProcessor</code>。我们先写好该类大体的轮廓，然后再详解<code>process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteSubscribeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPTION_EVENT_FLYER_INDEX = <span class="string">"eventFlyerIndex"</span>;</span><br><span class="line">    <span class="keyword">private</span> Types typeUtils;</span><br><span class="line">    <span class="keyword">private</span> Elements elementUtils;</span><br><span class="line">    <span class="keyword">private</span> Filer filer;</span><br><span class="line">    <span class="keyword">private</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;TypeElement, List&lt;ExecutableElement&gt;&gt; methodsByClass = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnvironment);</span><br><span class="line">        typeUtils = processingEnv.getTypeUtils();</span><br><span class="line">        elementUtils = processingEnv.getElementUtils();</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">        messager = processingEnv.getMessager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        annotations.add(RemoteSubscribe.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">return</span> annotations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第1行<code>@AutoService(Processor.class)</code>，是一个其他注解处理器中引入的注解。<code>AutoService</code>注解处理器是Google开发的，用来生成<code>META-INF/services/javax.annotation.processing.Processor</code>文件的。</p><p>第10行<code>init</code>函数，可以获取以下引用：<strong>Types、Elements、Filer、Messager</strong>。其完整的含义解释详见<a href="#参考资料">参考资料</a>。</p><p>第27行<code>getSupportedAnnotationTypes</code>函数，指定了该注解处理器是注册给<code>RemoteSubscribe</code>注解的。</p><p>第34行<code>getSupportedSourceVersion()</code>函数，指定了使用的Java版本。</p></li><li><p>搜索<code>@RemoteSubscribe</code>注解，<code>roundEnvironment.getElementsAnnotatedWith(RemoteSubscribe.class)</code>会返回所有被注解了<code>@RemoteSubscribe</code>的元素列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历所有被注解了@RemoteSubscribe的元素</span></span><br><span class="line"><span class="keyword">for</span> (Element annotationElement : roundEnvironment.getElementsAnnotatedWith(RemoteSubscribe.class)) &#123;</span><br><span class="line">    <span class="comment">// 如果被注解的元素是方法，则继续处理，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (annotationElement.getKind() == ElementKind.METHOD) &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"@Subscribe is only valid for methods"</span>, annotationElement);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们用到了<code>Messager</code>类用来打印异常信息。为什么不直接抛出一个异常<code>Exception</code>呢？因为如果在<code>process()</code>中抛出一个异常，那么运行注解处理器的JVM将会崩溃（就像其他Java应用一样），使用我们注解处理器RemoteSubscribeProcessor第三方开发者将会从javac中得到非常难懂的出错信息，因为它包含RemoteSubscribeProcessor的堆栈跟踪（Stacktace）信息。而<code>Messager</code>类则能够打印非常优美的错误信息。其完整用法可参见<a href="http://docs.oracle.com/javase/7/docs/api/javax/tools/Diagnostic.Kind.html" target="_blank" rel="noopener">官方文档</a>。</p></li><li><p>注解匹配标准，并获取注解方法列表<code>methodsByClass</code>。在获取到所有的元素后，还需要验证相关方法的合法性，并将合法的方法放置在集合中，留待后面使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取动态生成的.class文件的保存路径，该属性定义在项目build.gradle文件中</span></span><br><span class="line">    String index = processingEnv.getOptions().get(OPTION_EVENT_FLYER_INDEX);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (Element annotationElement : roundEnvironment.getElementsAnnotatedWith(RemoteSubscribe.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (annotationElement.getKind() == ElementKind.METHOD) &#123;</span><br><span class="line">            ExecutableElement method = (ExecutableElement) annotationElement;</span><br><span class="line">            <span class="comment">// 校验方法的合法性</span></span><br><span class="line">            <span class="keyword">if</span> (checkHasNoErrors(method)) &#123;</span><br><span class="line">                TypeElement classElement = (TypeElement) method.getEnclosingElement();</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, String.format(<span class="string">"annotations found &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class: %1s method: %2s"</span>, classElement.getSimpleName(), method.getSimpleName()));</span><br><span class="line">                List&lt;ExecutableElement&gt; executableElementList = methodsByClass.get(classElement);</span><br><span class="line">                <span class="keyword">if</span> (executableElementList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    executableElementList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                executableElementList.add(method);</span><br><span class="line">                methodsByClass.put(classElement, executableElementList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"@Subscribe is only valid for methods"</span>, annotationElement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (!methodsByClass.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 生成实际代码</span></span><br><span class="line">        createInfoIndexFile(index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.WARNING, <span class="string">"No @Subscribe annotations found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkHasNoErrors</span><span class="params">(ExecutableElement element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.getModifiers().contains(Modifier.STATIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must not be static"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (!element.getModifiers().contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must be public"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    List&lt;? extends VariableElement&gt; parameters = element.getParameters();</span><br><span class="line">    <span class="keyword">if</span> (parameters.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must have exactly 1 parameter"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码生成。在获取到我们所需要的所有注解方法后，我们就可以实际生成Java代码了。而生成Java代码的方式有很多中：</p><ul><li>可以直接用拼接字符串来生成文件</li><li>使用Square公司（因为提供了许多非常优秀的开源项目而非常有名）提供的<a href="https://github.com/square/javawriter" target="_blank" rel="noopener"><code>JavaWriter</code></a></li><li>使用<a href="https://github.com/square/javapoet" target="_blank" rel="noopener"><code>JavaPoet</code></a>来生成代码，也就是我们上面所依赖的相关库，详细使用见<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">Github</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec printAnnotationMethod = MethodSpec.methodBuilder(<span class="string">"printAnnotation"</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">        .returns(<span class="keyword">void</span>.class)</span><br><span class="line">        .addStatement(<span class="string">"$T.out.println($S)"</span>, System.class, <span class="string">"Hello, JavaPoet! Get RemoteSubscribe Class size: "</span> + methodsByClass.entrySet().size())</span><br><span class="line">        .build();</span><br><span class="line">   </span><br><span class="line">TypeSpec eventFlyerIndex = TypeSpec.classBuilder(clazz)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">        .addMethod(printAnnotationMethod)</span><br><span class="line">        .build();</span><br><span class="line">   </span><br><span class="line">JavaFile eventFlyerIndexFile = JavaFile.builder(pkg, eventFlyerIndex).build();</span><br><span class="line">   </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    eventFlyerIndexFile.writeTo(filer);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其生成的相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yunlinos.applicationannotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventFlyerIndex</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello, JavaPoet! Get RemoteSubscribe size: 2"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，我们在拿到相关注解方法的集合后，就能动态生成更多有意思的代码。那么，这个动态生成的Java类，我们又该怎么去调用呢？</p><ul><li>直接创建对象或者调用其静态方法：<code>EventFlyerIndex.printAnnotation();</code></li><li>通过反射机制来创建对象，而不需要开发者手动来做这些。<code>ButterKnife</code>中就是这样处理的，在牺牲一丢丢性能的情况下，极大提高了开发者的开发速度。</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在前面的介绍中，我们知道了怎么自定义注解处理器，并且也大概知道了<strong>EventBus、ButterKnife、ARouter</strong>这些优秀开源的实现思路。不过，仍然有以下几点值得我们关注：</p><ol><li>分离处理器和注解。<ul><li>定义注解的module , java库，xxxx-annotations</li><li>实现注解器的module, java库，xxxx-compiler</li><li>提供对外接口的module, android库，xxxx-api</li></ul></li><li>处理循环情况。注解处理过程可能会多于一次。</li><li>生成类的实例化。可根据请用场景选择实例化方式。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://race604.com/annotation-processing/" target="_blank" rel="noopener">java注解处理器</a><br><a href="https://blog.csdn.net/crazy1235/article/details/51876192" target="_blank" rel="noopener">JavaPoet的基本使用</a><br><a href="https://github.com/ShowJoy-com/showjoy-blog/issues/30" target="_blank" rel="noopener">Android开发你需要知道的注解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;EventBus3.0&lt;/code&gt;中，最大的改变和亮点就是在编译时生成索引，提升初始订阅者的注册速度，这里就用到了编译时注解
      
    
    </summary>
    
      <category term="Android插件化和热修复" scheme="http://yunlinos.com/categories/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="注解处理器" scheme="http://yunlinos.com/tags/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
      <category term="编译时注解" scheme="http://yunlinos.com/tags/%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Android IPC库EventFlyer</title>
    <link href="http://yunlinos.com/archives/46aebf49.html"/>
    <id>http://yunlinos.com/archives/46aebf49.html</id>
    <published>2018-09-02T06:13:41.000Z</published>
    <updated>2018-09-06T12:39:50.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为使得跨进程通信更加高效和方便，且实现在系统内单播和广播的功能，参照伟大的EventBus，实现了这款跨进程通信库。</p><p>项目地址：<a href="https://github.com/yunlinos/EventFlyer" title="EventFlyer" target="_blank" rel="noopener">https://github.com/yunlinos/EventFlyer</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>EventFlyer 是一款Android上的IPC (进程间通信) 库，使用起来和<a href="https://github.com/greenrobot/EventBus" title="EventBus" target="_blank" rel="noopener">EventBus</a>一样方便，其架构设计和代码实现来源于EventBus项目。<br><img src="/archives/46aebf49/EventFlyer.png" alt="EventFlyer"></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>简化应用程序之间的通信</li><li>避免生命周期的问题</li><li>支持线程切换</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在项目根目录的<code>build.gradle</code>中添加<code>jcenter()</code>仓库：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在应用的<code>build.gradle</code>中添加依赖：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'com.yunlinos.library:eventflyer:1.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>初始化负责转发消息的服务，该服务应该尽可能长时间存活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteServer</span> <span class="keyword">extends</span> <span class="title">FlyerService</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>像项目<code>eventmodel</code>中一样定义事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnControlEvent</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>在需要监听事件的应用中，初始化<code>Application</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    EventFlyer.getDefault().init(<span class="keyword">new</span> FlyerConfiguration.Builder()</span><br><span class="line">            .applicationContext(<span class="keyword">this</span>)</span><br><span class="line">            .remoteServicePkgName(<span class="string">"com.yunlinos.eventflyerserver"</span>)</span><br><span class="line">            .remoteServiceClassName(<span class="string">"com.yunlinos.eventflyerserver.RemoteServer"</span>)</span><br><span class="line">            .build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备订阅，声明和注释订阅方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RemoteSubscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventGet</span><span class="params">(OnControlEvent onControlEvent)</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;</span><br></pre></td></tr></table></figure><p><code>Bind</code>、<code>unbind</code>、<code>register</code>、<code>unregister</code>订阅者。 例如在Android上，activity和fragments通常会根据生命周期来注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    EventFlyer.getDefault().bindRemoteServer();</span><br><span class="line">    EventFlyer.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    EventFlyer.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">    EventFlyer.getDefault().unBindRemoteServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在发布事件的其他应用中，同样初始化<code>Application</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    EventFlyer.getDefault().init(<span class="keyword">new</span> FlyerConfiguration.Builder()</span><br><span class="line">            .applicationContext(<span class="keyword">this</span>)</span><br><span class="line">            .remoteServicePkgName(<span class="string">"com.yunlinos.eventflyerserver"</span>)</span><br><span class="line">            .remoteServiceClassName(<span class="string">"com.yunlinos.eventflyerserver.RemoteServer"</span>)</span><br><span class="line">            .build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    EventFlyer.getDefault().bindRemoteServer();</span><br><span class="line">    EventFlyer.getDefault().post(<span class="keyword">new</span> OnControlEvent(<span class="string">"RemoteEvent"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    EventFlyer.getDefault().unBindRemoteServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><pre><code>Copyright 2018 yunlinos &lt;yunlinyeos@gmail.com&gt;Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;为使得跨进程通信更加高效和方便，且实现在系统内单播和广播的功能，参照伟大的EventBus，实现了这款跨进程通信库。&lt;/p&gt;
&lt;p&gt;项目地址
      
    
    </summary>
    
      <category term="Android源码解析" scheme="http://yunlinos.com/categories/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="IPC" scheme="http://yunlinos.com/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>EventBus源码解析</title>
    <link href="http://yunlinos.com/archives/11ada9d0.html"/>
    <id>http://yunlinos.com/archives/11ada9d0.html</id>
    <published>2018-08-23T00:13:59.000Z</published>
    <updated>2018-09-06T12:39:23.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/greenrobot/EventBus" title="EventBus" target="_blank" rel="noopener">EventBus</a>是一款在 Android 和 Java 中使用的发布/订阅事件总线框架。因其体积小、效率高、使用简单而深受开发者喜爱。原理图为：<br><img src="/archives/11ada9d0/EventBus.png" alt="EventBus"></p><p>本文将从 EventBus 使用方法入手，来分析背后的实现原理。其核心方法包括：</p><ol><li>事件注册 <code>EventBus.getDefault().register(this);</code></li><li>取消注册 <code>EventBus.getDefault().unregister(this);</code></li><li>事件发布 <code>EventBus.getDefault().post(new MessageEvent());</code></li></ol><p>看起来特别简单，三行代码就能搞定我们需要的进程内通信。但其实<code>EventBus</code>在背后帮我们做了大量的工作，用了很多优雅的设计模式、代码优化来保证执行效率和可维护性。现在我们就掀开面纱来一探究竟。</p><h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2><p>事件注册的核心方法为 <code>EventBus.getDefault().register(this);</code><br>先看下<code>EventBus.getDefault()</code>的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Convenience singleton for apps using a process-wide EventBus instance. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventBus instance = defaultInstance;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">            instance = EventBus.defaultInstance;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = EventBus.defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBusBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</span></span><br><span class="line"><span class="comment"> * central bus, consider &#123;<span class="doctag">@link</span> #getDefault()&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    logger = builder.getLogger();</span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">    mainThreadPoster = mainThreadSupport != <span class="keyword">null</span> ? mainThreadSupport.createPoster(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">    asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，<code>getDefault</code>是一个单例方法，保证当前只有一个<code>EventBus</code>实例。而<code>EventBus</code>相关属性的初始化则使用了构造者模式，通过传入一个默认配置来完成，即<code>DEFAULT_BUILDER</code>。这样做的好处是对外屏蔽了大量的代码细节，大多数情况下通过默认配置即可完成进程间的通信，根本不需要关心其内部实现。而如果有特殊场景需要自定义属性，则可以通过配置<code>EventBusBuilder</code>来更改<code>EventBus</code>的属性，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder()</span><br><span class="line">        .eventInheritance(<span class="keyword">false</span>)</span><br><span class="line">        .build()</span><br><span class="line">        .register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>我们再来看看<code>register(this)</code>做了些什么。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到当前注册类的class对象</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    <span class="comment">// 根据class对象查找当前类中订阅事件集合，即使用了Subscribe注解、有public修饰符、一个参数的方法</span></span><br><span class="line">    <span class="comment">// SubscriberMethod类主要封装了符合条件方法的相关信息：</span></span><br><span class="line">    <span class="comment">// Method对象、线程模式、事件类型、优先级、是否是粘性事等</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面代码中可以看出，<code>register(this)</code>主要做了两件事，即事件方法的查找、事件方法的注册。我们先来看下查找的过程，从<code>findSubscriberMethods</code>开始：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// METHOD_CACHE是一个ConcurrentHashMap，缓存了subscriberClass和对应SubscriberMethod的集合，以提高注册效率，避免重复查找</span></span><br><span class="line">    <span class="comment">// 如果缓存中能找到，则直接返回相关信息</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在缓存中无法找到，则做进一步查找</span></span><br><span class="line">    <span class="comment">// 由于使用了默认的EventBusBuilder，则ignoreGeneratedIndex属性默认为false，即是否忽略注解生成器</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">        <span class="comment">// 直接使用反射进行方法查找</span></span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用索引进行方法查找</span></span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果对应类中没有符合条件的方法，则抛出异常。否则将这些方法放入到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的注释中我们可以看出流程：先从缓存中查找，如果找到则直接返回，否则就继续进行查找，查找方法为反射和索引（使用默认构造器，则使用<code>findUsingInfo</code>进行方法查找）。如果查找到的方法集合为空，则抛出异常，否则就进行缓存。现在我们进入到<code>findUsingInfo</code>方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用对象池来获取查找工具对象，并初始化注册类的Class对象</span></span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用索引类来查找订阅事件的方法，默认不生成索引类</span></span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射来查找订阅事件的方法</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改findState.clazz为subscriberClass的父类Class，即需要遍历父类</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找到的方法保存在了FindState实例的subscriberMethods集合中。</span></span><br><span class="line">    <span class="comment">// 使用subscriberMethods构建一个新的List&lt;SubscriberMethod&gt;</span></span><br><span class="line">    <span class="comment">// 释放掉findState</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br></pre></td></tr></table></figure></p><p><code>findUsingInfo()</code>方法会在当前要注册的类以及其父类中查找订阅事件的方法，这里出现了一个FindState类，它是<code>SubscriberMethodFinder</code>的内部类，用来辅助查找订阅事件的方法。会默认通过索引来进行方法的查找，默认该索引为空（使用索引来查找，能极大节省反射带来的性能损耗，不过我们先过完整个流程，再回过头来看索引的使用），故具体的查找过程在<code>findUsingReflectionInSingleClass()</code>方法，它主要通过反射查找订阅事件的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">        methods = findState.clazz.getMethods();</span><br><span class="line">        findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环遍历当前类的方法，筛选出符合条件的</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">// 获得方法的修饰符</span></span><br><span class="line">        <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">        <span class="comment">// 如果是public类型，但非abstract、static等</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="comment">// 如果当前方法只有一个参数</span></span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="comment">// 如果当前方法使用了Subscribe注解</span></span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// checkAdd()方法用来判断FindState的anyMethodByEventType map是否已经添加过以当前eventType为key的键值对，没添加过则返回true</span></span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        <span class="comment">// 得到Subscribe注解的threadMode属性值，即线程模式</span></span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        <span class="comment">// 创建一个SubscriberMethod对象，并添加到subscriberMethods集合</span></span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                        <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                    <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码中我们可以看到，在反射查找的过程中，会先遍历该类所有的方法，并验证该方法的参数、注解等信息，判断是否为所需要的事件订阅的方法，如果是的话就放入到集合中。现在，就让我们来看下标准事件的订阅方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEvent</span><span class="params">(MessageEvent event)</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>即在方法中会定义该方法的参数（即传入的<code>MessageEvent</code>），另外，会定义注解信息，包括线程等。关于注解这块，这里就不过解释了，后面会单独出一篇文章介绍工作中注解的使用。</p><p>此时方法查找的流程就分析完了，我们已经找到了当前注册类及其父类中订阅事件的方法的集合。接下来分析具体的注册流程，即<code>register()</code>中的<code>subscribe()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must be called in synchronized block</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    <span class="comment">// Subscription类保存了要注册的类对象以及当前的subscriberMethod</span></span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">    <span class="comment">// subscriptionsByEventType是一个HashMap，保存了以eventType为key,Subscription对象集合为value的键值对</span></span><br><span class="line">    <span class="comment">// 先查找subscriptionsByEventType是否存在以当前eventType为key的值</span></span><br><span class="line">    <span class="comment">// 即获取这个事件对应的订阅者列表</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果之前没有这个事件的订阅者，添加进去</span></span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果之前这个方法已经订阅过这个事件，再次订阅就报错</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历这个事件的订阅方法，调整它在订阅列表中的顺序，高优先级的放前面</span></span><br><span class="line">    <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// typesBySubscriber也是一个HashMap，保存了以当前要注册类的对象为key，注册类中订阅事件的方法的参数类型的集合为value的键值对</span></span><br><span class="line">    <span class="comment">// 查找是否存在对应的参数类型集合</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存当前订阅了事件的方法的参数类型</span></span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 粘性事件相关</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">            <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">            <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">            <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在注册流程中，主要是得到了<code>subscriptionsByEventType</code>、<code>typesBySubscriber</code>两个 HashMap，并且还会处理事件接收的优先级（调整<code>Subscription</code>在列表中的位置）、粘性事件分发（后面额外介绍）。在发送事件的时候要用到<code>subscriptionsByEventType</code>，完成事件的处理。当取消 EventBus 注册的时候要用到<code>typesBySubscriber</code>、<code>subscriptionsByEventType</code>，完成相关资源的释放。</p><p>注册流程为：<br><img src="/archives/11ada9d0/EventBusRegister.png" alt="EventBusRegister"></p><h2 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h2><p>取消注册的核心方法为：<code>EventBus.getDefault().unregister(this);</code><br>在解注册过程中，释放了<code>typesBySubscriber</code>、<code>subscriptionsByEventType</code>中缓存的资源。其核心内容如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到当前参数类型对应的Subscription集合</span></span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="comment">// 遍历Subscription集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            <span class="comment">// 如果当前subscription对象对应的注册类对象 和 要取消注册的注册类对象相同，则删除当前subscription对象</span></span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到当前注册类对象 对应的 订阅事件方法的参数类型 的集合</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除以subscriber（当前注册类对象）为key的键值对</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>取消注册流程为：<br><img src="/archives/11ada9d0/EventBusUnregister.png" alt="EventBusUnregister"></p><h2 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h2><p>事件发布的核心方法为：<code>EventBus.getDefault().post(new MessageEvent());</code><br>我们先进入<code>post</code>方法来看实际流程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Posts the given event to the event bus. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// currentPostingThreadState是一个PostingThreadState类型的ThreadLocal</span></span><br><span class="line">    <span class="comment">// PostingThreadState类保存了事件队列和线程模式等信息</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    <span class="comment">// 将要发送的事件添加到事件队列</span></span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isPosting默认为false</span></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        <span class="comment">// 是否为主线程</span></span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历事件队列</span></span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 发送单个事件</span></span><br><span class="line">                <span class="comment">// eventQueue.remove(0)，从事件队列移除事件</span></span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>post()</code>方法先将发送的事件保存的事件队列，然后通过循环出队列，将事件交给<code>postSingleEvent()</code>方法处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// eventInheritance默认为true，表示是否向上查找事件的父类</span></span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">// 查找当前事件类型的Class，连同当前事件类型的Class保存到集合</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="comment">// 遍历Class集合，继续处理事件</span></span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            logger.log(Level.FINE, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取事件类型对应的Subscription集合</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已订阅了对应类型的事件</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 事件分发处理</span></span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>postSingleEvent()</code>方法中，根据<code>eventInheritance</code>属性（默认为true），决定是否向上遍历事件的父类型，然后跟事件类型获取到对应的<code>Subscription</code>集合，遍历该集合进行事件的分发处理，即<code>postToSubscription</code>。我们继续进入该方法进行分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断订阅事件方法的线程模式</span></span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="comment">// 默认的线程模式</span></span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 在主线程处理事件</span></span><br><span class="line">        <span class="comment">// 如果在主线程发送事件，则直接在主线程通过反射处理事件</span></span><br><span class="line">        <span class="comment">// 如果是在子线程发送事件，则将事件入队列，通过Handler切换到主线程执行处理事件</span></span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 无论在那个线程发送事件，都先将事件入队列，然后通过 Handler 切换到主线程，依次处理事件</span></span><br><span class="line">        <span class="comment">// mainThreadPoster 不为空</span></span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果在主线程发送事件，则先将事件入队列，然后通过线程池依次处理事件</span></span><br><span class="line">        <span class="comment">// 如果在子线程发送事件，则直接在发送事件的线程通过反射处理事件</span></span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 无论在那个线程发送事件，都将事件入队列，然后通过线程池处理</span></span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>postToSubscription()</code>方法就是根据订阅事件方法的线程模式、以及发送事件的线程来判断如何处理事件，至于处理方式主要有两种：</p><ol><li>直接在该线程内进行反射执行</li><li>进行线程切换来执行该方法</li></ol><p>我们先来看第一种方式，即直接在相应线程直接通过<code>invokeSubscriber()</code>方法，用反射来执行订阅事件的方法，这样发送出去的事件就被订阅者接收并做相应处理了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再来看第二种方式，即通过线程切换来达到不同线程接收到事件的目的。实际代码处理如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用subscription和event封装一个PendingPost对象</span></span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 进入队列</span></span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">            handlerActive = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 发送开始处理事件的消息，handleMessage()方法将被执行，完成从子线程到主线程的切换</span></span><br><span class="line">            <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">// 死循环遍历队列</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 出队列</span></span><br><span class="line">            PendingPost pendingPost = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                    pendingPost = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进一步处理pendingPost</span></span><br><span class="line">            eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">            <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">            <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                rescheduled = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        handlerActive = rescheduled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions</span></span><br><span class="line"><span class="comment"> * between &#123;<span class="doctag">@link</span> #unregister(Object)&#125; and event delivery. Otherwise the event might be delivered after the</span></span><br><span class="line"><span class="comment"> * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the</span></span><br><span class="line"><span class="comment"> * live cycle of an Activity or Fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">    Object event = pendingPost.event;</span><br><span class="line">    Subscription subscription = pendingPost.subscription;</span><br><span class="line">    <span class="comment">// 释放pendingPost引用的资源</span></span><br><span class="line">    PendingPost.releasePendingPost(pendingPost);</span><br><span class="line">    <span class="keyword">if</span> (subscription.active) &#123;</span><br><span class="line">        <span class="comment">// 用反射来执行订阅事件的方法</span></span><br><span class="line">        invokeSubscriber(subscription, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方式的处理流程为：</p><ol><li>将subscription和event封装一个PendingPost对象，并放入队列</li><li>使用handleMessage()通知消息处理，完成线程的切换</li><li>遍历队列，取出PendingPost对象，并通过反射处理</li></ol><p>事件发布流程为：<br><img src="/archives/11ada9d0/EventBusPost.png" alt="EventBusPost"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合上面的分析，我们知道了EventBus的实现原理，也明白了它在易用性和效率性所作出的努力。借助它的导入，我们的项目就可以摆脱广播、全局变量、回调等进程内通信方式；但是，EventBus的过量使用，同样会导致软件的可维护性变差，事件的跟踪和处理会变得更加凌乱。</p><p>所以，EventBus可用，但不可滥用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot; title=&quot;EventBus&quot; targ
      
    
    </summary>
    
      <category term="Android源码解析" scheme="http://yunlinos.com/categories/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Python实现单点登录(SSO)</title>
    <link href="http://yunlinos.com/archives/c314ba14.html"/>
    <id>http://yunlinos.com/archives/c314ba14.html</id>
    <published>2018-08-18T07:44:27.000Z</published>
    <updated>2018-09-06T12:38:48.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近打算使用Python实现自动抓取<a href="https://www.atlassian.com/software/confluence" title="Confluence" target="_blank" rel="noopener">Confluence</a>页面，本来以为模拟登陆、页面抓取、数据分析能够一气呵成，可是事实并没有那么简单，直接在模拟登录这块NG了。</p><p>因为公司采用的并非是单系统登录机制，而是采用多系统单点登录机制（SSO），所以在模拟登陆获取<code>cookies</code>时遇到各种权限认证、页面跳转，导致整个过程比较曲折。不过，在仔细研究了单点登录的原理以及抓包后，终于解决了该问题，下面就是对这块内容的整理，主要分为两块：</p><ol><li>单系统登录机制和多系统单点登录机制(SSO)的区别</li><li>Python实现单点登录的过程</li></ol><p>如果对SSO原理不感兴趣，可直接跳转到<a href="#模拟SSO登录">实现部分</a>。</p><h2 id="SSO简介"><a href="#SSO简介" class="headerlink" title="SSO简介"></a>SSO简介</h2><h3 id="http会话机制"><a href="#http会话机制" class="headerlink" title="http会话机制"></a>http会话机制</h3><p>web应用采用browser/server架构，http作为通信协议。http是无状态协议（是指协议对于事务处理没有记忆能力），浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联。</p><p>如果用户需要通过浏览器访问服务器的敏感资源，那么就必须要相应的授权行为，即服务器需要鉴别浏览器的行为，只响应合法请求，忽略非法请求。但是要鉴别浏览器的行为，就必须要清楚浏览器的请求状态，能够识别本次请求的用户是谁，该用户的行为是否经过授权等信息。所以就出现了会话机制，即<a href="https://zhuanlan.zhihu.com/p/21275207" title="Cookie与Session机制" target="_blank" rel="noopener">Cookie与Session机制</a>。</p><p>Cookie通过在浏览器（客户端）记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。浏览器在每次发送http请求时都带上Cookie，而服务器端则根据该信息来判断当前的连接状态，这样就能知道会话的上下文信息了。因此，有了Cookie，服务端就能知道客户端的状态；而没有了Cookie，它连金鱼都不如。<br>有了会话机制，服务端就能更好的做好授权行为，即实现服务端的登录。</p><h3 id="单系统登录机制"><a href="#单系统登录机制" class="headerlink" title="单系统登录机制"></a>单系统登录机制</h3><p>单系统登录机制的实现很简单，就是客户端在第一次请求服务器时带上账号和密码，服务器在拿到这些信息后进行校验，如果校验成功则表明是合法的身份。这时候服务器会返回客户一个身份信息，即Cookie，客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态与权限。其过程如下：<br><img src="/archives/c314ba14/单系统登录.png" alt="单系统登录"></p><h3 id="多系统单点登录机制-SSO"><a href="#多系统单点登录机制-SSO" class="headerlink" title="多系统单点登录机制(SSO)"></a>多系统单点登录机制(SSO)</h3><p>随着计算机网络的发展，很多公司内部不只是单系统，而是发展成为了由多系统组成的应用群，面对各种系统，如果还是使用之前的登录机制，那么每套系统的使用都需要重新登录、注销等等，这将会极大影响日常的工作。</p><p>这时候就会出现了单点登录机制，即SSO(Single Sign On)。在多系统应用群中，只需要登录其中一个系统，即可在其他所有系统中得到授权而无需再次登录。</p><p>sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p><h2 id="模拟SSO登录"><a href="#模拟SSO登录" class="headerlink" title="模拟SSO登录"></a>模拟SSO登录</h2><p>在明白单点登录的原理后，我们就很容易知道后面需要的突破方向。而且只要拿到系统登录页面的cookie后，就能畅通无阻的访问内网的所有其他系统。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>Chrome 使用显示网页源代码和检查功能，来跟踪页面的请求过程</li><li>python 3.6</li><li>requests<br>当然，也可以使用抓包工具来分析整个请求过程，比如Windows上的<code>fiddler</code>，Mac上的<code>charles</code>。不过Chrome已经完全能够满足我们的要求。</li></ul><h3 id="分析登录页面"><a href="#分析登录页面" class="headerlink" title="分析登录页面"></a>分析登录页面</h3><p>打开登录页面，打开（F12或者邮件检查）Chrome自带的分析工具，在Network选卡上可以看到当前浏览器显示页面和提交登录信息的详情，如下图：<br><img src="/archives/c314ba14/登录界面.png" alt="登录界面"></p><p>接下来我们在页面上输入账号密码，点击登录按钮，通过页面追踪分析并模拟整个登录过程。如下图：<br><img src="/archives/c314ba14/登录请求界面.png" alt="登录请求界面"></p><p>从上面请求过程可以分析其流程如下：</p><ol><li>登录按钮提交时用POST方式提交表单，该表单包含账号、密码、it、execution等，并拿到分配的Ticket</li><li>通过Ticket发送Get请求获取SSO的Cookie</li><li>通过SSO Cookie进行最终的请求</li></ol><p>如果我们尝试多次登录，会发现每次it和execution是会变化的，不是固定不变。而这两个值可以从登录页面中直接拿到，在登录页面检查网页源代码，见下图：<br><img src="/archives/c314ba14/网页Execution信息.png" alt="网页Execution信息"></p><p>故我们可以Get请求获取登陆使用Lt和execution数据。</p><h3 id="模拟登录代码实现"><a href="#模拟登录代码实现" class="headerlink" title="模拟登录代码实现"></a>模拟登录代码实现</h3><p>在明白了整个登录后，我们就能开始动手写代码了。不过要注意的是，因为http是无状态的，web页面要保存登录状态需要用到Cookie，所以在每次请求时都需要带上上次返回的Cookie，否则就会被不停的重定向到登录页面，刚开始我也是在这里踩了很多坑。代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLoginInfo</span><span class="params">(it, execution, _eventId)</span>:</span></span><br><span class="line">    login_data = &#123;</span><br><span class="line">        <span class="string">'username'</span>: <span class="string">'***'</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">'***'</span>,</span><br><span class="line">        <span class="string">'imagecode'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'lt'</span>: it,</span><br><span class="line">        <span class="string">'execution'</span>: execution,</span><br><span class="line">        <span class="string">'_eventId'</span>: _eventId</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> login_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLoginHeader</span><span class="params">(str)</span>:</span></span><br><span class="line">    cook = <span class="string">'JSESSIONID='</span> + str</span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">        <span class="string">'Content-Length'</span>: <span class="string">'132'</span>,</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">        <span class="string">'Cache-Control'</span>: <span class="string">'max-age=0'</span>,</span><br><span class="line">        <span class="string">'Upgrade-Insecure-Requests'</span>: <span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36'</span>,</span><br><span class="line">        <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">        <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Origin'</span>: <span class="string">'&lt;url&gt;'</span>,</span><br><span class="line">        <span class="string">'Host'</span>: <span class="string">'&lt;url&gt;'</span>,</span><br><span class="line">        <span class="string">'Referer'</span>: <span class="string">'&lt;url&gt;'</span>,</span><br><span class="line">        <span class="string">'Cookie'</span>: cook</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> header</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getItInfo</span><span class="params">(content)</span>:</span></span><br><span class="line">    m = <span class="string">r'&lt;input type="hidden" name="lt" value="(.+?)" /&gt;'</span></span><br><span class="line">    n = re.findall(m, content)</span><br><span class="line">    <span class="keyword">return</span> n[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getExecutionInfo</span><span class="params">(content)</span>:</span></span><br><span class="line">    m = <span class="string">r'&lt;input type="hidden" name="execution" value="(.+?)" /&gt;'</span></span><br><span class="line">    n = re.findall(m, content)</span><br><span class="line">    <span class="keyword">return</span> n[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getEventIdInfo</span><span class="params">(content)</span>:</span></span><br><span class="line">    m = <span class="string">r'&lt;input type="hidden" name="_eventId" value="(.+?)" /&gt;'</span></span><br><span class="line">    n = re.findall(m, content)</span><br><span class="line">    <span class="keyword">return</span> n[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kb_url = <span class="string">'&lt;url&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 禁用安全请求警告</span></span><br><span class="line">requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class="line">loginreqsession = requests.session()  <span class="comment"># 创建session对象保存所有登录会话请求</span></span><br><span class="line">loginreqsession.keep_alive = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get请求获取登陆使用Lt和execution数据</span></span><br><span class="line">res = loginreqsession.get(kb_url, verify=<span class="keyword">False</span>)</span><br><span class="line">content = res.content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">cookie = res.cookies</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过正则表达式从登录页面中提取相关信息</span></span><br><span class="line">it = getItInfo(content)</span><br><span class="line">execution = getExecutionInfo(content)</span><br><span class="line">eventId = getEventIdInfo(content)</span><br><span class="line">print(<span class="string">'%s %s %s'</span> % (it, execution, eventId))</span><br><span class="line">loginData = getLoginInfo(it, execution, eventId)</span><br><span class="line">print(loginData)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Post请求获取SSO分配的Ticket</span></span><br><span class="line">res = loginreqsession.post(kb_url, headers=getLoginHeader(cookie[<span class="string">'JSESSIONID'</span>]), data=loginData, cookies=cookie,</span><br><span class="line">                           allow_redirects=<span class="keyword">False</span>, verify=<span class="keyword">False</span>)</span><br><span class="line">cookie = res.cookies</span><br><span class="line">location = res.headers[<span class="string">'Location'</span>]</span><br><span class="line">print(location)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Ticket发送Get请求获取cookies</span></span><br><span class="line">res = loginreqsession.get(location, allow_redirects=<span class="keyword">False</span>, verify=<span class="keyword">False</span>)</span><br><span class="line">cookie = res.cookies</span><br><span class="line">print(cookie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用cookies请求页面信息</span></span><br><span class="line">str = <span class="string">'&lt;url&gt;'</span></span><br><span class="line">content = requests.get(str, cookies=cookie, verify=<span class="keyword">False</span>).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在对整个登录流程做个总结：</p><ol><li>Get请求获取登陆使用Lt和execution数据</li><li>Post请求获取SSO分配的Ticket</li><li>通过Ticket发送Get请求获取SSO的cookie</li><li>通过SSO Cookie获取页面信息</li></ol><p>要注意的地方上面也提到过，就是：每次请求时都需要带上上次返回的Cookie，否则就会被不停的重定向到登录页面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近打算使用Python实现自动抓取&lt;a href=&quot;https://www.atlassian.com/software/confluen
      
    
    </summary>
    
      <category term="Python实践" scheme="http://yunlinos.com/categories/Python%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Python" scheme="http://yunlinos.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Android触摸事件模拟</title>
    <link href="http://yunlinos.com/archives/8b308b7c.html"/>
    <id>http://yunlinos.com/archives/8b308b7c.html</id>
    <published>2018-08-10T01:40:36.000Z</published>
    <updated>2018-09-06T12:39:40.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用monkey进行压力测试时，我们发现，随机的触摸事件中大约有95%的无效事件，达到深层页面的概率极低，每晚压测的实际有效时间其实只有半小时，且缺少相互依赖的路径，完全无法满足压力测试的需求。而存粹依靠人工测试则效率过低，所以我们会想，能否有一种方式，可以将我们的测试过程录制下来，然后在更多的机器上面循环回放，还能对操作进行加速和减速，并且实时跟踪崩溃数据和性能数据，起到效率更高的压测效果，即<code>Copy once, paste anywhere</code>。在知道<a href="http://yunlinos.com/archives/9f4ea589.html" title="触摸事件原理">触摸事件原理</a>后，我们就开始做这件很Cool的事情，而本文就介绍了整个预研和摸索的过程。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们现在先梳理下我们需要实现的功能，即过程大概如下：</p><ol><li>将触摸事件记录在文本中</li><li>记录相邻事件的时间间隔</li><li>读取文本信息，解析成触摸事件和时间间隔</li><li>将触摸事件注入到系统中，并根据时间间隔进行延时注入</li></ol><p>说到触摸事件注入，那么我们是否有想到之前的这篇文章：<a href="http://yunlinos.com/archives/9f4ea589.html" title="Android触摸事件原理">Android触摸事件原理</a>。在那里介绍了Monkey中常用的两种事件注入方式，即：</p><ol><li><code>InputManager.getInstance().injectInputEvent</code></li><li><code>FileOutputStream(&quot;/dev/input/event0&quot;)</code></li></ol><p>现在，事件注入的方式有了，那么事件来源的方式呢，我们如何得到事件源和事件间隔？下面，我们将以这两种方式作为突破口来实现触摸的录制和回放。</p><h2 id="injectEvent"><a href="#injectEvent" class="headerlink" title="injectEvent"></a>injectEvent</h2><p>在前面的文章中，我们深入了解了injectEvent方法的执行流程，其实就是<code>InputDispatcher</code>对事件进行分发。优点是直接通过应用层去执行，且触摸事件不需要经过任何处理即可进行分发，速度极快，基本上没有任何延迟就可以响应，monkey中大量的随机事件就是用这种方式处理的。</p><p>但最大的问题是，我们如何获取到操作中的触摸事件信息，并保存成文本信息呢。如果仿照<code>monkeyscript</code>的实现方式，在脚本中自定义触摸事件，确实可以生成可用的数据，但是这种工作极其繁琐且效率较低，只能用于单个按钮点击或者短路径的测试场景，对于压力测试这种长时间、多应用的测试场景，就显得力不从心了。</p><p>因此，我们只能从系统的事件源中想办法，通过抓取系统产生的大量事件来生成事件源。想到的方法有两种：</p><ol><li>从getevent拿到数据，即通过监听<code>/dev/input/event*</code>节点来捕获系统input事件。但是这些事件需要通过较为复杂的转换才能在应用层进行注入，且还要处理多指、拖拽等场景，较为麻烦，故暂时不做考虑，如果没有更好的方案可以再回头来看。</li><li>在<code>InputManagerService</code>中通过Socked向上层发送需要分发的数据，这些数据不需要任何处理就能从应用层进行事件注入，但是这样对系统代码的侵入性太强，故也不考虑。</li></ol><p>那么，我们就来看其他方式。</p><h2 id="getevent"><a href="#getevent" class="headerlink" title="getevent"></a>getevent</h2><p>在monkey中，使用的第二种事件注入方式就是通过向设备节点<code>/dev/input/event*</code>中写入触摸数据，然后InputManager中的<code>EventHub</code>就能正常获取到该事件，再进行后续的事件分发。<br>不过，Android官方已经提供了现成的工具做这些工作，包括事件捕获和事件注入，即<code>getevent</code>和<code>sendevent</code>。我们先通过adb命令来看下getevent的用法（触摸事件在哪个设备节点需要先确认，我这台Android设备的触摸事件是在<code>event4</code>）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb shell getevent | grep event4</span><br><span class="line">add device 5: /dev/input/event4</span><br><span class="line">/dev/input/event4: 0003 0039 00000008</span><br><span class="line">/dev/input/event4: 0003 0035 00005cdf</span><br><span class="line">/dev/input/event4: 0003 0036 00003341</span><br><span class="line">/dev/input/event4: 0001 014a 00000001</span><br><span class="line">/dev/input/event4: 0003 0000 00005cdf</span><br><span class="line">/dev/input/event4: 0003 0001 00003341</span><br><span class="line">/dev/input/event4: 0000 0000 00000000</span><br></pre></td></tr></table></figure></p><p>关于<code>getevent</code>的相关参数我们可以详见官方文章：<a href="https://source.android.com/devices/input/getevent" title="https://source.android.com/devices/input/getevent" target="_blank" rel="noopener">https://source.android.com/devices/input/getevent</a><br>这样我们就能获取到系统中的所有的触摸事件，然后根据出现的时间来确定时间间隔，并将这些信息保存成文本中，<code>python</code>实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNeededEvent</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'/dev/input/event4'</span> <span class="keyword">in</span> event <span class="keyword">and</span> <span class="string">'add device'</span> <span class="keyword">not</span> <span class="keyword">in</span> event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCurrentMillisecondTime</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(round(time.time() * <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyInputEvent</span><span class="params">()</span>:</span></span><br><span class="line">    copyCmd = <span class="string">'adb -s %s shell getevent'</span> % deviceIp</span><br><span class="line">    outputStream = os.popen(copyCmd)._stream</span><br><span class="line">    eventSaveFile = open(<span class="string">'Event.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">    eventLine = outputStream.readline()</span><br><span class="line">    currentTime = getCurrentMillisecondTime()</span><br><span class="line">    <span class="keyword">while</span> eventLine:</span><br><span class="line">        <span class="keyword">if</span> isNeededEvent(eventLine):</span><br><span class="line">            intervalTime = getCurrentMillisecondTime() - currentTime</span><br><span class="line">            currentTime = getCurrentMillisecondTime()</span><br><span class="line">            eventStr = <span class="string">'%s#%s'</span> % (intervalTime, eventLine)</span><br><span class="line">            print(intervalTime, eventLine)</span><br><span class="line">            eventSaveFile.write(eventStr)</span><br><span class="line">        eventLine = outputStream.readline()</span><br></pre></td></tr></table></figure></p><p>最终，我们得到的文本内容为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1#/dev/input/event4: 0003 0035 000011a5</span><br><span class="line">0#/dev/input/event4: 0003 0036 00001753</span><br><span class="line">0#/dev/input/event4: 0001 014a 00000001</span><br><span class="line">0#/dev/input/event4: 0003 0000 000011a5</span><br><span class="line">0#/dev/input/event4: 0003 0001 00001753</span><br><span class="line">4#/dev/input/event4: 0000 0000 00000000</span><br><span class="line">20#/dev/input/event4: 0003 0035 000011ae</span><br><span class="line">0#/dev/input/event4: 0003 0036 000017a0</span><br><span class="line">0#/dev/input/event4: 0003 0000 000011ae</span><br><span class="line">0#/dev/input/event4: 0003 0001 000017a0</span><br><span class="line">0#/dev/input/event4: 0000 0000 00000000</span><br><span class="line">5#/dev/input/event4: 0003 0035 000011b9</span><br><span class="line">0#/dev/input/event4: 0003 0036 000017fc</span><br><span class="line">0#/dev/input/event4: 0003 0000 000011b9</span><br><span class="line">4#/dev/input/event4: 0003 0001 000017fc</span><br></pre></td></tr></table></figure></p><h2 id="sendevent"><a href="#sendevent" class="headerlink" title="sendevent"></a>sendevent</h2><p>在得到这些触摸的文本信息，我们就能通过<code>sendevent</code>方法来进行触摸事件注入了，而且能通过事件前面记录的时间间隔来确定延时时间，从而模拟出正常的操作。不过在这之前，我们需要先确认下面几点注意事项，即：</p><ol><li><code>getevent</code>得到的数值是16进制的，<code>sendevent</code>输入的参数是10进制的，注意进行转换</li><li><code>sendevent</code>中没有冒号，即<code>sendevent /dev/input/event4 3 57 579</code>这种方式</li><li>如果执行没有效果，尝试先修改文件权限，在su后调用<code>chmod 777 /dev/input/event[x]</code></li></ol><p>万事俱备，我们现在来撸出事件注入的代码，同样是<code>python实现</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCurrentMillisecondTime</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(round(time.time() * <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTranslatedEvent</span><span class="params">(eventContent)</span>:</span></span><br><span class="line">    event = eventContent.split(<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'%s %s %s %s'</span> % (event[<span class="number">0</span>], int(event[<span class="number">1</span>], <span class="number">16</span>), int(event[<span class="number">2</span>], <span class="number">16</span>), int(event[<span class="number">3</span>], <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pasteInutEvent</span><span class="params">()</span>:</span></span><br><span class="line">    eventSaveFile = open(<span class="string">'Event.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">    eventLines = eventSaveFile.readlines()</span><br><span class="line"></span><br><span class="line">    time3 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> eventLine <span class="keyword">in</span> eventLines:</span><br><span class="line">        eventLine = eventLine.strip(<span class="string">'\n'</span>)</span><br><span class="line">        eventInfo = eventLine.split(<span class="string">'#'</span>)</span><br><span class="line">        intervalTime = eventInfo[<span class="number">0</span>]</span><br><span class="line">        eventContent = eventInfo[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> intervalTime != <span class="string">'0'</span>:</span><br><span class="line">            time.sleep(int(intervalTime) / <span class="number">1000</span>)</span><br><span class="line">        time2 = getCurrentMillisecondTime()</span><br><span class="line">        translatedEvent = getTranslatedEvent(eventContent).replace(<span class="string">':'</span>, <span class="string">''</span>)</span><br><span class="line">        print(<span class="string">'+++%s'</span> % (time2 - time3))</span><br><span class="line">        pasteCmd = <span class="string">'adb -s %s shell sendevent '</span> % deviceIp</span><br><span class="line">        os.system(<span class="string">'%s %s'</span> % (pasteCmd, translatedEvent))</span><br><span class="line">        time3 = getCurrentMillisecondTime()</span><br><span class="line">        print(<span class="string">'---%s'</span> % (time3 - time2))</span><br></pre></td></tr></table></figure></p><p>到了这里，我们就是不是就已经完成了所有的事件录制和回放的功能呢？不，不是的。如果有执行上面这段代码，我们会发现，界面上确实正在回放我们刚刚的操作的路径，不过是以龟速在进行，大概录制一分钟的操作，可能需要十分钟才能执行完，这样的功能并不能满足我们的需要。</p><p>可是，我们确实是按照记录的时间间隔来进行延时处理的，那么问题到底在哪里呢？于是我们在代码中加入日志，打印了方法的执行时间，发现在实际事件注入的地方（<code>os.system(&#39;%s %s&#39; % (pasteCmd, translatedEvent))</code>）耗时较长，大概开销在70ms左右。而我们后面的努力就是要将这块的时间开销降到最低，否则这种方案没有任何实际使用价值。那么我们从<code>sendevent</code>的源码实现入手，源码位于<code>system/core/toolbox/sendevent.c</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendevent_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> fd;</span><br><span class="line">     <span class="keyword">ssize_t</span> ret;</span><br><span class="line">     <span class="keyword">int</span> version;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(argc != <span class="number">5</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"use: %s device type code value\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">     <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"could not open %s, %s\n"</span>, argv[optind], strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (ioctl(fd, EVIOCGVERSION, &amp;version)) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"could not get driver version for %s, %s\n"</span>, argv[optind], strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line">     event.type = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">     event.code = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">     event.value = atoi(argv[<span class="number">4</span>]);</span><br><span class="line">     ret = write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">     <span class="keyword">if</span>(ret &lt; (<span class="keyword">ssize_t</span>) <span class="keyword">sizeof</span>(event)) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"write event failed, %s\n"</span>, strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>代码比较简单，从中我们可以看出事件注入的流程就是：打开文件描述符（13行）、组装事件信息（22-25行）、写入事件信息（26行）、关闭文件描述符（进程关闭时）。而对应我们每一次通过<code>sendevent</code>进行的事件注入，就意味着重复打开关闭文件的操作，根据经验判断，这个过程是非常耗时的。所以我们可以尝试重写该源码来验证我们的判断：在打开文件描述符后，写入所有数据，再关闭文件描述符。</p><p>另外，我们的想法是，通过<code>python</code>脚本录制所有的操作后，直接将事件数据文本导入到Android设备中，然后运行相关服务就可以进行回放。故<code>jni</code>代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line">    __u16 type;</span><br><span class="line">    __u16 code;</span><br><span class="line">    __s32 value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_yunlinos_montioninject_EventInject_openInputSource(JNIEnv *env, jclass type) &#123;</span><br><span class="line">    __android_log_write(ANDROID_LOG_DEBUG, <span class="string">"InjectEvent"</span>, <span class="string">"openInputSource"</span>);</span><br><span class="line">    fd = open(<span class="string">"/dev/input/event4"</span>, O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_yunlinos_montioninject_EventInject_injectEvent(JNIEnv *env, jclass type,</span><br><span class="line">                                                        jstring eventType_, jstring eventCode_,</span><br><span class="line">                                                        jstring eventValue_) &#123;</span><br><span class="line">    __android_log_write(ANDROID_LOG_DEBUG, <span class="string">"InjectEvent"</span>, <span class="string">"injectEvent"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eventType = (*env)-&gt;GetStringUTFChars(env, eventType_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eventCode = (*env)-&gt;GetStringUTFChars(env, eventCode_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eventValue = (*env)-&gt;GetStringUTFChars(env, eventValue_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line"></span><br><span class="line">    event.code = atoi(eventCode);</span><br><span class="line">    event.type = atoi(eventType);</span><br><span class="line">    event.value = atoi(eventValue);</span><br><span class="line"></span><br><span class="line">    write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, eventType_, eventType);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, eventCode_, eventCode);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, eventValue_, eventValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_yunlinos_montioninject_EventInject_closeInputSource(JNIEnv *env, jclass type) &#123;</span><br><span class="line">    __android_log_write(ANDROID_LOG_DEBUG, <span class="string">"InjectEvent"</span>, <span class="string">"closeInputSource"</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而应用层Java代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">openInputSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">injectEvent</span><span class="params">(String eventType, String eventCode, String eventValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">closeInputSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFileEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"/sdcard/Event.txt"</span>));</span><br><span class="line">         InputStreamReader is = <span class="keyword">new</span> InputStreamReader(fis);</span><br><span class="line">         BufferedReader br = <span class="keyword">new</span> BufferedReader(is)) &#123;</span><br><span class="line"></span><br><span class="line">        String txtLine;</span><br><span class="line">        String[] allEvents;</span><br><span class="line">        String[] eventInfo;</span><br><span class="line">        String eventStr;</span><br><span class="line">        <span class="keyword">while</span> ((txtLine = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            InputEvent inputEvent = <span class="keyword">new</span> InputEvent();</span><br><span class="line">            allEvents = txtLine.split(<span class="string">"#"</span>);</span><br><span class="line">            inputEvent.time = Long.parseLong(allEvents[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            eventStr = allEvents[<span class="number">1</span>].replace(<span class="string">":"</span>, <span class="string">""</span>);</span><br><span class="line">            eventInfo = eventStr.split(<span class="string">" "</span>);</span><br><span class="line">            inputEvent.type = String.valueOf(Integer.parseInt(eventInfo[<span class="number">1</span>], <span class="number">16</span>));</span><br><span class="line">            inputEvent.code = String.valueOf(Integer.parseInt(eventInfo[<span class="number">2</span>], <span class="number">16</span>));</span><br><span class="line">            inputEvent.value = String.valueOf(Long.parseLong(eventInfo[<span class="number">3</span>], <span class="number">16</span>));</span><br><span class="line">            inputEvents.add(inputEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectEvent</span><span class="params">(List&lt;InputEvent&gt; inputEventList)</span> </span>&#123;</span><br><span class="line">    EventInject.openInputSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (InputEvent inputEvent : inputEventList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputEvent.time != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(inputEvent.time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        EventInject.injectEvent(inputEvent.type, inputEvent.code, inputEvent.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventInject.closeInputSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>readFileEvent</code>方法用于读取事件信息文本并解析为可使用的事件，<code>injectEvent</code>则是实际事件注入的地方。在运行后，发现能够完美解决我们现有的问题。不过，针对于实际应用场景，还有很多需要优化的点，比如：</p><ul><li>当录制时间过长时，一次性解析所有触摸信息并解析为对象肯定不可能，内存占用太多。可能这个时就候需要使用生产消费者队列了。</li><li>我们还可以配置部分参数，通过处理延时时间的方式，进行回放的加速和减速。</li><li>等等</li></ul><p>这些在这篇文章中就不过多赘述了，各位可以根据自己的业务需要来进行定制化处理。</p><h2 id="项目开源地址"><a href="#项目开源地址" class="headerlink" title="项目开源地址"></a>项目开源地址</h2><p>触摸录制：<a href="https://github.com/yunlinos/MotionCopy" title="https://github.com/yunlinos/MotionCopy" target="_blank" rel="noopener">https://github.com/yunlinos/MotionCopy</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://source.android.com/devices/input/getevent.html" title="http://source.android.com/devices/input/getevent.html" target="_blank" rel="noopener">http://source.android.com/devices/input/getevent.html</a><br><a href="http://source.android.com/devices/input/touch-devices.html" title="http://source.android.com/devices/input/touch-devices.html" target="_blank" rel="noopener">http://source.android.com/devices/input/touch-devices.html</a><br><a href="https://stackoverflow.com/questions/12079591/android-sendevent-is-really-slow-how-to-speed-it-up" title="https://stackoverflow.com/questions/12079591/android-sendevent-is-really-slow-how-to-speed-it-up" target="_blank" rel="noopener">https://stackoverflow.com/questions/12079591/android-sendevent-is-really-slow-how-to-speed-it-up</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用monkey进行压力测试时，我们发现，随机的触摸事件中大约有95%的无效事件，达到深层页面的概率极低，每晚压测的实际有效时间其实只有半
      
    
    </summary>
    
      <category term="Android源码解析" scheme="http://yunlinos.com/categories/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="触摸事件" scheme="http://yunlinos.com/tags/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="自动化测试" scheme="http://yunlinos.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android触摸事件分发--从InputManager到Window</title>
    <link href="http://yunlinos.com/archives/feabfdd.html"/>
    <id>http://yunlinos.com/archives/feabfdd.html</id>
    <published>2018-08-05T07:06:56.000Z</published>
    <updated>2018-09-06T12:39:29.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上篇文章<a href="http://yunlinos.com/archives/9f4ea589.html" title="Android触摸事件原理">Android触摸事件原理</a>中，我们知道了事件注入的原理，也了解了触摸事件的来源与去处。但是，仍然留了两个比较复杂的问题还没解决，那就是：</p><ol><li>将触摸事件发送给Window时，是如何在茫茫人海中确定眼神的？</li><li>他们相隔千山万水，又是如何将触摸事件交付给对方的？</li></ol><p>当然，涉及到跨进程通信，我们的第一反应肯定是Binder机制。毕竟Binder在Android中是使用最多的IPC手段，包括Activity启动、Service启动等等，是效率和安全的象征。那触摸事件的跨进程分发到底是不是使用Binder呢，我们继续往下看。</p><h2 id="如何为触摸事件找到Window"><a href="#如何为触摸事件找到Window" class="headerlink" title="如何为触摸事件找到Window"></a>如何为触摸事件找到Window</h2><p>让时间倒转，回到<code>dispatchMotionLocked</code>：<br>[-&gt; InputDispatcher.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchMotionLocked(</span><br><span class="line">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="comment">// Pointer event.  (eg. touchscreen)</span></span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Non touch event.  (eg. trackball)</span></span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续往下看，进入到<code>findFocusedWindowTargetsLocked</code>中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> InputDispatcher::findFocusedWindowTargetsLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    String8 reason;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前没有获取焦点的窗口或者应用，就丢弃该事件</span></span><br><span class="line">    <span class="keyword">if</span> (mFocusedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocusedApplicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    mFocusedApplicationHandle, <span class="literal">NULL</span>, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);</span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ALOGI(<span class="string">"Dropping event because there is no focused window or focused application."</span>);</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> (! checkInjectionPermission(mFocusedWindowHandle, entry-&gt;injectionState)) &#123;</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测窗口是否为更多的输入操作而准备就绪</span></span><br><span class="line">    reason = checkWindowReadyForMoreInputLocked(currentTime,</span><br><span class="line">            mFocusedWindowHandle, entry, <span class="string">"focused"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reason.isEmpty()) &#123;</span><br><span class="line">        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功找到目标窗口，添加到目标窗口</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    addWindowTargetLocked(mFocusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">Failed:</span><br><span class="line">Unresponsive:</span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatisticsLocked(currentTime, entry,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    ALOGD(<span class="string">"findFocusedWindow finished: injectionResult=%d, "</span></span><br><span class="line">            <span class="string">"timeSpentWaitingForApplication=%0.1fms"</span>,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication / <span class="number">1000000.0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以从代码中的注释看到，会经过权限检查、窗口焦点状态等条件判断。那么，此处的<code>mFocusedWindowHandle</code>又是在哪里赋值的呢？我们可以在InputDispatcher找到赋值的地方：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::setInputWindows(<span class="keyword">const</span> Vector&lt;sp&lt;InputWindowHandle&gt; &gt;&amp; inputWindowHandles) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    ALOGD(<span class="string">"setInputWindows"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Vector&lt;sp&lt;InputWindowHandle&gt; &gt; oldWindowHandles = mWindowHandles;</span><br><span class="line">        mWindowHandles = inputWindowHandles;</span><br><span class="line"></span><br><span class="line">        sp&lt;InputWindowHandle&gt; newFocusedWindowHandle;</span><br><span class="line">        <span class="keyword">bool</span> foundHoveredWindow = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mWindowHandles.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle = mWindowHandles.itemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!windowHandle-&gt;updateInfo() || windowHandle-&gt;getInputChannel() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mWindowHandles.removeAt(i--);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle-&gt;getInfo()-&gt;hasFocus) &#123;</span><br><span class="line">                newFocusedWindowHandle = windowHandle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle == mLastHoverWindowHandle) &#123;</span><br><span class="line">                foundHoveredWindow = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!foundHoveredWindow) &#123;</span><br><span class="line">            mLastHoverWindowHandle = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFocusedWindowHandle != newFocusedWindowHandle) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFocusedWindowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">                ALOGD(<span class="string">"Focus left window: %s"</span>,</span><br><span class="line">                        mFocusedWindowHandle-&gt;getName().<span class="built_in">string</span>());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                sp&lt;InputChannel&gt; focusedInputChannel = mFocusedWindowHandle-&gt;getInputChannel();</span><br><span class="line">                <span class="keyword">if</span> (focusedInputChannel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="function">CancelationOptions <span class="title">options</span><span class="params">(CancelationOptions::CANCEL_NON_POINTER_EVENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="string">"focus left window"</span>)</span></span>;</span><br><span class="line">                    synthesizeCancelationEventsForInputChannelLocked(</span><br><span class="line">                            focusedInputChannel, options);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newFocusedWindowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">                ALOGD(<span class="string">"Focus entered window: %s"</span>,</span><br><span class="line">                        newFocusedWindowHandle-&gt;getName().<span class="built_in">string</span>());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            mFocusedWindowHandle = newFocusedWindowHandle;</span><br><span class="line">        &#125;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>InputDispatcher::setInputWindows</code>中，可以看到这里会对mWindowHandles赋值，也有对mFocusedWindowHandle进行赋值，如果看过<code>findTouchedWindowTargetsLocked</code>，同样会发现也是基于对mWindowHandles的遍历找到目标窗口的。<br>那么谁会调用<code>setInputWindows</code>函数呢？具体可以看这篇文章<a href="http://gityuan.com/2016/12/24/input-ui/" title="Input系统—UI线程" target="_blank" rel="noopener">Input系统—UI线程</a>，其实就是在窗口进行创建和删除时进行更新。<br><img src="/archives/feabfdd/window添加流程图.png" alt="window添加流程图"></p><h2 id="如何将触摸式事件分发到Window"><a href="#如何将触摸式事件分发到Window" class="headerlink" title="如何将触摸式事件分发到Window"></a>如何将触摸式事件分发到Window</h2><p>在知道怎么找到目标Window后，最关键的问题就是如何将事件分发到该Window了。那么，到底是不是通过Binder呢？再次回到InputDispatcher中进行事件分发的地方，即<code>InputDispatcher::dispatchOnce</code>，一步步随着代码读下去，就会发现最终是通过Socket发送出去的：<br><img src="/archives/feabfdd/事件发送流程.png" alt="事件发送流程"><br>当然，关于Socket的创建我们可以在窗口建立时找到，即<code>WindowManagerService</code>中，更详细见参考资料：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建WindowState【见小节2.5.1】</span></span><br><span class="line">    WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span> &amp;&amp; (attrs.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//根据WindowState的HashCode以及title来生成InputChannel名称</span></span><br><span class="line">        String name = win.makeInputChannelName();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一对InputChannel[见小节2.6]</span></span><br><span class="line">        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">        <span class="comment">//将socket服务端保存到WindowState的mInputChannel</span></span><br><span class="line">        win.setInputChannel(inputChannels[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//socket客户端传递给outInputChannel [见小节2.7]</span></span><br><span class="line">        inputChannels[<span class="number">1</span>].transferTo(outInputChannel);</span><br><span class="line">        <span class="comment">//利用socket服务端作为参数[见小节2.8]</span></span><br><span class="line">        mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> focusChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (win.canReceiveKeys()) &#123;</span><br><span class="line">        <span class="comment">//新添加window能接收按下操作，则更新聚焦窗口。</span></span><br><span class="line">        focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">        mInputMonitor.setInputFocusLw(mCurrentFocus, <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置当前聚焦窗口【见小节2.5.2】</span></span><br><span class="line">    mInputMonitor.updateInputWindowsLw(<span class="keyword">false</span> <span class="comment">/*force*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从这两篇博客中，我们就弄清楚了整个触摸事件传递的过程，回到最开始的问题：</p><ol><li>将触摸事件发送给Window时，是如何在茫茫人海中确定眼神的？<strong>在Window创建时，会将相应的窗口信息同步更新到InputDispatcher中；然后在分发事件事件时，根据触摸事件的位置及窗口的属性来找到目标窗口。</strong></li><li>他们相隔千山万水，又是如何将触摸事件交付给对方的？<strong>通过Socket的通信方式，在窗口添加时进行创建Socket</strong></li></ol><p>借用<a href="http://gityuan.com/" title="gityuan" target="_blank" rel="noopener">gityuan</a>中图为：</p><p><img src="/archives/feabfdd/事件框架图.jpg" alt="事件框架图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://gityuan.com/2016/12/31/input-ipc/" title="Input系统—事件处理全过程" target="_blank" rel="noopener">Input系统—事件处理全过程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上篇文章&lt;a href=&quot;http://yunlinos.com/archives/9f4ea589.html&quot; title=&quot;Andro
      
    
    </summary>
    
      <category term="Android源码解析" scheme="http://yunlinos.com/categories/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="触摸事件" scheme="http://yunlinos.com/tags/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android触摸事件原理</title>
    <link href="http://yunlinos.com/archives/9f4ea589.html"/>
    <id>http://yunlinos.com/archives/9f4ea589.html</id>
    <published>2018-08-04T02:40:02.000Z</published>
    <updated>2018-09-06T12:39:35.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上篇文章<a href="http://yunlinos.com/archives/ff7c0d4a.html" title="Android Monkey源码解析">Android Monkey源码解析</a>中，我们学习了Monkey的基本用法，也知道了完整的执行流程。在大多数情况下，我们只需要一行代码即可完成最终的系统事件注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!InputManager.getInstance().injectInputEvent(keyEvent,</span><br><span class="line">        InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br></pre></td></tr></table></figure></p><p>当然，如果你阅读源码较为细心，也会发现<code>MonkeyFlipEvent</code>是用了另外一种方式进行事件注入，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">injectEvent</span><span class="params">(IWindowManager iwm, IActivityManager iam, <span class="keyword">int</span> verbose)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verbose &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">":Sending Flip keyboardOpen="</span> + mKeyboardOpen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject flip event</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"/dev/input/event0"</span>);</span><br><span class="line">        f.write(mKeyboardOpen ? FLIP_0 : FLIP_1);</span><br><span class="line">        f.close();</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Got IOException performing flip"</span> + e);</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，这两种方式又是如何将事件注入到系统中呢？再延伸下，Android系统中，触摸事件的来源是什么？又是如何传递到View上？在View中又是如何进行事件分发呢？</p><p>在下面的内容里，我们将从源码中一一找到答案。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>相关源码位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/</span><br><span class="line">- SystemServer.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/java/com/android/server/input/</span><br><span class="line">- InputManagerService.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/jni/</span><br><span class="line">- com_android_server_input_InputManagerService.cpp</span><br><span class="line"></span><br><span class="line">frameworks/<span class="keyword">native</span>/services/inputflinger/</span><br><span class="line">- EventHub.cpp</span><br><span class="line">- InputManager.cpp</span><br><span class="line">- InputReader.cpp</span><br><span class="line">- InputDispatcher.cpp</span><br></pre></td></tr></table></figure></p><p>先初步看下Android系统的触摸事件流程图，然后再分解整个流程进行剖析<br><img src="/archives/9f4ea589/触摸流程图.png" alt="触摸流程图"></p><p>将会从以下几个阶段来分析触摸事件的来源与去处：</p><ol><li>捕获触摸事件：对应流程图2-3</li><li>派发触摸事件：对应流程图4</li><li>触摸事件分发：对应流程图5-6</li></ol><h2 id="捕获触摸事件"><a href="#捕获触摸事件" class="headerlink" title="捕获触摸事件"></a>捕获触摸事件</h2><p>说到触摸事件，不得不提到InputManagerService，这是一个系统服务，主要用于处理各种输入事件，包括鼠标、键盘等。该服务在SystemServer进程启动的时候实例化，并注册到ServiceManager中去。<br>[-&gt; SystemServer.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">···</span><br><span class="line">wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">        mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">        !mFirstBoot, mOnlyCore, <span class="keyword">new</span> PhoneWindowManager());</span><br><span class="line">ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>在SystemServer的<code>startOtherServices</code>方法，会发现InputManagerService和WindowManagerService分别进行实例化，且WindowManagerService持有InputManagerService的引用，并注册到ServiceManager中。<br>我们回到InputManagerService中，在该服务的初始化过程中，会发现两个Native方法。<br>[-&gt; InputManagerService.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">(InputManagerService service,</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, MessageQueue messageQueue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure></p><p>根据这两个方法，我们找到对应的JNI方法，即：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == NULL) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    status_t result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过调用流程，会发现跟<code>NativeInputManager</code>相关，此时，我们来看看该类在初始化的过程中做了哪些事情：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="keyword">true</span>) &#123;</span><br><span class="line">···</span><br><span class="line">    sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line">    mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先实例化了EventHub和InputManager，且InputManager会持有EventHub的引用。那么，这两个都是些什么东西呢？首先我们进入EventHub去看看<br>[-&gt; EventHub.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 创建epoll对象，mEpollFd为epoll对象的描述符</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建inotify对象，mINotifyFd为inotify对象的描述符</span></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="comment">// DEVICE_PATH值为"/dev/input"，监听该目录下的设备节点创建与删除操作。通过read函数读取事件</span></span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"Could not register INotify for %s.  errno=%d"</span>,</span><br><span class="line">            DEVICE_PATH, errno);</span><br><span class="line"></span><br><span class="line">    struct epoll_event eventItem;</span><br><span class="line">    memset(&amp;eventItem, <span class="number">0</span>, sizeof(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;    <span class="comment">//监听可读事件</span></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    <span class="comment">// EPOLL_CTL_ADD表示增加事件</span></span><br><span class="line">    <span class="comment">// epoll_ctl将事件监听添加到epoll对象中去</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add INotify to epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major, minor;</span><br><span class="line">    getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line">    <span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">    mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来对于设备事件的监听，即监听<code>/dev/input/event*</code>的节点，主要依靠EventHub，利用Linux的inotify和epoll机制来获取Input事件。关于该部分的详解，可细读该部分的代码，这里不多赘述（关于EventHub和getEvent就不继续往下看了，知道这个深度对于非Framework工程师已经足够）。<br>了解到EventHub的主要功能，我们可以猜测出，InputManager持有其引用，应该是不断的读取设备的事件，并对上层进行分发消费。带着这份猜测，我们继续来看InputManager的代码。<br>[-&gt; InputManager.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">    <span class="comment">// 事件分发执行类</span></span><br><span class="line">    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">    <span class="comment">// 事件获取执行类</span></span><br><span class="line">    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) :</span><br><span class="line">        mReader(reader),</span><br><span class="line">        mDispatcher(dispatcher) &#123;</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputManager::~InputManager() &#123;</span><br><span class="line">    stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">    <span class="comment">// 事件获取线程</span></span><br><span class="line">    mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">    <span class="comment">// 事件分发线程</span></span><br><span class="line">    mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">        int32_t oldGeneration;</span><br><span class="line">        int32_t timeoutMillis;</span><br><span class="line">        bool inputDevicesChanged = <span class="keyword">false</span>;</span><br><span class="line">        Vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">// 监听事件</span></span><br><span class="line">        size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">       <span class="comment">// 处理事件</span></span><br><span class="line">         processEventsLocked(mEventBuffer, count);</span><br><span class="line">       ···</span><br><span class="line">       <span class="comment">// 派发事件</span></span><br><span class="line">        mQueuedListener-&gt;flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>确实印证了我们之前的猜测，这里用到了生产消费者模型，即一条线程不断读取设备事件，另外一条线程不断分发该事件。且事件读取线程用到了epoll机制，避免的性能的损耗。InputReader不断的通过EventHub获取到Input事件，经过<code>processEventsLocked</code>进行简单的封装，再通过<code>mQueuedListener-&gt;flush()</code>进行事件的派发。<br>到这里，捕获触摸事件的流程我们弄清楚里，总结如下：<br><img src="/archives/9f4ea589/捕获触摸事件.png" alt="捕获触摸事件"></p><h2 id="派发触摸事件"><a href="#派发触摸事件" class="headerlink" title="派发触摸事件"></a>派发触摸事件</h2><p>以上，我们知道了触摸事件的来源；现在，我们来关注触摸事件的去处。<br>[-&gt; InputManager.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有挂起的命令，运行分派循环。</span></span><br><span class="line">        <span class="comment">// 分派循环可能会将命令编入队列，以便随后运行。</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行所有存在的挂起的命令。</span></span><br><span class="line">        <span class="comment">// 如果有任何命令运行，则强制下一个轮询立即唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里主要是消息处理模型，如果有input事件的话则被唤醒处理事件，如果没有的话继续睡眠等待。我们主要关注<code>dispatchOnceInnerLocked(&amp;nextWakeupTime)</code>方法，该方法内会对事件类型进行判断并执行不同的处理方法，包括<code>EventEntry::TYPE_KEY</code>、<code>EventEntry::TYPE_MOTION</code>等等，我们只关注触摸事件的处理方式，即。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">        ···</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        ···</span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchMotionLocked(</span><br><span class="line">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ···    </span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">bool</span> conflictingPointerActions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">    <span class="comment">// 找到目标Window</span></span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//  派发</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由以上代码可以看出，对于触摸事件会首先通过<code>findTouchedWindowTargetsLocked</code>找到目标Window，进而通过dispatchEventLocked将消息发送到目标窗口。关于如何找到对应的Window，如何将派发给对应的Window，过程较为复杂，而我们此次仅关注整体流程，故在下篇博客中阐述。</p><h2 id="触摸事件分发"><a href="#触摸事件分发" class="headerlink" title="触摸事件分发"></a>触摸事件分发</h2><p>当触摸事件到达View中时，就涉及到应用端的事件分发机制了。该部分没必要另起介绍了，推荐两个比较优秀的文章：</p><ul><li><a href="http://www.monkeyliu.com/blog/2016/06/17/touchevent/" title="Android触摸事件分发机制" target="_blank" rel="noopener">Android触摸事件分发机制</a></li><li><a href="https://blog.csdn.net/guolin_blog/article/details/9097463" title="Android事件分发机制完全解析" target="_blank" rel="noopener">Android事件分发机制完全解析</a></li></ul><h2 id="解疑"><a href="#解疑" class="headerlink" title="解疑"></a>解疑</h2><p>让我们再次回到文章开始的疑问：</p><ol><li>触摸事件的来源是什么？<strong>InputReader通过EventHub获取到Input事件，并通过InputDispatcher 发出事件通知。</strong></li><li>又是如何传递到View上？<strong>在InputDispatcher找到对应的Window，并将事件发送到Window中。</strong></li><li>在View中又是如何进行事件分发呢？<strong>详见上面推荐的两篇博客。</strong></li></ol><p>最后一个问题，<code>InputManager.getInstance().injectInputEvent</code>又是如何进行事件注入的了。让我们从源码中来找到答案：<br>[-&gt; InputManagerService.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span> <span class="comment">// Binder call</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">injectInputEvent</span><span class="params">(InputEvent event, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> injectInputEventInternal(event, Display.DEFAULT_DISPLAY, mode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">injectInputEventInternal</span><span class="params">(InputEvent event, <span class="keyword">int</span> displayId, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"event must not be null"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mode != InputManager.INJECT_INPUT_EVENT_MODE_ASYNC</span><br><span class="line">              &amp;&amp; mode != InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH</span><br><span class="line">              &amp;&amp; mode != InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mode is invalid"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> pid = Binder.getCallingPid();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> uid = Binder.getCallingUid();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          result = nativeInjectInputEvent(mPtr, event, displayId, pid, uid, mode,</span><br><span class="line">                  INJECTION_TIMEOUT_MILLIS, WindowManagerPolicy.FLAG_DISABLE_KEY_REPEAT);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          Binder.restoreCallingIdentity(ident);</span><br><span class="line">      &#125;</span><br><span class="line">···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>应用通过Binder调用到InputManagerService中的方法，并且调用到Native方法<code>nativeInjectInputEvent</code>，让我们再次跟随源码的脚本进入<code>com_android_server_input_InputManagerService.cpp</code>到中：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeInjectInputEvent</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jobject inputEventObj, jint displayId, jint injectorPid, jint injectorUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint syncMode, jint timeoutMillis, jint policyFlags)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsInstanceOf(inputEventObj, gKeyEventClassInfo.clazz)) &#123;</span><br><span class="line">        KeyEvent keyEvent;</span><br><span class="line">        <span class="keyword">status_t</span> status = android_view_KeyEvent_toNative(env, inputEventObj, &amp; keyEvent);</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            jniThrowRuntimeException(env, <span class="string">"Could not read contents of KeyEvent object."</span>);</span><br><span class="line">            <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (jint) im-&gt;getInputManager()-&gt;getDispatcher()-&gt;injectInputEvent(</span><br><span class="line">                &amp; keyEvent, displayId, injectorPid, injectorUid, syncMode, timeoutMillis,</span><br><span class="line">                <span class="keyword">uint32_t</span>(policyFlags));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env-&gt;IsInstanceOf(inputEventObj, gMotionEventClassInfo.clazz)) &#123;</span><br><span class="line">        <span class="keyword">const</span> MotionEvent* motionEvent = android_view_MotionEvent_getNativePtr(env, inputEventObj);</span><br><span class="line">        <span class="keyword">if</span> (!motionEvent) &#123;</span><br><span class="line">            jniThrowRuntimeException(env, <span class="string">"Could not read contents of MotionEvent object."</span>);</span><br><span class="line">            <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (jint) im-&gt;getInputManager()-&gt;getDispatcher()-&gt;injectInputEvent(</span><br><span class="line">                motionEvent, displayId, injectorPid, injectorUid, syncMode, timeoutMillis,</span><br><span class="line">                <span class="keyword">uint32_t</span>(policyFlags));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Invalid input event type."</span>);</span><br><span class="line">        <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里，惊不惊喜，意不意外，其实并没有什么精妙或者牛逼的处理方式，就是直接获取到InputDispatcher对事件进行分发。殊途同归，最终还是回到了最开始的地方。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我们来总结下整个触摸事件的流程：</p><ol><li>InputManagerService在SystemServer中初始化，并向ServiceManager进行注册</li><li>初始化过程中生成InputManager和EventHub实例，InputManager持有EventHub的引用</li><li>InputManager实例化InputReader和InputDispatcher</li><li>InputReader通过EventHub监听Input事件</li><li>InputDispatcher进行事件的派发，即先找到对应的Window，并将Input事件传到该Window</li><li>Input事件传到应用，进入到View的事件分发，通过<code>dispatchTouchEven</code>、<code>onInterceptTouchEvent</code>等方法进行选择性分发</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://source.android.com/devices/input/touch-devices" title="Android触摸设备" target="_blank" rel="noopener">Android触摸设备</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上篇文章&lt;a href=&quot;http://yunlinos.com/archives/ff7c0d4a.html&quot; title=&quot;Andro
      
    
    </summary>
    
      <category term="Android源码解析" scheme="http://yunlinos.com/categories/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="触摸事件" scheme="http://yunlinos.com/tags/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android Monkey源码解析</title>
    <link href="http://yunlinos.com/archives/ff7c0d4a.html"/>
    <id>http://yunlinos.com/archives/ff7c0d4a.html</id>
    <published>2018-08-03T06:57:41.000Z</published>
    <updated>2018-09-06T12:39:00.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间在梳理公司的自动化测试脚本时，发现Monkey是个挺有意思的工具，它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试，这个倒很像一个梗<code>π里面藏着一部莎士比亚</code>。比较好奇它的实现原理，于是就有了研究源码的想法，说干就干，Read the Fucking Source Code。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>先将源码从系统中导出，我手头的AOSP是Android 5.1</p><ul><li>Monkey程序由Android系统自带，使用Java语言开发。在Android文件系统中的存放位置为：<code>/system/framework/monkey.jar</code>。在源码中的位置为<code>/development/cmds/monkey</code></li><li>Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本位于Android文件系统中：<code>/system/bin/monkey</code>。在源码中的位置为<code>development/cmds/monkey/monkey</code></li></ul><p>下面，就将开始Monkey的源码阅读之旅。</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>Monkey是由system/bin/monkey脚本启动system/framework/monkey.jar。下面是monkey脚本的内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Script to start "monkey" on the device, which has a very rudimentary</span><br><span class="line"><span class="meta">#</span> shell.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">base=/system</span><br><span class="line"><span class="meta">#</span> 设置monkey的CLASSPATH环境变量指向monkey.jar</span><br><span class="line">export CLASSPATH=$base/framework/monkey.jar</span><br><span class="line">trap "" HUP</span><br><span class="line"><span class="meta">#</span> 通过app_process指定monkey的入口和传进来的所有参数启动上面CLASSPATH设定的monkey.jar</span><br><span class="line">exec app_process $base/bin com.android.commands.monkey.Monkey $*</span><br></pre></td></tr></table></figure></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>可以通过adb命令执行Monkey脚本<code>adb shell monkey -p com.android.settings 500</code>，其基本流程如下：</p><ul><li>解析命令行参数</li><li>根据命令行参数选择不同的事件输入源，也就是事件源是从网络过来还是通过内部随机产生</li><li>跳入runMonkeyCycle方法针对不同事件源获取并开始执行不同的事件</li></ul><ol><li><p>入口在main方法，代码位于com.android.commands.monkey.Monkey.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Command-line entry point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args The command-line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Set the process name showing in "ps" or "top"</span></span><br><span class="line">        Process.setArgV0(<span class="string">"com.android.commands.monkey"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> resultCode = (<span class="keyword">new</span> Monkey()).run(args);</span><br><span class="line">        System.exit(resultCode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>解析输入参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the command!</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args The command-line arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Returns a posix-style result code. 0 for no error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">···</span><br><span class="line">        <span class="keyword">if</span> (!processOptions()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>根据输入的参数选择不同的事件输入流</p></li></ol><ul><li>MonkeySourceScript：通过相应的规则编写monkey脚本来驱动monkey进行事件注入，为非随机事件</li><li>MonkeySourceRandomScript：随机内部事件源，由脚本来触发，为随机事件</li><li>MonkeySourceNetwork：由网络（比如MonkeyRunner）发送过来的事件</li><li>MonkeySourceRandom：由monkey内部产生的随机事件集<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mScriptFileNames != <span class="keyword">null</span> &amp;&amp; mScriptFileNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// script mode, ignore other options</span></span><br><span class="line">    mEventSource = <span class="keyword">new</span> MonkeySourceScript(mRandom, mScriptFileNames.get(<span class="number">0</span>), mThrottle,</span><br><span class="line">            mRandomizeThrottle, mProfileWaitTime, mDeviceSleepTime);</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line"></span><br><span class="line">    mCountEvents = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mScriptFileNames != <span class="keyword">null</span> &amp;&amp; mScriptFileNames.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mSetupFileName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceRandomScript(mSetupFileName,</span><br><span class="line">                mScriptFileNames, mThrottle, mRandomizeThrottle, mRandom,</span><br><span class="line">                mProfileWaitTime, mDeviceSleepTime, mRandomizeScript);</span><br><span class="line">        mCount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceRandomScript(mScriptFileNames,</span><br><span class="line">                mThrottle, mRandomizeThrottle, mRandom,</span><br><span class="line">                mProfileWaitTime, mDeviceSleepTime, mRandomizeScript);</span><br><span class="line">    &#125;</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line">    mCountEvents = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mServerPort != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceNetwork(mServerPort);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Error binding to network socket."</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mCount = Integer.MAX_VALUE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// random source by default</span></span><br><span class="line">    <span class="keyword">if</span> (mVerbose &gt;= <span class="number">2</span>) &#123; <span class="comment">// check seeding performance</span></span><br><span class="line">        System.out.println(<span class="string">"// Seeded: "</span> + mSeed);</span><br><span class="line">    &#125;</span><br><span class="line">    mEventSource = <span class="keyword">new</span> MonkeySourceRandom(mRandom, mMainApps, mThrottle, mRandomizeThrottle);</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line">    <span class="comment">// set any of the factors that has been set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MonkeySourceRandom.FACTORZ_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactors[i] &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">            ((MonkeySourceRandom) mEventSource).setFactors(i, mFactors[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in random mode, we start with a random activity</span></span><br><span class="line">    ((MonkeySourceRandom) mEventSource).generateActivity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>循环执行事件<br>run方法根据参数从不同的事件源获得事件并放入到EventQueue后，就会开始执行一个循环去从EventQueue里获取事件进行执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">···</span><br><span class="line">        mNetworkMonitor.start();</span><br><span class="line">        <span class="keyword">int</span> crashedAtCycle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crashedAtCycle = runMonkeyCycles();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the rotation lock if it's still held and restore the</span></span><br><span class="line">            <span class="comment">// original orientation.</span></span><br><span class="line">            <span class="keyword">new</span> MonkeyRotationEvent(Surface.ROTATION_0, <span class="keyword">false</span>).injectEvent(</span><br><span class="line">                    mWm, mAm, mVerbose);</span><br><span class="line">        &#125;</span><br><span class="line">        mNetworkMonitor.stop();</span><br><span class="line">···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>runMonkeyCyles方法会根据不同的数据源开始一条条的获取事件并进行执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">MonkeyEvent ev = mEventSource.getNextEvent();</span><br><span class="line"><span class="keyword">if</span> (ev != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> injectCode = ev.injectEvent(mWm, mAm, mVerbose);</span><br><span class="line">    <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_FAIL) &#123;</span><br><span class="line">        System.out.println(<span class="string">"    // Injection Failed"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyKeyEvent) &#123;</span><br><span class="line">            mDroppedKeyEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyMotionEvent) &#123;</span><br><span class="line">            mDroppedPointerEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyFlipEvent) &#123;</span><br><span class="line">            mDroppedFlipEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyRotationEvent) &#123;</span><br><span class="line">            mDroppedRotationEvents++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_ERROR_REMOTE_EXCEPTION) &#123;</span><br><span class="line">        systemCrashed = <span class="keyword">true</span>;</span><br><span class="line">        System.err.println(<span class="string">"** Error: RemoteException while injecting event."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_ERROR_SECURITY_EXCEPTION) &#123;</span><br><span class="line">        systemCrashed = !mIgnoreSecurityExceptions;</span><br><span class="line">        <span class="keyword">if</span> (systemCrashed) &#123;</span><br><span class="line">            System.err.println(<span class="string">"** Error: SecurityException while injecting event."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't count throttling as an event.</span></span><br><span class="line">    <span class="keyword">if</span> (!(ev <span class="keyword">instanceof</span> MonkeyThrottleEvent)) &#123;</span><br><span class="line">        eventCounter++;</span><br><span class="line">        <span class="keyword">if</span> (mCountEvents) &#123;</span><br><span class="line">            cycleCounter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mCountEvents) &#123;</span><br><span class="line">        cycleCounter++;</span><br><span class="line">        writeScriptLog(cycleCounter);</span><br><span class="line">        <span class="comment">//Capture the bugreport after n iteration</span></span><br><span class="line">        <span class="keyword">if</span> (mGetPeriodicBugreport) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cycleCounter % mBugreportFrequency) == <span class="number">0</span>) &#123;</span><br><span class="line">                mRequestPeriodicBugreport = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Event Source has signaled that we have no more events to process</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行事件主要为与MonkeyEvent的injectEvent方法，例如MonkeykeyEvent事件的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">injectEvent</span><span class="params">(IWindowManager iwm, IActivityManager iam, <span class="keyword">int</span> verbose)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verbose &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        String note;</span><br><span class="line">        <span class="keyword">if</span> (mAction == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">            note = <span class="string">"ACTION_UP"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            note = <span class="string">"ACTION_DOWN"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">":Sending Key ("</span> + note + <span class="string">"): "</span></span><br><span class="line">                    + mKeyCode + <span class="string">"    // "</span></span><br><span class="line">                    + MonkeySourceRandom.getKeyName(mKeyCode));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">":Sending Key ("</span> + note + <span class="string">"): "</span></span><br><span class="line">                    + mKeyCode + <span class="string">"    // Unknown key event"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyEvent keyEvent = mKeyEvent;</span><br><span class="line">    <span class="keyword">if</span> (keyEvent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> eventTime = mEventTime;</span><br><span class="line">        <span class="keyword">if</span> (eventTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            eventTime = SystemClock.uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> downTime = mDownTime;</span><br><span class="line">        <span class="keyword">if</span> (downTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            downTime = eventTime;</span><br><span class="line">        &#125;</span><br><span class="line">        keyEvent = <span class="keyword">new</span> KeyEvent(downTime, eventTime, mAction, mKeyCode,</span><br><span class="line">                mRepeatCount, mMetaState, mDeviceId, mScanCode,</span><br><span class="line">                KeyEvent.FLAG_FROM_SYSTEM, InputDevice.SOURCE_KEYBOARD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!InputManager.getInstance().injectInputEvent(keyEvent,</span><br><span class="line">            InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上，基本就完成了整个事件注入的流程</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Monkey的软件架构图：<br><img src="/archives/ff7c0d4a/Monkey结构图.png" alt="你想输入的替代文字"></p><p>Monkey的工作原理图：<br><img src="/archives/ff7c0d4a/自动化测试架构图.png" alt="Monkey的工作原理图"></p><p>再次总结下其工作流程如下：</p><ol><li>由<code>system/bin/monkey</code>启动Monkey进程</li><li>解析命令行参数</li><li>根据输入的参数选择不同的事件输入流：是从网络过来还是通过内部随机产生</li><li>跳入runMonkeyCycle方法针对不同事件源获取事件</li><li>向系统注入事件</li></ol><p>另外，关于如何向Android中进行事件注入，将在下篇博客中展现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间在梳理公司的自动化测试脚本时，发现Monkey是个挺有意思的工具，它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等
      
    
    </summary>
    
      <category term="Android源码解析" scheme="http://yunlinos.com/categories/Android%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="自动化测试" scheme="http://yunlinos.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Monkey" scheme="http://yunlinos.com/tags/Monkey/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yunlinos.com/archives/4a17b156.html"/>
    <id>http://yunlinos.com/archives/4a17b156.html</id>
    <published>2018-08-01T12:23:53.033Z</published>
    <updated>2018-08-04T01:09:04.963Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到YunLin的博客，本博客基于<a href="https://github.com/" title="Github" target="_blank" rel="noopener">Github</a>和<a href="https://hexo.io/zh-cn/" title="Hexo" target="_blank" rel="noopener">Hexo</a>搭建，使用<a href="https://github.com/iissnan/hexo-theme-next" title="NexT.Mist" target="_blank" rel="noopener">NexT.Mist</a>主题。在阿里云购买的域名，分别为<a href="http://yunlinos.com/" title="www.yunlinos.com">www.yunlinos.com</a>和<a href="http://yunlinos.cn/" title="www.yunlinos.cn" target="_blank" rel="noopener">www.yunlinos.cn</a>。</p><p>在这里，坚决减少记录性内容，避免环境的简单搭建；多些源码的解读、架构的思考、底层的原理，确保内容高质量。</p><p>现阶段内容包括不限于：</p><ul><li>开源项目的源码解读，偏向于设计思想和优秀的代码实现</li><li>Android源码的实现，偏向于功能的原理性解读</li><li>深耕计算机网络、Java虚拟机方面</li></ul><p>当然，最重要的还是坚持，让更多的人得到帮助，也让自己的成长滴水成河。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到YunLin的博客，本博客基于&lt;a href=&quot;https://github.com/&quot; title=&quot;Github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;和&lt;a href=&quot;https://hexo.io/zh-cn/
      
    
    </summary>
    
      <category term="个人思考总结" scheme="http://yunlinos.com/categories/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yunlinos.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
