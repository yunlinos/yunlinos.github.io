<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YunLinOS Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yunlinos.com/"/>
  <updated>2018-08-23T01:12:22.404Z</updated>
  <id>http://yunlinos.com/</id>
  
  <author>
    <name>YunLinOS</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EventBus源码解析</title>
    <link href="http://yunlinos.com/archives/11ada9d0.html"/>
    <id>http://yunlinos.com/archives/11ada9d0.html</id>
    <published>2018-08-23T00:13:59.000Z</published>
    <updated>2018-08-23T01:12:22.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/greenrobot/EventBus" title="EventBus" target="_blank" rel="noopener">EventBus</a>是一款在 Android 和 Java 中使用的发布/订阅事件总线框架。因其体积小、效率高、使用简单而深受开发者喜爱。原理图为：<br><img src="/archives/11ada9d0/EventBus.png" alt="EventBus"></p><p>本文将从 EventBus 使用方法入手，来分析背后的实现原理。其核心方法包括：</p><ol><li>事件注册 <code>EventBus.getDefault().register(this);</code></li><li>取消注册 <code>EventBus.getDefault().unregister(this);</code></li><li>事件发布 <code>EventBus.getDefault().post(new MessageEvent());</code></li></ol><p>看起来特别简单，三行代码就能搞定我们需要的进程内通信。但其实<code>EventBus</code>在背后帮我们做了大量的工作，用了很多优雅的设计模式、代码优化来保证执行效率和可维护性。现在我们就掀开面纱来一探究竟。</p><h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2><p>事件注册的核心方法为 <code>EventBus.getDefault().register(this);</code><br>先看下<code>EventBus.getDefault()</code>的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Convenience singleton for apps using a process-wide EventBus instance. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventBus instance = defaultInstance;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">            instance = EventBus.defaultInstance;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = EventBus.defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBusBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</span></span><br><span class="line"><span class="comment"> * central bus, consider &#123;<span class="doctag">@link</span> #getDefault()&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    logger = builder.getLogger();</span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">    mainThreadPoster = mainThreadSupport != <span class="keyword">null</span> ? mainThreadSupport.createPoster(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">    asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，<code>getDefault</code>是一个单例方法，保证当前只有一个<code>EventBus</code>实例。而<code>EventBus</code>相关属性的初始化则使用了构造者模式，通过传入一个默认配置来完成，即<code>DEFAULT_BUILDER</code>。这样做的好处是对外屏蔽了大量的代码细节，大多数情况下通过默认配置即可完成进程间的通信，根本不需要关心其内部实现。而如果有特殊场景需要自定义属性，则可以通过配置<code>EventBusBuilder</code>来更改<code>EventBus</code>的属性，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder()</span><br><span class="line">        .eventInheritance(<span class="keyword">false</span>)</span><br><span class="line">        .build()</span><br><span class="line">        .register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>我们再来看看<code>register(this)</code>做了些什么。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到当前注册类的class对象</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    <span class="comment">// 根据class对象查找当前类中订阅事件集合，即使用了Subscribe注解、有public修饰符、一个参数的方法</span></span><br><span class="line">    <span class="comment">// SubscriberMethod类主要封装了符合条件方法的相关信息：</span></span><br><span class="line">    <span class="comment">// Method对象、线程模式、事件类型、优先级、是否是粘性事等</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面代码中可以看出，<code>register(this)</code>主要做了两件事，即事件方法的查找、事件方法的注册。我们先来看下查找的过程，从<code>findSubscriberMethods</code>开始：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// METHOD_CACHE是一个ConcurrentHashMap，缓存了subscriberClass和对应SubscriberMethod的集合，以提高注册效率，避免重复查找</span></span><br><span class="line">    <span class="comment">// 如果缓存中能找到，则直接返回相关信息</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在缓存中无法找到，则做进一步查找</span></span><br><span class="line">    <span class="comment">// 由于使用了默认的EventBusBuilder，则ignoreGeneratedIndex属性默认为false，即是否忽略注解生成器</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">        <span class="comment">// 直接使用反射进行方法查找</span></span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用索引进行方法查找</span></span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果对应类中没有符合条件的方法，则抛出异常。否则将这些方法放入到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的注释中我们可以看出流程：先从缓存中查找，如果找到则直接返回，否则就继续进行查找，查找方法为反射和索引（使用默认构造器，则使用<code>findUsingInfo</code>进行方法查找）。如果查找到的方法集合为空，则抛出异常，否则就进行缓存。现在我们进入到<code>findUsingInfo</code>方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用对象池来获取查找工具对象，并初始化注册类的Class对象</span></span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用索引类来查找订阅事件的方法，默认不生成索引类</span></span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射来查找订阅事件的方法</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改findState.clazz为subscriberClass的父类Class，即需要遍历父类</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找到的方法保存在了FindState实例的subscriberMethods集合中。</span></span><br><span class="line">    <span class="comment">// 使用subscriberMethods构建一个新的List&lt;SubscriberMethod&gt;</span></span><br><span class="line">    <span class="comment">// 释放掉findState</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br></pre></td></tr></table></figure></p><p><code>findUsingInfo()</code>方法会在当前要注册的类以及其父类中查找订阅事件的方法，这里出现了一个FindState类，它是<code>SubscriberMethodFinder</code>的内部类，用来辅助查找订阅事件的方法。会默认通过索引来进行方法的查找，默认该索引为空（使用索引来查找，能极大节省反射带来的性能损耗，不过我们先过完整个流程，再回过头来看索引的使用），故具体的查找过程在<code>findUsingReflectionInSingleClass()</code>方法，它主要通过反射查找订阅事件的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">        methods = findState.clazz.getMethods();</span><br><span class="line">        findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环遍历当前类的方法，筛选出符合条件的</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">// 获得方法的修饰符</span></span><br><span class="line">        <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">        <span class="comment">// 如果是public类型，但非abstract、static等</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="comment">// 如果当前方法只有一个参数</span></span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="comment">// 如果当前方法使用了Subscribe注解</span></span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// checkAdd()方法用来判断FindState的anyMethodByEventType map是否已经添加过以当前eventType为key的键值对，没添加过则返回true</span></span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        <span class="comment">// 得到Subscribe注解的threadMode属性值，即线程模式</span></span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        <span class="comment">// 创建一个SubscriberMethod对象，并添加到subscriberMethods集合</span></span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                        <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                    <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码中我们可以看到，在反射查找的过程中，会先遍历该类所有的方法，并验证该方法的参数、注解等信息，判断是否为所需要的事件订阅的方法，如果是的话就放入到集合中。现在，就让我们来看下标准事件的订阅方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEvent</span><span class="params">(MessageEvent event)</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>即在方法中会定义该方法的参数（即传入的<code>MessageEvent</code>），另外，会定义注解信息，包括线程等。关于注解这块，这里就不过解释了，后面会单独出一篇文章介绍工作中注解的使用。</p><p>此时方法查找的流程就分析完了，我们已经找到了当前注册类及其父类中订阅事件的方法的集合。接下来分析具体的注册流程，即<code>register()</code>中的<code>subscribe()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must be called in synchronized block</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    <span class="comment">// Subscription类保存了要注册的类对象以及当前的subscriberMethod</span></span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">    <span class="comment">// subscriptionsByEventType是一个HashMap，保存了以eventType为key,Subscription对象集合为value的键值对</span></span><br><span class="line">    <span class="comment">// 先查找subscriptionsByEventType是否存在以当前eventType为key的值</span></span><br><span class="line">    <span class="comment">// 即获取这个事件对应的订阅者列表</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果之前没有这个事件的订阅者，添加进去</span></span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果之前这个方法已经订阅过这个事件，再次订阅就报错</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历这个事件的订阅方法，调整它在订阅列表中的顺序，高优先级的放前面</span></span><br><span class="line">    <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// typesBySubscriber也是一个HashMap，保存了以当前要注册类的对象为key，注册类中订阅事件的方法的参数类型的集合为value的键值对</span></span><br><span class="line">    <span class="comment">// 查找是否存在对应的参数类型集合</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存当前订阅了事件的方法的参数类型</span></span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 粘性事件相关</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">            <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">            <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">            <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在注册流程中，主要是得到了<code>subscriptionsByEventType</code>、<code>typesBySubscriber</code>两个 HashMap，并且还会处理事件接收的优先级（调整<code>Subscription</code>在列表中的位置）、粘性事件分发（后面额外介绍）。在发送事件的时候要用到<code>subscriptionsByEventType</code>，完成事件的处理。当取消 EventBus 注册的时候要用到<code>typesBySubscriber</code>、<code>subscriptionsByEventType</code>，完成相关资源的释放。</p><p>注册流程为：<br><img src="/archives/11ada9d0/EventBusRegister.png" alt="EventBusRegister"></p><h2 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h2><p>取消注册的核心方法为：<code>EventBus.getDefault().unregister(this);</code><br>在解注册过程中，释放了<code>typesBySubscriber</code>、<code>subscriptionsByEventType</code>中缓存的资源。其核心内容如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到当前参数类型对应的Subscription集合</span></span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="comment">// 遍历Subscription集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            <span class="comment">// 如果当前subscription对象对应的注册类对象 和 要取消注册的注册类对象相同，则删除当前subscription对象</span></span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Unregisters the given subscriber from all event classes. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到当前注册类对象 对应的 订阅事件方法的参数类型 的集合</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除以subscriber（当前注册类对象）为key的键值对</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>取消注册流程为：<br><img src="/archives/11ada9d0/EventBusUnregister.png" alt="EventBusUnregister"></p><h2 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h2><p>事件发布的核心方法为：<code>EventBus.getDefault().post(new MessageEvent());</code><br>我们先进入<code>post</code>方法来看实际流程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Posts the given event to the event bus. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// currentPostingThreadState是一个PostingThreadState类型的ThreadLocal</span></span><br><span class="line">    <span class="comment">// PostingThreadState类保存了事件队列和线程模式等信息</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    <span class="comment">// 将要发送的事件添加到事件队列</span></span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isPosting默认为false</span></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        <span class="comment">// 是否为主线程</span></span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历事件队列</span></span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 发送单个事件</span></span><br><span class="line">                <span class="comment">// eventQueue.remove(0)，从事件队列移除事件</span></span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>post()</code>方法先将发送的事件保存的事件队列，然后通过循环出队列，将事件交给<code>postSingleEvent()</code>方法处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// eventInheritance默认为true，表示是否向上查找事件的父类</span></span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">// 查找当前事件类型的Class，连同当前事件类型的Class保存到集合</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="comment">// 遍历Class集合，继续处理事件</span></span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            logger.log(Level.FINE, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取事件类型对应的Subscription集合</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已订阅了对应类型的事件</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 事件分发处理</span></span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>postSingleEvent()</code>方法中，根据<code>eventInheritance</code>属性（默认为true），决定是否向上遍历事件的父类型，然后跟事件类型获取到对应的<code>Subscription</code>集合，遍历该集合进行事件的分发处理，即<code>postToSubscription</code>。我们继续进入该方法进行分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断订阅事件方法的线程模式</span></span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="comment">// 默认的线程模式</span></span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 在主线程处理事件</span></span><br><span class="line">        <span class="comment">// 如果在主线程发送事件，则直接在主线程通过反射处理事件</span></span><br><span class="line">        <span class="comment">// 如果是在子线程发送事件，则将事件入队列，通过Handler切换到主线程执行处理事件</span></span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 无论在那个线程发送事件，都先将事件入队列，然后通过 Handler 切换到主线程，依次处理事件</span></span><br><span class="line">        <span class="comment">// mainThreadPoster 不为空</span></span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果在主线程发送事件，则先将事件入队列，然后通过线程池依次处理事件</span></span><br><span class="line">        <span class="comment">// 如果在子线程发送事件，则直接在发送事件的线程通过反射处理事件</span></span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 无论在那个线程发送事件，都将事件入队列，然后通过线程池处理</span></span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>postToSubscription()</code>方法就是根据订阅事件方法的线程模式、以及发送事件的线程来判断如何处理事件，至于处理方式主要有两种：</p><ol><li>直接在该线程内进行反射执行</li><li>进行线程切换来执行该方法</li></ol><p>我们先来看第一种方式，即直接在相应线程直接通过<code>invokeSubscriber()</code>方法，用反射来执行订阅事件的方法，这样发送出去的事件就被订阅者接收并做相应处理了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再来看第二种方式，即通过线程切换来达到不同线程接收到事件的目的。实际代码处理如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用subscription和event封装一个PendingPost对象</span></span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 进入队列</span></span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">            handlerActive = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 发送开始处理事件的消息，handleMessage()方法将被执行，完成从子线程到主线程的切换</span></span><br><span class="line">            <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">// 死循环遍历队列</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 出队列</span></span><br><span class="line">            PendingPost pendingPost = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                    pendingPost = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进一步处理pendingPost</span></span><br><span class="line">            eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">            <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">            <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                rescheduled = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        handlerActive = rescheduled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions</span></span><br><span class="line"><span class="comment"> * between &#123;<span class="doctag">@link</span> #unregister(Object)&#125; and event delivery. Otherwise the event might be delivered after the</span></span><br><span class="line"><span class="comment"> * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the</span></span><br><span class="line"><span class="comment"> * live cycle of an Activity or Fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">    Object event = pendingPost.event;</span><br><span class="line">    Subscription subscription = pendingPost.subscription;</span><br><span class="line">    <span class="comment">// 释放pendingPost引用的资源</span></span><br><span class="line">    PendingPost.releasePendingPost(pendingPost);</span><br><span class="line">    <span class="keyword">if</span> (subscription.active) &#123;</span><br><span class="line">        <span class="comment">// 用反射来执行订阅事件的方法</span></span><br><span class="line">        invokeSubscriber(subscription, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方式的处理流程为：</p><ol><li>将subscription和event封装一个PendingPost对象，并放入队列</li><li>使用handleMessage()通知消息处理，完成线程的切换</li><li>遍历队列，取出PendingPost对象，并通过反射处理</li></ol><p>事件发布流程为：<br><img src="/archives/11ada9d0/EventBusPost.png" alt="EventBusPost"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合上面的分析，我们知道了EventBus的实现原理，也明白了它在易用性和效率性所作出的努力。借助它的导入，我们的项目就可以摆脱广播、全局变量、回调等进程内通信方式；但是，EventBus的过量使用，同样会导致软件的可维护性变差，事件的跟踪和处理会变得更加凌乱。</p><p>所以，EventBus可用，但不可滥用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot; title=&quot;EventBus&quot; targ
      
    
    </summary>
    
      <category term="开源项目源码" scheme="http://yunlinos.com/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Python实现单点登录(SSO)</title>
    <link href="http://yunlinos.com/archives/c314ba14.html"/>
    <id>http://yunlinos.com/archives/c314ba14.html</id>
    <published>2018-08-18T07:44:27.000Z</published>
    <updated>2018-08-18T07:56:51.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近打算使用Python实现自动抓取<a href="https://www.atlassian.com/software/confluence" title="Confluence" target="_blank" rel="noopener">Confluence</a>页面，本来以为模拟登陆、页面抓取、数据分析能够一气呵成，可是事实并没有那么简单，直接在模拟登录这块NG了。</p><p>因为公司采用的并非是单系统登录机制，而是采用多系统单点登录机制（SSO），所以在模拟登陆获取<code>cookies</code>时遇到各种权限认证、页面跳转，导致整个过程比较曲折。不过，在仔细研究了单点登录的原理以及抓包后，终于解决了该问题，下面就是对这块内容的整理，主要分为两块：</p><ol><li>单系统登录机制和多系统单点登录机制(SSO)的区别</li><li>Python实现单点登录的过程</li></ol><p>如果对SSO原理不感兴趣，可直接跳转到<a href="#模拟SSO登录">实现部分</a>。</p><h2 id="SSO简介"><a href="#SSO简介" class="headerlink" title="SSO简介"></a>SSO简介</h2><h3 id="http会话机制"><a href="#http会话机制" class="headerlink" title="http会话机制"></a>http会话机制</h3><p>web应用采用browser/server架构，http作为通信协议。http是无状态协议（是指协议对于事务处理没有记忆能力），浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联。</p><p>如果用户需要通过浏览器访问服务器的敏感资源，那么就必须要相应的授权行为，即服务器需要鉴别浏览器的行为，只响应合法请求，忽略非法请求。但是要鉴别浏览器的行为，就必须要清楚浏览器的请求状态，能够识别本次请求的用户是谁，该用户的行为是否经过授权等信息。所以就出现了会话机制，即<a href="https://zhuanlan.zhihu.com/p/21275207" title="Cookie与Session机制" target="_blank" rel="noopener">Cookie与Session机制</a>。</p><p>Cookie通过在浏览器（客户端）记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。浏览器在每次发送http请求时都带上Cookie，而服务器端则根据该信息来判断当前的连接状态，这样就能知道会话的上下文信息了。因此，有了Cookie，服务端就能知道客户端的状态；而没有了Cookie，它连金鱼都不如。<br>有了会话机制，服务端就能更好的做好授权行为，即实现服务端的登录。</p><h3 id="单系统登录机制"><a href="#单系统登录机制" class="headerlink" title="单系统登录机制"></a>单系统登录机制</h3><p>单系统登录机制的实现很简单，就是客户端在第一次请求服务器时带上账号和密码，服务器在拿到这些信息后进行校验，如果校验成功则表明是合法的身份。这时候服务器会返回客户一个身份信息，即Cookie，客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态与权限。其过程如下：<br><img src="/archives/c314ba14/单系统登录.png" alt="单系统登录"></p><h3 id="多系统单点登录机制-SSO"><a href="#多系统单点登录机制-SSO" class="headerlink" title="多系统单点登录机制(SSO)"></a>多系统单点登录机制(SSO)</h3><p>随着计算机网络的发展，很多公司内部不只是单系统，而是发展成为了由多系统组成的应用群，面对各种系统，如果还是使用之前的登录机制，那么每套系统的使用都需要重新登录、注销等等，这将会极大影响日常的工作。</p><p>这时候就会出现了单点登录机制，即SSO(Single Sign On)。在多系统应用群中，只需要登录其中一个系统，即可在其他所有系统中得到授权而无需再次登录。</p><p>sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p><h2 id="模拟SSO登录"><a href="#模拟SSO登录" class="headerlink" title="模拟SSO登录"></a>模拟SSO登录</h2><p>在明白单点登录的原理后，我们就很容易知道后面需要的突破方向。而且只要拿到系统登录页面的cookie后，就能畅通无阻的访问内网的所有其他系统。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>Chrome 使用显示网页源代码和检查功能，来跟踪页面的请求过程</li><li>python 3.6</li><li>requests<br>当然，也可以使用抓包工具来分析整个请求过程，比如Windows上的<code>fiddler</code>，Mac上的<code>charles</code>。不过Chrome已经完全能够满足我们的要求。</li></ul><h3 id="分析登录页面"><a href="#分析登录页面" class="headerlink" title="分析登录页面"></a>分析登录页面</h3><p>打开登录页面，打开（F12或者邮件检查）Chrome自带的分析工具，在Network选卡上可以看到当前浏览器显示页面和提交登录信息的详情，如下图：<br><img src="/archives/c314ba14/登录界面.png" alt="登录界面"></p><p>接下来我们在页面上输入账号密码，点击登录按钮，通过页面追踪分析并模拟整个登录过程。如下图：<br><img src="/archives/c314ba14/登录请求界面.png" alt="登录请求界面"></p><p>从上面请求过程可以分析其流程如下：</p><ol><li>登录按钮提交时用POST方式提交表单，该表单包含账号、密码、it、execution等，并拿到分配的Ticket</li><li>通过Ticket发送Get请求获取SSO的Cookie</li><li>通过SSO Cookie进行最终的请求</li></ol><p>如果我们尝试多次登录，会发现每次it和execution是会变化的，不是固定不变。而这两个值可以从登录页面中直接拿到，在登录页面检查网页源代码，见下图：<br><img src="/archives/c314ba14/网页Execution信息.png" alt="网页Execution信息"></p><p>故我们可以Get请求获取登陆使用Lt和execution数据。</p><h3 id="模拟登录代码实现"><a href="#模拟登录代码实现" class="headerlink" title="模拟登录代码实现"></a>模拟登录代码实现</h3><p>在明白了整个登录后，我们就能开始动手写代码了。不过要注意的是，因为http是无状态的，web页面要保存登录状态需要用到Cookie，所以在每次请求时都需要带上上次返回的Cookie，否则就会被不停的重定向到登录页面，刚开始我也是在这里踩了很多坑。代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLoginInfo</span><span class="params">(it, execution, _eventId)</span>:</span></span><br><span class="line">    login_data = &#123;</span><br><span class="line">        <span class="string">'username'</span>: <span class="string">'***'</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">'***'</span>,</span><br><span class="line">        <span class="string">'imagecode'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'lt'</span>: it,</span><br><span class="line">        <span class="string">'execution'</span>: execution,</span><br><span class="line">        <span class="string">'_eventId'</span>: _eventId</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> login_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLoginHeader</span><span class="params">(str)</span>:</span></span><br><span class="line">    cook = <span class="string">'JSESSIONID='</span> + str</span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">        <span class="string">'Content-Length'</span>: <span class="string">'132'</span>,</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">        <span class="string">'Cache-Control'</span>: <span class="string">'max-age=0'</span>,</span><br><span class="line">        <span class="string">'Upgrade-Insecure-Requests'</span>: <span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36'</span>,</span><br><span class="line">        <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">        <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Origin'</span>: <span class="string">'&lt;url&gt;'</span>,</span><br><span class="line">        <span class="string">'Host'</span>: <span class="string">'&lt;url&gt;'</span>,</span><br><span class="line">        <span class="string">'Referer'</span>: <span class="string">'&lt;url&gt;'</span>,</span><br><span class="line">        <span class="string">'Cookie'</span>: cook</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> header</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getItInfo</span><span class="params">(content)</span>:</span></span><br><span class="line">    m = <span class="string">r'&lt;input type="hidden" name="lt" value="(.+?)" /&gt;'</span></span><br><span class="line">    n = re.findall(m, content)</span><br><span class="line">    <span class="keyword">return</span> n[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getExecutionInfo</span><span class="params">(content)</span>:</span></span><br><span class="line">    m = <span class="string">r'&lt;input type="hidden" name="execution" value="(.+?)" /&gt;'</span></span><br><span class="line">    n = re.findall(m, content)</span><br><span class="line">    <span class="keyword">return</span> n[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getEventIdInfo</span><span class="params">(content)</span>:</span></span><br><span class="line">    m = <span class="string">r'&lt;input type="hidden" name="_eventId" value="(.+?)" /&gt;'</span></span><br><span class="line">    n = re.findall(m, content)</span><br><span class="line">    <span class="keyword">return</span> n[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kb_url = <span class="string">'&lt;url&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 禁用安全请求警告</span></span><br><span class="line">requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class="line">loginreqsession = requests.session()  <span class="comment"># 创建session对象保存所有登录会话请求</span></span><br><span class="line">loginreqsession.keep_alive = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get请求获取登陆使用Lt和execution数据</span></span><br><span class="line">res = loginreqsession.get(kb_url, verify=<span class="keyword">False</span>)</span><br><span class="line">content = res.content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">cookie = res.cookies</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过正则表达式从登录页面中提取相关信息</span></span><br><span class="line">it = getItInfo(content)</span><br><span class="line">execution = getExecutionInfo(content)</span><br><span class="line">eventId = getEventIdInfo(content)</span><br><span class="line">print(<span class="string">'%s %s %s'</span> % (it, execution, eventId))</span><br><span class="line">loginData = getLoginInfo(it, execution, eventId)</span><br><span class="line">print(loginData)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Post请求获取SSO分配的Ticket</span></span><br><span class="line">res = loginreqsession.post(kb_url, headers=getLoginHeader(cookie[<span class="string">'JSESSIONID'</span>]), data=loginData, cookies=cookie,</span><br><span class="line">                           allow_redirects=<span class="keyword">False</span>, verify=<span class="keyword">False</span>)</span><br><span class="line">cookie = res.cookies</span><br><span class="line">location = res.headers[<span class="string">'Location'</span>]</span><br><span class="line">print(location)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过Ticket发送Get请求获取cookies</span></span><br><span class="line">res = loginreqsession.get(location, allow_redirects=<span class="keyword">False</span>, verify=<span class="keyword">False</span>)</span><br><span class="line">cookie = res.cookies</span><br><span class="line">print(cookie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用cookies请求页面信息</span></span><br><span class="line">str = <span class="string">'&lt;url&gt;'</span></span><br><span class="line">content = requests.get(str, cookies=cookie, verify=<span class="keyword">False</span>).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在对整个登录流程做个总结：</p><ol><li>Get请求获取登陆使用Lt和execution数据</li><li>Post请求获取SSO分配的Ticket</li><li>通过Ticket发送Get请求获取SSO的cookie</li><li>通过SSO Cookie获取页面信息</li></ol><p>要注意的地方上面也提到过，就是：每次请求时都需要带上上次返回的Cookie，否则就会被不停的重定向到登录页面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近打算使用Python实现自动抓取&lt;a href=&quot;https://www.atlassian.com/software/confluen
      
    
    </summary>
    
      <category term="日常问题处理" scheme="http://yunlinos.com/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Python" scheme="http://yunlinos.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Android触摸事件模拟</title>
    <link href="http://yunlinos.com/archives/8b308b7c.html"/>
    <id>http://yunlinos.com/archives/8b308b7c.html</id>
    <published>2018-08-10T01:40:36.000Z</published>
    <updated>2018-08-10T13:40:36.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用monkey进行压力测试时，我们发现，随机的触摸事件中大约有95%的无效事件，达到深层页面的概率极低，每晚压测的实际有效时间其实只有半小时，且缺少相互依赖的路径，完全无法满足压力测试的需求。而存粹依靠人工测试则效率过低，所以我们会想，能否有一种方式，可以将我们的测试过程录制下来，然后在更多的机器上面循环回放，还能对操作进行加速和减速，并且实时跟踪崩溃数据和性能数据，起到效率更高的压测效果，即<code>Copy once, paste anywhere</code>。在知道<a href="http://yunlinos.com/archives/9f4ea589.html" title="触摸事件原理">触摸事件原理</a>后，我们就开始做这件很Cool的事情，而本文就介绍了整个预研和摸索的过程。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们现在先梳理下我们需要实现的功能，即过程大概如下：</p><ol><li>将触摸事件记录在文本中</li><li>记录相邻事件的时间间隔</li><li>读取文本信息，解析成触摸事件和时间间隔</li><li>将触摸事件注入到系统中，并根据时间间隔进行延时注入</li></ol><p>说到触摸事件注入，那么我们是否有想到之前的这篇文章：<a href="http://yunlinos.com/archives/9f4ea589.html" title="Android触摸事件原理">Android触摸事件原理</a>。在那里介绍了Monkey中常用的两种事件注入方式，即：</p><ol><li><code>InputManager.getInstance().injectInputEvent</code></li><li><code>FileOutputStream(&quot;/dev/input/event0&quot;)</code></li></ol><p>现在，事件注入的方式有了，那么事件来源的方式呢，我们如何得到事件源和事件间隔？下面，我们将以这两种方式作为突破口来实现触摸的录制和回放。</p><h2 id="injectEvent"><a href="#injectEvent" class="headerlink" title="injectEvent"></a>injectEvent</h2><p>在前面的文章中，我们深入了解了injectEvent方法的执行流程，其实就是<code>InputDispatcher</code>对事件进行分发。优点是直接通过应用层去执行，且触摸事件不需要经过任何处理即可进行分发，速度极快，基本上没有任何延迟就可以响应，monkey中大量的随机事件就是用这种方式处理的。</p><p>但最大的问题是，我们如何获取到操作中的触摸事件信息，并保存成文本信息呢。如果仿照<code>monkeyscript</code>的实现方式，在脚本中自定义触摸事件，确实可以生成可用的数据，但是这种工作极其繁琐且效率较低，只能用于单个按钮点击或者短路径的测试场景，对于压力测试这种长时间、多应用的测试场景，就显得力不从心了。</p><p>因此，我们只能从系统的事件源中想办法，通过抓取系统产生的大量事件来生成事件源。想到的方法有两种：</p><ol><li>从getevent拿到数据，即通过监听<code>/dev/input/event*</code>节点来捕获系统input事件。但是这些事件需要通过较为复杂的转换才能在应用层进行注入，且还要处理多指、拖拽等场景，较为麻烦，故暂时不做考虑，如果没有更好的方案可以再回头来看。</li><li>在<code>InputManagerService</code>中通过Socked向上层发送需要分发的数据，这些数据不需要任何处理就能从应用层进行事件注入，但是这样对系统代码的侵入性太强，故也不考虑。</li></ol><p>那么，我们就来看其他方式。</p><h2 id="getevent"><a href="#getevent" class="headerlink" title="getevent"></a>getevent</h2><p>在monkey中，使用的第二种事件注入方式就是通过向设备节点<code>/dev/input/event*</code>中写入触摸数据，然后InputManager中的<code>EventHub</code>就能正常获取到该事件，再进行后续的事件分发。<br>不过，Android官方已经提供了现成的工具做这些工作，包括事件捕获和事件注入，即<code>getevent</code>和<code>sendevent</code>。我们先通过adb命令来看下getevent的用法（触摸事件在哪个设备节点需要先确认，我这台Android设备的触摸事件是在<code>event4</code>）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb shell getevent | grep event4</span><br><span class="line">add device 5: /dev/input/event4</span><br><span class="line">/dev/input/event4: 0003 0039 00000008</span><br><span class="line">/dev/input/event4: 0003 0035 00005cdf</span><br><span class="line">/dev/input/event4: 0003 0036 00003341</span><br><span class="line">/dev/input/event4: 0001 014a 00000001</span><br><span class="line">/dev/input/event4: 0003 0000 00005cdf</span><br><span class="line">/dev/input/event4: 0003 0001 00003341</span><br><span class="line">/dev/input/event4: 0000 0000 00000000</span><br></pre></td></tr></table></figure></p><p>关于<code>getevent</code>的相关参数我们可以详见官方文章：<a href="https://source.android.com/devices/input/getevent" title="https://source.android.com/devices/input/getevent" target="_blank" rel="noopener">https://source.android.com/devices/input/getevent</a><br>这样我们就能获取到系统中的所有的触摸事件，然后根据出现的时间来确定时间间隔，并将这些信息保存成文本中，<code>python</code>实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNeededEvent</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'/dev/input/event4'</span> <span class="keyword">in</span> event <span class="keyword">and</span> <span class="string">'add device'</span> <span class="keyword">not</span> <span class="keyword">in</span> event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCurrentMillisecondTime</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(round(time.time() * <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyInputEvent</span><span class="params">()</span>:</span></span><br><span class="line">    copyCmd = <span class="string">'adb -s %s shell getevent'</span> % deviceIp</span><br><span class="line">    outputStream = os.popen(copyCmd)._stream</span><br><span class="line">    eventSaveFile = open(<span class="string">'Event.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">    eventLine = outputStream.readline()</span><br><span class="line">    currentTime = getCurrentMillisecondTime()</span><br><span class="line">    <span class="keyword">while</span> eventLine:</span><br><span class="line">        <span class="keyword">if</span> isNeededEvent(eventLine):</span><br><span class="line">            intervalTime = getCurrentMillisecondTime() - currentTime</span><br><span class="line">            currentTime = getCurrentMillisecondTime()</span><br><span class="line">            eventStr = <span class="string">'%s#%s'</span> % (intervalTime, eventLine)</span><br><span class="line">            print(intervalTime, eventLine)</span><br><span class="line">            eventSaveFile.write(eventStr)</span><br><span class="line">        eventLine = outputStream.readline()</span><br></pre></td></tr></table></figure></p><p>最终，我们得到的文本内容为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1#/dev/input/event4: 0003 0035 000011a5</span><br><span class="line">0#/dev/input/event4: 0003 0036 00001753</span><br><span class="line">0#/dev/input/event4: 0001 014a 00000001</span><br><span class="line">0#/dev/input/event4: 0003 0000 000011a5</span><br><span class="line">0#/dev/input/event4: 0003 0001 00001753</span><br><span class="line">4#/dev/input/event4: 0000 0000 00000000</span><br><span class="line">20#/dev/input/event4: 0003 0035 000011ae</span><br><span class="line">0#/dev/input/event4: 0003 0036 000017a0</span><br><span class="line">0#/dev/input/event4: 0003 0000 000011ae</span><br><span class="line">0#/dev/input/event4: 0003 0001 000017a0</span><br><span class="line">0#/dev/input/event4: 0000 0000 00000000</span><br><span class="line">5#/dev/input/event4: 0003 0035 000011b9</span><br><span class="line">0#/dev/input/event4: 0003 0036 000017fc</span><br><span class="line">0#/dev/input/event4: 0003 0000 000011b9</span><br><span class="line">4#/dev/input/event4: 0003 0001 000017fc</span><br></pre></td></tr></table></figure></p><h2 id="sendevent"><a href="#sendevent" class="headerlink" title="sendevent"></a>sendevent</h2><p>在得到这些触摸的文本信息，我们就能通过<code>sendevent</code>方法来进行触摸事件注入了，而且能通过事件前面记录的时间间隔来确定延时时间，从而模拟出正常的操作。不过在这之前，我们需要先确认下面几点注意事项，即：</p><ol><li><code>getevent</code>得到的数值是16进制的，<code>sendevent</code>输入的参数是10进制的，注意进行转换</li><li><code>sendevent</code>中没有冒号，即<code>sendevent /dev/input/event4 3 57 579</code>这种方式</li><li>如果执行没有效果，尝试先修改文件权限，在su后调用<code>chmod 777 /dev/input/event[x]</code></li></ol><p>万事俱备，我们现在来撸出事件注入的代码，同样是<code>python实现</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCurrentMillisecondTime</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(round(time.time() * <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTranslatedEvent</span><span class="params">(eventContent)</span>:</span></span><br><span class="line">    event = eventContent.split(<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'%s %s %s %s'</span> % (event[<span class="number">0</span>], int(event[<span class="number">1</span>], <span class="number">16</span>), int(event[<span class="number">2</span>], <span class="number">16</span>), int(event[<span class="number">3</span>], <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pasteInutEvent</span><span class="params">()</span>:</span></span><br><span class="line">    eventSaveFile = open(<span class="string">'Event.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">    eventLines = eventSaveFile.readlines()</span><br><span class="line"></span><br><span class="line">    time3 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> eventLine <span class="keyword">in</span> eventLines:</span><br><span class="line">        eventLine = eventLine.strip(<span class="string">'\n'</span>)</span><br><span class="line">        eventInfo = eventLine.split(<span class="string">'#'</span>)</span><br><span class="line">        intervalTime = eventInfo[<span class="number">0</span>]</span><br><span class="line">        eventContent = eventInfo[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> intervalTime != <span class="string">'0'</span>:</span><br><span class="line">            time.sleep(int(intervalTime) / <span class="number">1000</span>)</span><br><span class="line">        time2 = getCurrentMillisecondTime()</span><br><span class="line">        translatedEvent = getTranslatedEvent(eventContent).replace(<span class="string">':'</span>, <span class="string">''</span>)</span><br><span class="line">        print(<span class="string">'+++%s'</span> % (time2 - time3))</span><br><span class="line">        pasteCmd = <span class="string">'adb -s %s shell sendevent '</span> % deviceIp</span><br><span class="line">        os.system(<span class="string">'%s %s'</span> % (pasteCmd, translatedEvent))</span><br><span class="line">        time3 = getCurrentMillisecondTime()</span><br><span class="line">        print(<span class="string">'---%s'</span> % (time3 - time2))</span><br></pre></td></tr></table></figure></p><p>到了这里，我们就是不是就已经完成了所有的事件录制和回放的功能呢？不，不是的。如果有执行上面这段代码，我们会发现，界面上确实正在回放我们刚刚的操作的路径，不过是以龟速在进行，大概录制一分钟的操作，可能需要十分钟才能执行完，这样的功能并不能满足我们的需要。</p><p>可是，我们确实是按照记录的时间间隔来进行延时处理的，那么问题到底在哪里呢？于是我们在代码中加入日志，打印了方法的执行时间，发现在实际事件注入的地方（<code>os.system(&#39;%s %s&#39; % (pasteCmd, translatedEvent))</code>）耗时较长，大概开销在70ms左右。而我们后面的努力就是要将这块的时间开销降到最低，否则这种方案没有任何实际使用价值。那么我们从<code>sendevent</code>的源码实现入手，源码位于<code>system/core/toolbox/sendevent.c</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendevent_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> fd;</span><br><span class="line">     <span class="keyword">ssize_t</span> ret;</span><br><span class="line">     <span class="keyword">int</span> version;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(argc != <span class="number">5</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"use: %s device type code value\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">     <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"could not open %s, %s\n"</span>, argv[optind], strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (ioctl(fd, EVIOCGVERSION, &amp;version)) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"could not get driver version for %s, %s\n"</span>, argv[optind], strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line">     event.type = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">     event.code = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">     event.value = atoi(argv[<span class="number">4</span>]);</span><br><span class="line">     ret = write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">     <span class="keyword">if</span>(ret &lt; (<span class="keyword">ssize_t</span>) <span class="keyword">sizeof</span>(event)) &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"write event failed, %s\n"</span>, strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>代码比较简单，从中我们可以看出事件注入的流程就是：打开文件描述符（13行）、组装事件信息（22-25行）、写入事件信息（26行）、关闭文件描述符（进程关闭时）。而对应我们每一次通过<code>sendevent</code>进行的事件注入，就意味着重复打开关闭文件的操作，根据经验判断，这个过程是非常耗时的。所以我们可以尝试重写该源码来验证我们的判断：在打开文件描述符后，写入所有数据，再关闭文件描述符。</p><p>另外，我们的想法是，通过<code>python</code>脚本录制所有的操作后，直接将事件数据文本导入到Android设备中，然后运行相关服务就可以进行回放。故<code>jni</code>代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line">    __u16 type;</span><br><span class="line">    __u16 code;</span><br><span class="line">    __s32 value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_yunlinos_montioninject_EventInject_openInputSource(JNIEnv *env, jclass type) &#123;</span><br><span class="line">    __android_log_write(ANDROID_LOG_DEBUG, <span class="string">"InjectEvent"</span>, <span class="string">"openInputSource"</span>);</span><br><span class="line">    fd = open(<span class="string">"/dev/input/event4"</span>, O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_yunlinos_montioninject_EventInject_injectEvent(JNIEnv *env, jclass type,</span><br><span class="line">                                                        jstring eventType_, jstring eventCode_,</span><br><span class="line">                                                        jstring eventValue_) &#123;</span><br><span class="line">    __android_log_write(ANDROID_LOG_DEBUG, <span class="string">"InjectEvent"</span>, <span class="string">"injectEvent"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eventType = (*env)-&gt;GetStringUTFChars(env, eventType_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eventCode = (*env)-&gt;GetStringUTFChars(env, eventCode_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eventValue = (*env)-&gt;GetStringUTFChars(env, eventValue_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line"></span><br><span class="line">    event.code = atoi(eventCode);</span><br><span class="line">    event.type = atoi(eventType);</span><br><span class="line">    event.value = atoi(eventValue);</span><br><span class="line"></span><br><span class="line">    write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, eventType_, eventType);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, eventCode_, eventCode);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, eventValue_, eventValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_yunlinos_montioninject_EventInject_closeInputSource(JNIEnv *env, jclass type) &#123;</span><br><span class="line">    __android_log_write(ANDROID_LOG_DEBUG, <span class="string">"InjectEvent"</span>, <span class="string">"closeInputSource"</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而应用层Java代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">openInputSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">injectEvent</span><span class="params">(String eventType, String eventCode, String eventValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">closeInputSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFileEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"/sdcard/Event.txt"</span>));</span><br><span class="line">         InputStreamReader is = <span class="keyword">new</span> InputStreamReader(fis);</span><br><span class="line">         BufferedReader br = <span class="keyword">new</span> BufferedReader(is)) &#123;</span><br><span class="line"></span><br><span class="line">        String txtLine;</span><br><span class="line">        String[] allEvents;</span><br><span class="line">        String[] eventInfo;</span><br><span class="line">        String eventStr;</span><br><span class="line">        <span class="keyword">while</span> ((txtLine = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            InputEvent inputEvent = <span class="keyword">new</span> InputEvent();</span><br><span class="line">            allEvents = txtLine.split(<span class="string">"#"</span>);</span><br><span class="line">            inputEvent.time = Long.parseLong(allEvents[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            eventStr = allEvents[<span class="number">1</span>].replace(<span class="string">":"</span>, <span class="string">""</span>);</span><br><span class="line">            eventInfo = eventStr.split(<span class="string">" "</span>);</span><br><span class="line">            inputEvent.type = String.valueOf(Integer.parseInt(eventInfo[<span class="number">1</span>], <span class="number">16</span>));</span><br><span class="line">            inputEvent.code = String.valueOf(Integer.parseInt(eventInfo[<span class="number">2</span>], <span class="number">16</span>));</span><br><span class="line">            inputEvent.value = String.valueOf(Long.parseLong(eventInfo[<span class="number">3</span>], <span class="number">16</span>));</span><br><span class="line">            inputEvents.add(inputEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectEvent</span><span class="params">(List&lt;InputEvent&gt; inputEventList)</span> </span>&#123;</span><br><span class="line">    EventInject.openInputSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (InputEvent inputEvent : inputEventList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputEvent.time != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(inputEvent.time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        EventInject.injectEvent(inputEvent.type, inputEvent.code, inputEvent.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventInject.closeInputSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>readFileEvent</code>方法用于读取事件信息文本并解析为可使用的事件，<code>injectEvent</code>则是实际事件注入的地方。在运行后，发现能够完美解决我们现有的问题。不过，针对于实际应用场景，还有很多需要优化的点，比如：</p><ul><li>当录制时间过长时，一次性解析所有触摸信息并解析为对象肯定不可能，内存占用太多。可能这个时就候需要使用生产消费者队列了。</li><li>我们还可以配置部分参数，通过处理延时时间的方式，进行回放的加速和减速。</li><li>等等</li></ul><p>这些在这篇文章中就不过多赘述了，各位可以根据自己的业务需要来进行定制化处理。</p><h2 id="项目开源地址"><a href="#项目开源地址" class="headerlink" title="项目开源地址"></a>项目开源地址</h2><p>触摸录制：<a href="https://github.com/yunlinos/MotionCopy" title="https://github.com/yunlinos/MotionCopy" target="_blank" rel="noopener">https://github.com/yunlinos/MotionCopy</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://source.android.com/devices/input/getevent.html" title="http://source.android.com/devices/input/getevent.html" target="_blank" rel="noopener">http://source.android.com/devices/input/getevent.html</a><br><a href="http://source.android.com/devices/input/touch-devices.html" title="http://source.android.com/devices/input/touch-devices.html" target="_blank" rel="noopener">http://source.android.com/devices/input/touch-devices.html</a><br><a href="https://stackoverflow.com/questions/12079591/android-sendevent-is-really-slow-how-to-speed-it-up" title="https://stackoverflow.com/questions/12079591/android-sendevent-is-really-slow-how-to-speed-it-up" target="_blank" rel="noopener">https://stackoverflow.com/questions/12079591/android-sendevent-is-really-slow-how-to-speed-it-up</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用monkey进行压力测试时，我们发现，随机的触摸事件中大约有95%的无效事件，达到深层页面的概率极低，每晚压测的实际有效时间其实只有半
      
    
    </summary>
    
      <category term="Android系统源码" scheme="http://yunlinos.com/categories/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="自动化测试" scheme="http://yunlinos.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="触摸事件" scheme="http://yunlinos.com/tags/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android触摸事件分发--从InputManager到Window</title>
    <link href="http://yunlinos.com/archives/feabfdd.html"/>
    <id>http://yunlinos.com/archives/feabfdd.html</id>
    <published>2018-08-05T07:06:56.000Z</published>
    <updated>2018-08-06T00:01:35.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上篇文章<a href="http://yunlinos.com/archives/9f4ea589.html" title="Android触摸事件原理">Android触摸事件原理</a>中，我们知道了事件注入的原理，也了解了触摸事件的来源与去处。但是，仍然留了两个比较复杂的问题还没解决，那就是：</p><ol><li>将触摸事件发送给Window时，是如何在茫茫人海中确定眼神的？</li><li>他们相隔千山万水，又是如何将触摸事件交付给对方的？</li></ol><p>当然，涉及到跨进程通信，我们的第一反应肯定是Binder机制。毕竟Binder在Android中是使用最多的IPC手段，包括Activity启动、Service启动等等，是效率和安全的象征。那触摸事件的跨进程分发到底是不是使用Binder呢，我们继续往下看。</p><h2 id="如何为触摸事件找到Window"><a href="#如何为触摸事件找到Window" class="headerlink" title="如何为触摸事件找到Window"></a>如何为触摸事件找到Window</h2><p>让时间倒转，回到<code>dispatchMotionLocked</code>：<br>[-&gt; InputDispatcher.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchMotionLocked(</span><br><span class="line">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="comment">// Pointer event.  (eg. touchscreen)</span></span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Non touch event.  (eg. trackball)</span></span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续往下看，进入到<code>findFocusedWindowTargetsLocked</code>中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> InputDispatcher::findFocusedWindowTargetsLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    String8 reason;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前没有获取焦点的窗口或者应用，就丢弃该事件</span></span><br><span class="line">    <span class="keyword">if</span> (mFocusedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocusedApplicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    mFocusedApplicationHandle, <span class="literal">NULL</span>, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);</span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ALOGI(<span class="string">"Dropping event because there is no focused window or focused application."</span>);</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    <span class="keyword">if</span> (! checkInjectionPermission(mFocusedWindowHandle, entry-&gt;injectionState)) &#123;</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测窗口是否为更多的输入操作而准备就绪</span></span><br><span class="line">    reason = checkWindowReadyForMoreInputLocked(currentTime,</span><br><span class="line">            mFocusedWindowHandle, entry, <span class="string">"focused"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reason.isEmpty()) &#123;</span><br><span class="line">        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功找到目标窗口，添加到目标窗口</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    addWindowTargetLocked(mFocusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">Failed:</span><br><span class="line">Unresponsive:</span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatisticsLocked(currentTime, entry,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    ALOGD(<span class="string">"findFocusedWindow finished: injectionResult=%d, "</span></span><br><span class="line">            <span class="string">"timeSpentWaitingForApplication=%0.1fms"</span>,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication / <span class="number">1000000.0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以从代码中的注释看到，会经过权限检查、窗口焦点状态等条件判断。那么，此处的<code>mFocusedWindowHandle</code>又是在哪里赋值的呢？我们可以在InputDispatcher找到赋值的地方：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::setInputWindows(<span class="keyword">const</span> Vector&lt;sp&lt;InputWindowHandle&gt; &gt;&amp; inputWindowHandles) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    ALOGD(<span class="string">"setInputWindows"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Vector&lt;sp&lt;InputWindowHandle&gt; &gt; oldWindowHandles = mWindowHandles;</span><br><span class="line">        mWindowHandles = inputWindowHandles;</span><br><span class="line"></span><br><span class="line">        sp&lt;InputWindowHandle&gt; newFocusedWindowHandle;</span><br><span class="line">        <span class="keyword">bool</span> foundHoveredWindow = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mWindowHandles.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle = mWindowHandles.itemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!windowHandle-&gt;updateInfo() || windowHandle-&gt;getInputChannel() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mWindowHandles.removeAt(i--);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle-&gt;getInfo()-&gt;hasFocus) &#123;</span><br><span class="line">                newFocusedWindowHandle = windowHandle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle == mLastHoverWindowHandle) &#123;</span><br><span class="line">                foundHoveredWindow = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!foundHoveredWindow) &#123;</span><br><span class="line">            mLastHoverWindowHandle = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFocusedWindowHandle != newFocusedWindowHandle) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFocusedWindowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">                ALOGD(<span class="string">"Focus left window: %s"</span>,</span><br><span class="line">                        mFocusedWindowHandle-&gt;getName().<span class="built_in">string</span>());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                sp&lt;InputChannel&gt; focusedInputChannel = mFocusedWindowHandle-&gt;getInputChannel();</span><br><span class="line">                <span class="keyword">if</span> (focusedInputChannel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="function">CancelationOptions <span class="title">options</span><span class="params">(CancelationOptions::CANCEL_NON_POINTER_EVENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="string">"focus left window"</span>)</span></span>;</span><br><span class="line">                    synthesizeCancelationEventsForInputChannelLocked(</span><br><span class="line">                            focusedInputChannel, options);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newFocusedWindowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">                ALOGD(<span class="string">"Focus entered window: %s"</span>,</span><br><span class="line">                        newFocusedWindowHandle-&gt;getName().<span class="built_in">string</span>());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            mFocusedWindowHandle = newFocusedWindowHandle;</span><br><span class="line">        &#125;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>InputDispatcher::setInputWindows</code>中，可以看到这里会对mWindowHandles赋值，也有对mFocusedWindowHandle进行赋值，如果看过<code>findTouchedWindowTargetsLocked</code>，同样会发现也是基于对mWindowHandles的遍历找到目标窗口的。<br>那么谁会调用<code>setInputWindows</code>函数呢？具体可以看这篇文章<a href="http://gityuan.com/2016/12/24/input-ui/" title="Input系统—UI线程" target="_blank" rel="noopener">Input系统—UI线程</a>，其实就是在窗口进行创建和删除时进行更新。<br><img src="/archives/feabfdd/window添加流程图.png" alt="window添加流程图"></p><h2 id="如何将触摸式事件分发到Window"><a href="#如何将触摸式事件分发到Window" class="headerlink" title="如何将触摸式事件分发到Window"></a>如何将触摸式事件分发到Window</h2><p>在知道怎么找到目标Window后，最关键的问题就是如何将事件分发到该Window了。那么，到底是不是通过Binder呢？再次回到InputDispatcher中进行事件分发的地方，即<code>InputDispatcher::dispatchOnce</code>，一步步随着代码读下去，就会发现最终是通过Socket发送出去的：<br><img src="/archives/feabfdd/事件发送流程.png" alt="事件发送流程"><br>当然，关于Socket的创建我们可以在窗口建立时找到，即<code>WindowManagerService</code>中，更详细见参考资料：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建WindowState【见小节2.5.1】</span></span><br><span class="line">    WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span> &amp;&amp; (attrs.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//根据WindowState的HashCode以及title来生成InputChannel名称</span></span><br><span class="line">        String name = win.makeInputChannelName();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一对InputChannel[见小节2.6]</span></span><br><span class="line">        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">        <span class="comment">//将socket服务端保存到WindowState的mInputChannel</span></span><br><span class="line">        win.setInputChannel(inputChannels[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//socket客户端传递给outInputChannel [见小节2.7]</span></span><br><span class="line">        inputChannels[<span class="number">1</span>].transferTo(outInputChannel);</span><br><span class="line">        <span class="comment">//利用socket服务端作为参数[见小节2.8]</span></span><br><span class="line">        mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> focusChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (win.canReceiveKeys()) &#123;</span><br><span class="line">        <span class="comment">//新添加window能接收按下操作，则更新聚焦窗口。</span></span><br><span class="line">        focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">        mInputMonitor.setInputFocusLw(mCurrentFocus, <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置当前聚焦窗口【见小节2.5.2】</span></span><br><span class="line">    mInputMonitor.updateInputWindowsLw(<span class="keyword">false</span> <span class="comment">/*force*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从这两篇博客中，我们就弄清楚了整个触摸事件传递的过程，回到最开始的问题：</p><ol><li>将触摸事件发送给Window时，是如何在茫茫人海中确定眼神的？<strong>在Window创建时，会将相应的窗口信息同步更新到InputDispatcher中；然后在分发事件事件时，根据触摸事件的位置及窗口的属性来找到目标窗口。</strong></li><li>他们相隔千山万水，又是如何将触摸事件交付给对方的？<strong>通过Socket的通信方式，在窗口添加时进行创建Socket</strong></li></ol><p>借用<a href="http://gityuan.com/" title="gityuan" target="_blank" rel="noopener">gityuan</a>中图为：</p><p><img src="/archives/feabfdd/事件框架图.jpg" alt="事件框架图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://gityuan.com/2016/12/31/input-ipc/" title="Input系统—事件处理全过程" target="_blank" rel="noopener">Input系统—事件处理全过程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上篇文章&lt;a href=&quot;http://yunlinos.com/archives/9f4ea589.html&quot; title=&quot;Andro
      
    
    </summary>
    
      <category term="Android系统源码" scheme="http://yunlinos.com/categories/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="触摸事件" scheme="http://yunlinos.com/tags/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android触摸事件原理</title>
    <link href="http://yunlinos.com/archives/9f4ea589.html"/>
    <id>http://yunlinos.com/archives/9f4ea589.html</id>
    <published>2018-08-04T02:40:02.000Z</published>
    <updated>2018-08-05T02:22:29.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上篇文章<a href="http://yunlinos.com/archives/ff7c0d4a.html" title="Android Monkey源码解析">Android Monkey源码解析</a>中，我们学习了Monkey的基本用法，也知道了完整的执行流程。在大多数情况下，我们只需要一行代码即可完成最终的系统事件注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!InputManager.getInstance().injectInputEvent(keyEvent,</span><br><span class="line">        InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT)) &#123;</span><br><span class="line">    <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br></pre></td></tr></table></figure></p><p>当然，如果你阅读源码较为细心，也会发现<code>MonkeyFlipEvent</code>是用了另外一种方式进行事件注入，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">injectEvent</span><span class="params">(IWindowManager iwm, IActivityManager iam, <span class="keyword">int</span> verbose)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verbose &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">":Sending Flip keyboardOpen="</span> + mKeyboardOpen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject flip event</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"/dev/input/event0"</span>);</span><br><span class="line">        f.write(mKeyboardOpen ? FLIP_0 : FLIP_1);</span><br><span class="line">        f.close();</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Got IOException performing flip"</span> + e);</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，这两种方式又是如何将事件注入到系统中呢？再延伸下，Android系统中，触摸事件的来源是什么？又是如何传递到View上？在View中又是如何进行事件分发呢？</p><p>在下面的内容里，我们将从源码中一一找到答案。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>相关源码位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/java/com/android/server/</span><br><span class="line">- SystemServer.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/java/com/android/server/input/</span><br><span class="line">- InputManagerService.java</span><br><span class="line"></span><br><span class="line">frameworks/base/services/core/jni/</span><br><span class="line">- com_android_server_input_InputManagerService.cpp</span><br><span class="line"></span><br><span class="line">frameworks/<span class="keyword">native</span>/services/inputflinger/</span><br><span class="line">- EventHub.cpp</span><br><span class="line">- InputManager.cpp</span><br><span class="line">- InputReader.cpp</span><br><span class="line">- InputDispatcher.cpp</span><br></pre></td></tr></table></figure></p><p>先初步看下Android系统的触摸事件流程图，然后再分解整个流程进行剖析<br><img src="/archives/9f4ea589/触摸流程图.png" alt="触摸流程图"></p><p>将会从以下几个阶段来分析触摸事件的来源与去处：</p><ol><li>捕获触摸事件：对应流程图2-3</li><li>派发触摸事件：对应流程图4</li><li>触摸事件分发：对应流程图5-6</li></ol><h2 id="捕获触摸事件"><a href="#捕获触摸事件" class="headerlink" title="捕获触摸事件"></a>捕获触摸事件</h2><p>说到触摸事件，不得不提到InputManagerService，这是一个系统服务，主要用于处理各种输入事件，包括鼠标、键盘等。该服务在SystemServer进程启动的时候实例化，并注册到ServiceManager中去。<br>[-&gt; SystemServer.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">···</span><br><span class="line">wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">        mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">        !mFirstBoot, mOnlyCore, <span class="keyword">new</span> PhoneWindowManager());</span><br><span class="line">ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>在SystemServer的<code>startOtherServices</code>方法，会发现InputManagerService和WindowManagerService分别进行实例化，且WindowManagerService持有InputManagerService的引用，并注册到ServiceManager中。<br>我们回到InputManagerService中，在该服务的初始化过程中，会发现两个Native方法。<br>[-&gt; InputManagerService.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">(InputManagerService service,</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, MessageQueue messageQueue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure></p><p>根据这两个方法，我们找到对应的JNI方法，即：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == NULL) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    status_t result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过调用流程，会发现跟<code>NativeInputManager</code>相关，此时，我们来看看该类在初始化的过程中做了哪些事情：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="keyword">true</span>) &#123;</span><br><span class="line">···</span><br><span class="line">    sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line">    mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先实例化了EventHub和InputManager，且InputManager会持有EventHub的引用。那么，这两个都是些什么东西呢？首先我们进入EventHub去看看<br>[-&gt; EventHub.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 创建epoll对象，mEpollFd为epoll对象的描述符</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建inotify对象，mINotifyFd为inotify对象的描述符</span></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="comment">// DEVICE_PATH值为"/dev/input"，监听该目录下的设备节点创建与删除操作。通过read函数读取事件</span></span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"Could not register INotify for %s.  errno=%d"</span>,</span><br><span class="line">            DEVICE_PATH, errno);</span><br><span class="line"></span><br><span class="line">    struct epoll_event eventItem;</span><br><span class="line">    memset(&amp;eventItem, <span class="number">0</span>, sizeof(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;    <span class="comment">//监听可读事件</span></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    <span class="comment">// EPOLL_CTL_ADD表示增加事件</span></span><br><span class="line">    <span class="comment">// epoll_ctl将事件监听添加到epoll对象中去</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add INotify to epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major, minor;</span><br><span class="line">    getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line">    <span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">    mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来对于设备事件的监听，即监听<code>/dev/input/event*</code>的节点，主要依靠EventHub，利用Linux的inotify和epoll机制来获取Input事件。关于该部分的详解，可细读该部分的代码，这里不多赘述（关于EventHub和getEvent就不继续往下看了，知道这个深度对于非Framework工程师已经足够）。<br>了解到EventHub的主要功能，我们可以猜测出，InputManager持有其引用，应该是不断的读取设备的事件，并对上层进行分发消费。带着这份猜测，我们继续来看InputManager的代码。<br>[-&gt; InputManager.cpp]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">    <span class="comment">// 事件分发执行类</span></span><br><span class="line">    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">    <span class="comment">// 事件获取执行类</span></span><br><span class="line">    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) :</span><br><span class="line">        mReader(reader),</span><br><span class="line">        mDispatcher(dispatcher) &#123;</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputManager::~InputManager() &#123;</span><br><span class="line">    stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">    <span class="comment">// 事件获取线程</span></span><br><span class="line">    mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">    <span class="comment">// 事件分发线程</span></span><br><span class="line">    mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">        int32_t oldGeneration;</span><br><span class="line">        int32_t timeoutMillis;</span><br><span class="line">        bool inputDevicesChanged = <span class="keyword">false</span>;</span><br><span class="line">        Vector&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">// 监听事件</span></span><br><span class="line">        size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">       <span class="comment">// 处理事件</span></span><br><span class="line">         processEventsLocked(mEventBuffer, count);</span><br><span class="line">       ···</span><br><span class="line">       <span class="comment">// 派发事件</span></span><br><span class="line">        mQueuedListener-&gt;flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>确实印证了我们之前的猜测，这里用到了生产消费者模型，即一条线程不断读取设备事件，另外一条线程不断分发该事件。且事件读取线程用到了epoll机制，避免的性能的损耗。InputReader不断的通过EventHub获取到Input事件，经过<code>processEventsLocked</code>进行简单的封装，再通过<code>mQueuedListener-&gt;flush()</code>进行事件的派发。<br>到这里，捕获触摸事件的流程我们弄清楚里，总结如下：<br><img src="/archives/9f4ea589/捕获触摸事件.png" alt="捕获触摸事件"></p><h2 id="派发触摸事件"><a href="#派发触摸事件" class="headerlink" title="派发触摸事件"></a>派发触摸事件</h2><p>以上，我们知道了触摸事件的来源；现在，我们来关注触摸事件的去处。<br>[-&gt; InputManager.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有挂起的命令，运行分派循环。</span></span><br><span class="line">        <span class="comment">// 分派循环可能会将命令编入队列，以便随后运行。</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行所有存在的挂起的命令。</span></span><br><span class="line">        <span class="comment">// 如果有任何命令运行，则强制下一个轮询立即唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里主要是消息处理模型，如果有input事件的话则被唤醒处理事件，如果没有的话继续睡眠等待。我们主要关注<code>dispatchOnceInnerLocked(&amp;nextWakeupTime)</code>方法，该方法内会对事件类型进行判断并执行不同的处理方法，包括<code>EventEntry::TYPE_KEY</code>、<code>EventEntry::TYPE_MOTION</code>等等，我们只关注触摸事件的处理方式，即。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">        ···</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        ···</span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchMotionLocked(</span><br><span class="line">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ···    </span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">bool</span> conflictingPointerActions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">    <span class="comment">// 找到目标Window</span></span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//  派发</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由以上代码可以看出，对于触摸事件会首先通过<code>findTouchedWindowTargetsLocked</code>找到目标Window，进而通过dispatchEventLocked将消息发送到目标窗口。关于如何找到对应的Window，如何将派发给对应的Window，过程较为复杂，而我们此次仅关注整体流程，故在下篇博客中阐述。</p><h2 id="触摸事件分发"><a href="#触摸事件分发" class="headerlink" title="触摸事件分发"></a>触摸事件分发</h2><p>当触摸事件到达View中时，就涉及到应用端的事件分发机制了。该部分没必要另起介绍了，推荐两个比较优秀的文章：</p><ul><li><a href="http://www.monkeyliu.com/blog/2016/06/17/touchevent/" title="Android触摸事件分发机制" target="_blank" rel="noopener">Android触摸事件分发机制</a></li><li><a href="https://blog.csdn.net/guolin_blog/article/details/9097463" title="Android事件分发机制完全解析" target="_blank" rel="noopener">Android事件分发机制完全解析</a></li></ul><h2 id="解疑"><a href="#解疑" class="headerlink" title="解疑"></a>解疑</h2><p>让我们再次回到文章开始的疑问：</p><ol><li>触摸事件的来源是什么？<strong>InputReader通过EventHub获取到Input事件，并通过InputDispatcher 发出事件通知。</strong></li><li>又是如何传递到View上？<strong>在InputDispatcher找到对应的Window，并将事件发送到Window中。</strong></li><li>在View中又是如何进行事件分发呢？<strong>详见上面推荐的两篇博客。</strong></li></ol><p>最后一个问题，<code>InputManager.getInstance().injectInputEvent</code>又是如何进行事件注入的了。让我们从源码中来找到答案：<br>[-&gt; InputManagerService.java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span> <span class="comment">// Binder call</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">injectInputEvent</span><span class="params">(InputEvent event, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> injectInputEventInternal(event, Display.DEFAULT_DISPLAY, mode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">injectInputEventInternal</span><span class="params">(InputEvent event, <span class="keyword">int</span> displayId, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"event must not be null"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mode != InputManager.INJECT_INPUT_EVENT_MODE_ASYNC</span><br><span class="line">              &amp;&amp; mode != InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH</span><br><span class="line">              &amp;&amp; mode != InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mode is invalid"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> pid = Binder.getCallingPid();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> uid = Binder.getCallingUid();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          result = nativeInjectInputEvent(mPtr, event, displayId, pid, uid, mode,</span><br><span class="line">                  INJECTION_TIMEOUT_MILLIS, WindowManagerPolicy.FLAG_DISABLE_KEY_REPEAT);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          Binder.restoreCallingIdentity(ident);</span><br><span class="line">      &#125;</span><br><span class="line">···</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>应用通过Binder调用到InputManagerService中的方法，并且调用到Native方法<code>nativeInjectInputEvent</code>，让我们再次跟随源码的脚本进入<code>com_android_server_input_InputManagerService.cpp</code>到中：<br>[-&gt; com_android_server_input_InputManagerService.cpp]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">nativeInjectInputEvent</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jobject inputEventObj, jint displayId, jint injectorPid, jint injectorUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint syncMode, jint timeoutMillis, jint policyFlags)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsInstanceOf(inputEventObj, gKeyEventClassInfo.clazz)) &#123;</span><br><span class="line">        KeyEvent keyEvent;</span><br><span class="line">        <span class="keyword">status_t</span> status = android_view_KeyEvent_toNative(env, inputEventObj, &amp; keyEvent);</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            jniThrowRuntimeException(env, <span class="string">"Could not read contents of KeyEvent object."</span>);</span><br><span class="line">            <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (jint) im-&gt;getInputManager()-&gt;getDispatcher()-&gt;injectInputEvent(</span><br><span class="line">                &amp; keyEvent, displayId, injectorPid, injectorUid, syncMode, timeoutMillis,</span><br><span class="line">                <span class="keyword">uint32_t</span>(policyFlags));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (env-&gt;IsInstanceOf(inputEventObj, gMotionEventClassInfo.clazz)) &#123;</span><br><span class="line">        <span class="keyword">const</span> MotionEvent* motionEvent = android_view_MotionEvent_getNativePtr(env, inputEventObj);</span><br><span class="line">        <span class="keyword">if</span> (!motionEvent) &#123;</span><br><span class="line">            jniThrowRuntimeException(env, <span class="string">"Could not read contents of MotionEvent object."</span>);</span><br><span class="line">            <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (jint) im-&gt;getInputManager()-&gt;getDispatcher()-&gt;injectInputEvent(</span><br><span class="line">                motionEvent, displayId, injectorPid, injectorUid, syncMode, timeoutMillis,</span><br><span class="line">                <span class="keyword">uint32_t</span>(policyFlags));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Invalid input event type."</span>);</span><br><span class="line">        <span class="keyword">return</span> INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里，惊不惊喜，意不意外，其实并没有什么精妙或者牛逼的处理方式，就是直接获取到InputDispatcher对事件进行分发。殊途同归，最终还是回到了最开始的地方。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我们来总结下整个触摸事件的流程：</p><ol><li>InputManagerService在SystemServer中初始化，并向ServiceManager进行注册</li><li>初始化过程中生成InputManager和EventHub实例，InputManager持有EventHub的引用</li><li>InputManager实例化InputReader和InputDispatcher</li><li>InputReader通过EventHub监听Input事件</li><li>InputDispatcher进行事件的派发，即先找到对应的Window，并将Input事件传到该Window</li><li>Input事件传到应用，进入到View的事件分发，通过<code>dispatchTouchEven</code>、<code>onInterceptTouchEvent</code>等方法进行选择性分发</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://source.android.com/devices/input/touch-devices" title="Android触摸设备" target="_blank" rel="noopener">Android触摸设备</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上篇文章&lt;a href=&quot;http://yunlinos.com/archives/ff7c0d4a.html&quot; title=&quot;Andro
      
    
    </summary>
    
      <category term="Android系统源码" scheme="http://yunlinos.com/categories/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="触摸事件" scheme="http://yunlinos.com/tags/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android Monkey源码解析</title>
    <link href="http://yunlinos.com/archives/ff7c0d4a.html"/>
    <id>http://yunlinos.com/archives/ff7c0d4a.html</id>
    <published>2018-08-03T06:57:41.000Z</published>
    <updated>2018-08-04T01:59:29.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间在梳理公司的自动化测试脚本时，发现Monkey是个挺有意思的工具，它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试，这个倒很像一个梗<code>π里面藏着一部莎士比亚</code>。比较好奇它的实现原理，于是就有了研究源码的想法，说干就干，Read the Fucking Source Code。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>先将源码从系统中导出，我手头的AOSP是Android 5.1</p><ul><li>Monkey程序由Android系统自带，使用Java语言开发。在Android文件系统中的存放位置为：<code>/system/framework/monkey.jar</code>。在源码中的位置为<code>/development/cmds/monkey</code></li><li>Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本位于Android文件系统中：<code>/system/bin/monkey</code>。在源码中的位置为<code>development/cmds/monkey/monkey</code></li></ul><p>下面，就将开始Monkey的源码阅读之旅。</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>Monkey是由system/bin/monkey脚本启动system/framework/monkey.jar。下面是monkey脚本的内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Script to start "monkey" on the device, which has a very rudimentary</span><br><span class="line"><span class="meta">#</span> shell.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">base=/system</span><br><span class="line"><span class="meta">#</span> 设置monkey的CLASSPATH环境变量指向monkey.jar</span><br><span class="line">export CLASSPATH=$base/framework/monkey.jar</span><br><span class="line">trap "" HUP</span><br><span class="line"><span class="meta">#</span> 通过app_process指定monkey的入口和传进来的所有参数启动上面CLASSPATH设定的monkey.jar</span><br><span class="line">exec app_process $base/bin com.android.commands.monkey.Monkey $*</span><br></pre></td></tr></table></figure></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>可以通过adb命令执行Monkey脚本<code>adb shell monkey -p com.android.settings 500</code>，其基本流程如下：</p><ul><li>解析命令行参数</li><li>根据命令行参数选择不同的事件输入源，也就是事件源是从网络过来还是通过内部随机产生</li><li>跳入runMonkeyCycle方法针对不同事件源获取并开始执行不同的事件</li></ul><ol><li><p>入口在main方法，代码位于com.android.commands.monkey.Monkey.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Command-line entry point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args The command-line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Set the process name showing in "ps" or "top"</span></span><br><span class="line">        Process.setArgV0(<span class="string">"com.android.commands.monkey"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> resultCode = (<span class="keyword">new</span> Monkey()).run(args);</span><br><span class="line">        System.exit(resultCode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>解析输入参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the command!</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args The command-line arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Returns a posix-style result code. 0 for no error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">···</span><br><span class="line">        <span class="keyword">if</span> (!processOptions()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>根据输入的参数选择不同的事件输入流</p></li></ol><ul><li>MonkeySourceScript：通过相应的规则编写monkey脚本来驱动monkey进行事件注入，为非随机事件</li><li>MonkeySourceRandomScript：随机内部事件源，由脚本来触发，为随机事件</li><li>MonkeySourceNetwork：由网络（比如MonkeyRunner）发送过来的事件</li><li>MonkeySourceRandom：由monkey内部产生的随机事件集<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mScriptFileNames != <span class="keyword">null</span> &amp;&amp; mScriptFileNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// script mode, ignore other options</span></span><br><span class="line">    mEventSource = <span class="keyword">new</span> MonkeySourceScript(mRandom, mScriptFileNames.get(<span class="number">0</span>), mThrottle,</span><br><span class="line">            mRandomizeThrottle, mProfileWaitTime, mDeviceSleepTime);</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line"></span><br><span class="line">    mCountEvents = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mScriptFileNames != <span class="keyword">null</span> &amp;&amp; mScriptFileNames.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mSetupFileName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceRandomScript(mSetupFileName,</span><br><span class="line">                mScriptFileNames, mThrottle, mRandomizeThrottle, mRandom,</span><br><span class="line">                mProfileWaitTime, mDeviceSleepTime, mRandomizeScript);</span><br><span class="line">        mCount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceRandomScript(mScriptFileNames,</span><br><span class="line">                mThrottle, mRandomizeThrottle, mRandom,</span><br><span class="line">                mProfileWaitTime, mDeviceSleepTime, mRandomizeScript);</span><br><span class="line">    &#125;</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line">    mCountEvents = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mServerPort != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mEventSource = <span class="keyword">new</span> MonkeySourceNetwork(mServerPort);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Error binding to network socket."</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mCount = Integer.MAX_VALUE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// random source by default</span></span><br><span class="line">    <span class="keyword">if</span> (mVerbose &gt;= <span class="number">2</span>) &#123; <span class="comment">// check seeding performance</span></span><br><span class="line">        System.out.println(<span class="string">"// Seeded: "</span> + mSeed);</span><br><span class="line">    &#125;</span><br><span class="line">    mEventSource = <span class="keyword">new</span> MonkeySourceRandom(mRandom, mMainApps, mThrottle, mRandomizeThrottle);</span><br><span class="line">    mEventSource.setVerbose(mVerbose);</span><br><span class="line">    <span class="comment">// set any of the factors that has been set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MonkeySourceRandom.FACTORZ_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactors[i] &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">            ((MonkeySourceRandom) mEventSource).setFactors(i, mFactors[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in random mode, we start with a random activity</span></span><br><span class="line">    ((MonkeySourceRandom) mEventSource).generateActivity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>循环执行事件<br>run方法根据参数从不同的事件源获得事件并放入到EventQueue后，就会开始执行一个循环去从EventQueue里获取事件进行执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">···</span><br><span class="line">        mNetworkMonitor.start();</span><br><span class="line">        <span class="keyword">int</span> crashedAtCycle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            crashedAtCycle = runMonkeyCycles();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the rotation lock if it's still held and restore the</span></span><br><span class="line">            <span class="comment">// original orientation.</span></span><br><span class="line">            <span class="keyword">new</span> MonkeyRotationEvent(Surface.ROTATION_0, <span class="keyword">false</span>).injectEvent(</span><br><span class="line">                    mWm, mAm, mVerbose);</span><br><span class="line">        &#125;</span><br><span class="line">        mNetworkMonitor.stop();</span><br><span class="line">···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>runMonkeyCyles方法会根据不同的数据源开始一条条的获取事件并进行执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">MonkeyEvent ev = mEventSource.getNextEvent();</span><br><span class="line"><span class="keyword">if</span> (ev != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> injectCode = ev.injectEvent(mWm, mAm, mVerbose);</span><br><span class="line">    <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_FAIL) &#123;</span><br><span class="line">        System.out.println(<span class="string">"    // Injection Failed"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyKeyEvent) &#123;</span><br><span class="line">            mDroppedKeyEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyMotionEvent) &#123;</span><br><span class="line">            mDroppedPointerEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyFlipEvent) &#123;</span><br><span class="line">            mDroppedFlipEvents++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev <span class="keyword">instanceof</span> MonkeyRotationEvent) &#123;</span><br><span class="line">            mDroppedRotationEvents++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_ERROR_REMOTE_EXCEPTION) &#123;</span><br><span class="line">        systemCrashed = <span class="keyword">true</span>;</span><br><span class="line">        System.err.println(<span class="string">"** Error: RemoteException while injecting event."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (injectCode == MonkeyEvent.INJECT_ERROR_SECURITY_EXCEPTION) &#123;</span><br><span class="line">        systemCrashed = !mIgnoreSecurityExceptions;</span><br><span class="line">        <span class="keyword">if</span> (systemCrashed) &#123;</span><br><span class="line">            System.err.println(<span class="string">"** Error: SecurityException while injecting event."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't count throttling as an event.</span></span><br><span class="line">    <span class="keyword">if</span> (!(ev <span class="keyword">instanceof</span> MonkeyThrottleEvent)) &#123;</span><br><span class="line">        eventCounter++;</span><br><span class="line">        <span class="keyword">if</span> (mCountEvents) &#123;</span><br><span class="line">            cycleCounter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mCountEvents) &#123;</span><br><span class="line">        cycleCounter++;</span><br><span class="line">        writeScriptLog(cycleCounter);</span><br><span class="line">        <span class="comment">//Capture the bugreport after n iteration</span></span><br><span class="line">        <span class="keyword">if</span> (mGetPeriodicBugreport) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cycleCounter % mBugreportFrequency) == <span class="number">0</span>) &#123;</span><br><span class="line">                mRequestPeriodicBugreport = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Event Source has signaled that we have no more events to process</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行事件主要为与MonkeyEvent的injectEvent方法，例如MonkeykeyEvent事件的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">injectEvent</span><span class="params">(IWindowManager iwm, IActivityManager iam, <span class="keyword">int</span> verbose)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verbose &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        String note;</span><br><span class="line">        <span class="keyword">if</span> (mAction == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">            note = <span class="string">"ACTION_UP"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            note = <span class="string">"ACTION_DOWN"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">":Sending Key ("</span> + note + <span class="string">"): "</span></span><br><span class="line">                    + mKeyCode + <span class="string">"    // "</span></span><br><span class="line">                    + MonkeySourceRandom.getKeyName(mKeyCode));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">":Sending Key ("</span> + note + <span class="string">"): "</span></span><br><span class="line">                    + mKeyCode + <span class="string">"    // Unknown key event"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyEvent keyEvent = mKeyEvent;</span><br><span class="line">    <span class="keyword">if</span> (keyEvent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> eventTime = mEventTime;</span><br><span class="line">        <span class="keyword">if</span> (eventTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            eventTime = SystemClock.uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> downTime = mDownTime;</span><br><span class="line">        <span class="keyword">if</span> (downTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            downTime = eventTime;</span><br><span class="line">        &#125;</span><br><span class="line">        keyEvent = <span class="keyword">new</span> KeyEvent(downTime, eventTime, mAction, mKeyCode,</span><br><span class="line">                mRepeatCount, mMetaState, mDeviceId, mScanCode,</span><br><span class="line">                KeyEvent.FLAG_FROM_SYSTEM, InputDevice.SOURCE_KEYBOARD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!InputManager.getInstance().injectInputEvent(keyEvent,</span><br><span class="line">            InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MonkeyEvent.INJECT_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上，基本就完成了整个事件注入的流程</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Monkey的软件架构图：<br><img src="/archives/ff7c0d4a/Monkey结构图.png" alt="你想输入的替代文字"></p><p>Monkey的工作原理图：<br><img src="/archives/ff7c0d4a/自动化测试架构图.png" alt="Monkey的工作原理图"></p><p>再次总结下其工作流程如下：</p><ol><li>由<code>system/bin/monkey</code>启动Monkey进程</li><li>解析命令行参数</li><li>根据输入的参数选择不同的事件输入流：是从网络过来还是通过内部随机产生</li><li>跳入runMonkeyCycle方法针对不同事件源获取事件</li><li>向系统注入事件</li></ol><p>另外，关于如何向Android中进行事件注入，将在下篇博客中展现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间在梳理公司的自动化测试脚本时，发现Monkey是个挺有意思的工具，它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等
      
    
    </summary>
    
      <category term="Android系统源码" scheme="http://yunlinos.com/categories/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Android" scheme="http://yunlinos.com/tags/Android/"/>
    
      <category term="Monkey" scheme="http://yunlinos.com/tags/Monkey/"/>
    
      <category term="自动化测试" scheme="http://yunlinos.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yunlinos.com/archives/4a17b156.html"/>
    <id>http://yunlinos.com/archives/4a17b156.html</id>
    <published>2018-08-01T12:23:53.033Z</published>
    <updated>2018-08-04T01:09:04.963Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到YunLin的博客，本博客基于<a href="https://github.com/" title="Github" target="_blank" rel="noopener">Github</a>和<a href="https://hexo.io/zh-cn/" title="Hexo" target="_blank" rel="noopener">Hexo</a>搭建，使用<a href="https://github.com/iissnan/hexo-theme-next" title="NexT.Mist" target="_blank" rel="noopener">NexT.Mist</a>主题。在阿里云购买的域名，分别为<a href="http://yunlinos.com/" title="www.yunlinos.com">www.yunlinos.com</a>和<a href="http://yunlinos.cn/" title="www.yunlinos.cn" target="_blank" rel="noopener">www.yunlinos.cn</a>。</p><p>在这里，坚决减少记录性内容，避免环境的简单搭建；多些源码的解读、架构的思考、底层的原理，确保内容高质量。</p><p>现阶段内容包括不限于：</p><ul><li>开源项目的源码解读，偏向于设计思想和优秀的代码实现</li><li>Android源码的实现，偏向于功能的原理性解读</li><li>深耕计算机网络、Java虚拟机方面</li></ul><p>当然，最重要的还是坚持，让更多的人得到帮助，也让自己的成长滴水成河。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到YunLin的博客，本博客基于&lt;a href=&quot;https://github.com/&quot; title=&quot;Github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;和&lt;a href=&quot;https://hexo.io/zh-cn/
      
    
    </summary>
    
      <category term="个人思考总结" scheme="http://yunlinos.com/categories/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yunlinos.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
